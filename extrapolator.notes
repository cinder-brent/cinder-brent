We use an array when we need something to be iterable

Ok, so what we have here is...we have a system...we have a system where we're using XML to store all the data, and what we
do is...ok so lets say we have a client, "Cinder", now would we have clients or projects? I mean ok, like, if we have XML we
can go ok, we have a "project", or something like a "project", then we go ok, we have project details like a name and
description, then we have stuff like invoicing. So we could have a project that could have an invoice, so ok like we would
go ok we have a project, then we have a client, then we have an invoice, now what if all of this stuff is maleable? Like ok
lets say we have a project that doesn't involve any invoicing (free work), so we go ok we have a project, then we have a
client, then we have...what if we make an art out of it? So we go ok we have clients and we have projects...what if we have
one or the other? Basically, is Cinder a client? No, Cinder isn't a client. At least I don't think so. So freaking ok, now,
lets say we have Cinder, then we have projects under Cinder (by Cinder). Now we go ok, we have a project that is for a
client, so do we put the project under the client or put the client under the project? If we have Cinder, then we have
projects, we would therefore put clients under projects, but this doesn't really work, because clients can have multiple
projects (ideally). So what we would do is go ok, we can have projects under clients and clients under projects...ok we can
have clients with projects, but we can't have projects with clients. Or can we? What if we have a project that yields a
client, does that mean we have a client under a project? Umm...historically that is what that would be...historically we
would have a project that would have a new client that wanted something done based off of that project, so we would have a
client based off of a project, whereas otherwise we would have a project based off of a client, so we have both. So ok, we
go ok, now what this means is that the interpreter would have to account for this by basically having...ok so lets say we
have a client and a project under that client, the interpreter would have to interpret the client, then it would have to
interpret the project. Now, the thing is it would have to interpret clients and projects completely independent of one
another, so freaking ok, we would go ok, we have...either one dude. That's totally what that is. So basically by the time
you design this thing you're done and it's all history. So freaking ok, now how do we do this? What we would do is go ok,
build a simple interpreter for some simple XML (clients and projects) and interpret a client or a project. Then, interpret
the other (from within). So ok lets do this bad boy.

So freaking ok, my first thoughts are what if we just had straight XML to store all this data, and we pick through it at
will? Like ok we go ok, we take in a new client, we put...we take in some XML (any old XML), then we go ok, we just manually
work with that XML to get the job done. This makes a lot of sense because it is so fast. All we do is input/output the raw
XML. It works. It freaking works. Is there a case where we wouldn't want this to be how we're doing things? Umm...ok,
umm...the only thing I can think of is an interface that displays this data, where you can update the data at will and
stuff, but I can't think of why I would need the interface. Why would you want this interface? When it came down to
centralizing all data we would need to translate this XML (and everything else) into an easy-to-use client interface. On
this interface they would be able to input/output their data at will. So lets say we start working with a client, we go ok,
lets say they have a secure place that they can put in their information, so like ok they go ok, they can...upload content
(images/video/etc.), type content (rich-text), add anything (notes/etc.), and so on and so forth. So ok we go...now we have
this interface...they upload some content, make some XML...beautiful idea. Now ok, we go...this interface would be string-
based...it would be string because if we interacted with the server (php), the server returns string. So we go ok, we...
dude this is so interesting...so freaking ok we go ok, now we would input/output string. Are you SURE this is right? It's
ALWAYS going to be string. ALWAYS. 100% of the time? Umm...yea it's string. Even if it's not we can always come back and
fix it. So ok, we go we have some string, then we do stuff with the string. The first thing that comes to mind is storing
the string. How would we store this string? Umm...ok lets say we have a client that needs (for some reason) to give us
more than one of something. So we go ok, we have an interface for inputting these things, then we go ok, umm...would we
ever need to do this? Umm...freaking...well...I have no idea. I mean yea we would probably need to do this at some point,
just I don't know what that is. So freaking ok lets go back to the point where we have some XML, and we are coming up with
a user-interface for this XML. Do we have XML? Or do we have something else? XML is good because of its' syntactical
structure. It's very easy to deal with on the view. This is why I prefer XML at this point. The thing is, what it really
is is string. Hmm! Ok so we have some string, now how do we...are you SURE this is string? Umm lets just go with it and if
we need to fix it in the future we can do so. So ok we have some string, then we have interpretation of this string. So ok,
the string would be the view, then we would take that string and do stuff with it: put it on the server, store it
somewhere, transform it, etc. So ok we have some string...so that blows all of pretty much everything to smitherines. We
would no longer specifically use MariaDB/XML/etc. to do this, we would use string (which would come before all of this
other stuff). So we go ok, now what?

Ok, so now we have some string, so ok your whole system is made out of string then. So you can type notes, put anything
you want in the computer, and the thing is string. Ok. So freaking ok, we go ok...now how do we organize/deal with this
string? How can we centralize all of this string in such a way...do we NEED to do this? Ok so lets say we have a client,
and for this client we have some string: now we pick through the string (and stuff like that) with regular expression/etc.
So freaking ok, now...dang dude...so freaking lets say we have some data for a client:

Client name: Test client
Client data: Hello world

Now we have to pick through...yea this works. It works because its' quick and dirty, yet fully-capable. Ok.

So now, where do we go from here? Ok so if we build our code-generator, we go ok, we bust out a website: we have multiples
covered, we just have to design the rest (the singularity) of the site. So there's 1 thing going on...is there ANYWHERE
else where there are multiples going on? Umm...freaking...wow dude this is nuts. This is freaking nuts McButts! Umm...
freaking ok, so like we have some string...so ok what if we grid out the string and go ok, we can splice anywhere in the
string...so we have string and we have splice, then what? Then we freaking go ok, umm...freaking ok, what do we do dude?
LoL. So we go ok, we have some string, now what we do is take this string and...freaking do everything with it, so just
start hacking at it.

Ok, so to start, we would have a system, based off this string, that would be like we said: it would be (partly) an easy-
to-use user-interface that would allow for clients (users) to easily input data about their site (content (for static
pages), etc.). Ideally this would extend all the way to Cinder, so we could generally organize our data and stuff like
that. Like we would have a thing where we could input/output information in Cinder just like the user-interface. So the
fundamental structure of this thing would be recursive: you could put this system in any point of Cinder (or anything else,
for that matter). So freaking ok, we go...we would escape our string and comma-seperate (or somehow seperate) our data,
then we would interpret this data...ok so the interpretation is seperate from the data, and the data is (basically) easier
to work with. Ok. Now, we interpret this escaped, comma-seperated string...now what do we do with it? So we would go ok,
we freaking...hmm...dang this is so interesting. So then we interpret the data. We process the data. We take the raw
string and process it (for whatever we're doing with it). We manipulate it, store it, etc. Ok so lets say we have a test
of this process. We fire up php, withdraw some data from MariaDB, and output it to the client. So freaking we fire up PHP,
withdraw the data, and output it to the client, all with string. It freaking works. Ok, now, generally speaking what are
we doing when we do something like this? Or basically how do we do this? Umm I'ma smoke one. So freaking ok, you have
string, then you have an interpreter. You would have string, any string, string. Then you would have either string or
interpreted string. Freaking ok, so what does this interpreter do? So in general we would interpret string (or we 
wouldn't). So freaking ok, ummm...we would have some string. Where would we get the string from/in general, how does the
string exist? We could simply type the string in, we could take it in from places like cameras/etc. So freaking ok, umm...
yea how do we come up with string? I mean ok we could just jump ahead to the interpreter, but we have to figure ok what are
we interpreting? We're interpreting string, but what is the string? If we format the string, how do we come up with the
string? Ok lets take a test case: we take in some string from a client, two things, a name and a description. Now ok, we
format this string and pass it to an interpreter, so like we escape each of the strings and join them with a comma, then
we pass that string to an interpreter. So ok, umm...the interpreter breaks them apart at the comma, unescapes the resulting
strings and then what? Then it freaking...huh...then it does whatever it's going to do with the strings (it could do
anything: manipulate them, store them, etc.). So freaking ok, umm...I'm starting to run in circles.

So yea in general we have string. We could interpret numbers, objects, functions, anything with string. So freaking ok...
now what if we had an auto-interpreter that interpreted numbers/objects/etc.? Bleh.

Hmm...

Ok so should we start building? Or should we sit here some more and blow around in the wind? I mean the thing is, we
freaking realized that if there was no difference (in a bad way) and we went in a circle, we'd be better off trying to do
something big. So freaking ok, we might as well freaking imagine our way out of here! Freaking ok, so do we want to start
building this bad boy or play WoW and sit around or something? Umm...well, we're making headway working in our head, so
like ok, we might as well just sit around and drink coffee or something and think. But I mean if you want to get to work,
by all means let it rip. You should see if you can get it down:) That would be so bad if you could. Freaking brute force
nine.

So freaking ok, if we WERE to get to work, what we would need to do (at least) is build this thing to be able to be
updated as easily as possible, so like we take...ok so we have a grid (of syntax), and we code this grid, and we can splice
this grid at will, and we go ok, we code the thing, then we edit it (when we update it) with the grid, and freaking that's
how we do things. This way everything would be all buttoned up and that is the end of it. Freaking ok, umm...so freaking
ok, what we do is we have a system made of string, and we go ok, we freaking...hmm...ok so it's definitely string, and we
SHOULD be able to build it based off of that (and thats it!). So freaking ok, should we start building? It would be
BEAUTIFUL to just start and it works and bam, it's done and everything's good. I mean holy shit dude, that would be such a
kick in the pants. Ok dude, lets start.


Ok so lets plan this thing out. I'm sitting here staring at the screen and I'm like a little pseudo would probably go a long
ways. 

So freaking ok, we would have Cinder, which would (?) create and manage plugins, so ok we have to decide at this point
whether this is within the scope of Cinder. Should this be an extension of Cinder, or directly Cinder itself? Any definition
is not fundamental enough to be Cinder, so defining a plug-in is therefore outside of the scope of Cinder, so we would go ok
we need to be able to extend Cinder or something like that. So is it an extension, a plug-in? Does it matter? Umm ok, so we
would go something like ok, is it even one of the two? Whatever it is, it's something like an extension, so we'll start
there. So we would have an extension called "Fractal" that would create and manage plug-in's for systems like WordPress,
etc. So ok we go now if we call this Fractal what do we call our CMS? Cinder? Umm...ok so we need to figure that out. We
figure the answers will surface as we build this thing, too, so maybe lets just start going at it, or continue going at it.
So ok, now we go this extension creates and manages "plug-in's" that are potentially standalone so they can be used with
systems like WordPress. Ok, so now we go ok, shouldn't we just have a single interface...both dude. Totally build both. Then
we should probably go something like ok, now what are we doing here that is potentially redundant? Like ok, if we have the
thing extend Cinder and build plug-in's and stuff like that, what does it and Cinder have in common (that could be reduced
to a single thing)? Freaking ok, umm...so somewhere in here...dude this is freaking badass...ok so if the extension of
Cinder creates and manages plug-in's, freaking...ok, so it would have CRUD for plug-in's, now what would Cinder have? Umm...
it would have CRUD for extensions. So we would have CRUD, then we would have a single thing that was both an extension and
a plug-in. We could call this an element (one element of an array). Ok so whatever it is, it has CRUD, so we can get rid of
that. Now we just go ok, we have two things: a plug-in and an extension. So ok, what is a plug-in and what is an extension?
Or ok, at that point we have two things, so we go ok, we freaking...we have two things...how pure are these two things? Are
they elements? Umm...dude this is so badass...we can just relatively get the thing down dude. Enough relative organization
and it will be down. Freaking ok, so if there are two possibilities...ok dude if that array is an element...an array isn't
an element. Ok so that isn't pure, but it's better! It's more fundamental. So ok from there what else would we need? So we
have an array of elements, and we have CRUD for those elements, then what? 

Ok dude consider this, looking at the big picture at this point: you have a system made of string wherein you would ideally
have potential splices upon that string. These splices would define changes in scopes in the code, these changes would
define changes in the version. So what you do is make the code out of splices and count version changes accordingly. Primo
dude! This sounds good, this sounds real good. Then we would have all this stuff inside of Cinder, our main and central
system, and freaking...umm...then we would have extensions or plug-in's for Cinder that would do stuff like create
plug-in's and stuff like that. So freaking ok, umm...we would go...ok so these plug-in's/extensions that would have CRUD
would be string (just like everything else), so ok, if everything is string and we have a system of splicing to deal with
this string...freaking...ok...dude make this thing freaking so big it's not even funny. Like freaking humongous. Ok dude,
so freaking...umm...how do we freaking do this? So ok if we have two elements at the beginning of the line...what...what is
different about these two things? If we know what is different between these things we know what we need to do to further
generalize everything. So ok what's the difference between an "extension" of Cinder and a "plug-in" of an "extension" of
Cinder? Umm...ok so these too would be string, and we would interpret that string...so if the interpretation is the same
we (finally) have an element, which is ideal. Ok so fundamentally there would be no difference between these two things, so
it's not the string itself but the interpretation of the string that is what we would need to figure out. So ok, we have
some string...now how do we interpret this string? CRUD? We would have some string, and we would splice that string, and
that is it! That is all we would need to do...we would have some string, and all we could potentially do with that string
is splice it. So that's it, string and splice. So ok, all you would need is splice! That would be like the element of the
thing...if not that string. Anyways, so it's string, because string is a "thing". Splice isn't really a thing, and we need
a noun to do this, so I mean. If we're wrong we can always fix it later down the line.

Ok, so we have splice/string, now what? Ok so we would have some string and we would splice it, so I mean...is that the
element? Is that the head of the element poking through? I'ma smoke one. Ok dude lets flow.

So freaking ok, umm...so we would have some string and we would splice it, or we could just write a function that splices
string and splice some string out of nowhere and pow, we have a fundamental point of splice. Ok so freaking...does this
work? Wow dude, so ok for the CRUD we would have...we would splice the string. If we want to create the string, we splice
it out of nowhere, if we want to update the string, we splice it as necessary, if we want to read it, we splice it to the
view, if we want to delete it, we splice it out of existence. This makes a lot of sense. Even if like we just put the new
string...huh...

So we would have some string...we would have a splice function that would return some sort of string (even if empty). So
ok, now, what we do is go ok, we figure out what ONE of these things is and then go from there. So it would be a string, a
single column that was a string. Then we would go ok, now...ok so the point of this thing is that it can handle multiples,
across the board. So if we had one of these things, how would it go? It would go ok, we have some PHP, we store this one
thing in Maria and...call it forth and process it. So we have this one thing on Maria. Now, if we have more than one of
these, how will it go? What is this one thing with multiples in mind? So it could (or couldn't) have children, it could (or
couldn't) be orderable, it could (or couldn't) be unique, ...you need to program one of these. Ok so if it can have
children (and siblings), we have an array holding these things, then lets say we have two of them, and the second one has
children. They both could have order ID's to order them. The children of the second one would be linked by parent ID's.
Now, what if we have children from other tables? We would need a table of table ID's to link all this stuff together. Or
does it even make sense to do that?

Ok what if we took some string and broke it down to binary, and we went ok each bit represents a class, and whatever the
value of the bit is determines whether the binary, as a whole, is an instance of that class or not? Then we extend all the
potential classes, one by one, and create an instance of the resulting class, which IS the binary as a whole. Or, what if
each bit was an instance of a class, in descending order? Each class would have CRUD and it's value as a string. We could
therefore generate these classes dynamically and create some kind of pseudo-binary. Like ok ideally, we would want the
thing to be the whole binary string, but we could compose that string of classes representing each bit of the binary. Very
neat, clean, etc. Then we compose the binary out of these and we have the binary, as a whole. Each bit would have a value
of 0 or 1, of course.

Ok so basically all we need is a string-editor. I mean ok, does this really work, though? Whatever those things are, if
they aren't string we can just swap them out at any point in time. Oh freaking kay dude...umm...so freaking...umm...ok so
whatever these things are...ok if you can make ONE of these things, the whole thing is hard-wired (in terms of CRUD and
anything like that). That's freaking bad dude. Ok man, so...

Ok so one of these things would be at least string. It would potentially be string (just some text or something), so it's
at least string. Now, anything we recieve from the server is in string, so the inner-workings of this thing are in string.
So ok, we go...again, even if it isn't string, we can fix it. We haven't even started coding yet. So freaking ok...umm...
lets smoke one...or no? Let's sit here and figure this out. So you have string and splice...ok go on, we can just come back
and fix it if we're wrong. Ok, so now lets say we code some of the inner-workings of this thing. How would the database
commands go? We would go ok, we CRUD our database...so we would have so much database syntax, and what we do is we trace
that syntax to figure out just how far the rabbit hole goes.

Ok so if we do that we end up with a finite amount of syntax...there's only so much you can do with a database...and we
have string, ok go on.

From there we process this string with PHP, so the whole thing should be seamless, string in, string out.

So ok, we would go...we would have PHP, which would interact with MariaDB. All we need here is a class to deal with
database interactions. This class (or whatever) would: "CREATE" databases and tables, "INSERT" table rows, "UPDATE" table
rows, "DELETE" table rows, and "SELECT" table rows. This is basically it. Any further detail can be hammered out at will.

So ok, from there we have all of our data in and out of PHP, and as far as the server-side code of the thing is concerned
thats it! So what we need to do is tinker out the details about how this works in PHP and we're good.

So ok, before we build this thing, are we SURE that we have it right?

So all of the elements would be all over the place, and the whole thing would be all over the place. Completely objective.
So how do we code this? Umm...so ok if we have some string...so ok relatively speaking (at least) we would need some string
(a non-empty string) to work with for this to work. Technically speaking we could have an empty string and it would still
work, just for surgical reasons at this point I'm saying that we need non-empty string. Basically we just need something to
work with. So ok, umm...what if it's a full-bodied array (with nesting)? Does that satisfy our objective requirement? Yes.
If it doesn't we can work it out when we get there.

Ok, so you have the thing working, now lets build it? Umm...ok...so now what if we want something weird, like some
multiples in the core of the code? Umm...freaking...hmm...it's all string so we could just put them in there. Just manually
put them in there.

Umm ok, so you have multiples...so you'd have an array...then what? Then you'd fill the array with anything: objects,
strings, more arrays, anything. Then we logically loop through...then we'd logically loop through the types and do stuff
based on what type something was. So ok, we SHOULD be able to figure this out with syntax, so...there's a way to do it,
either way. So we go ok, we loop through the array, we do stuff with the elements...this makes a lot of sense because you
could come up with a fairly automatic system that would take array elements and generate code based on those array
elements. Or something like that. Umm ok, so...freaking ok, umm...what do we do here? So we freaking...what good is this?
Ok so if you check types, you run through types and do something based on the type. So what then? Ok so the available types
are:


"boolean"
"integer"
"double" (for historical reasons "double" is returned in case of a float, and not simply "float")
"string"
"array"
"object"
"resource"
"resource (closed)" as of PHP 7.2.0
"NULL"
"unknown type"

So a boolean would just be some data, as would integer, double, string, and null. Array would need to be looped again,
object would need to be logically handled (invoked/etc.), resource would be passed to something that could use it,
resource (closed) would be...ignored(?), and unknown type would have to be sniffed and dealt with...or something. So ok,
lets say with objects we iterate through them looking for functions or something...do we invoke __construct on each
one? Or what? I mean the way you create objects in PHP is by creating instances of classes, so umm...yea it would be
something like that. But why would we do this when the __construct function is called when we instantiate the class? This
whole methodology falls apart at that point. There's no point to bottlenecking types, therefore. We'll have to take some
other route about what we're doing. No biggy, swhat we're doing.

So ok, we want to generalize everything, to a point. So ok, we want to go beyond making websites, when we do this, and
generalize EVERYTHING. Now, how do we go about doing this? Or should we freaking get to work? God this is annoying. Every
dang time I get to work it comes down to grinding along or working on more fundamental stuff. Honestly we have to keep both
going, so get to work dude!

Ok, so freaking...if this thing is string based, that's one thing, and it should, therefore, fundamentally work. So I mean,
umm...how do we do it? If we break PHP down we're one step closer to our goal, so freaking...ok if we break PHP down (I
know this doesn't sound very appetizing, but in short, it really does!) we just translate that to whatever it is we're
going for and we're done. Like if we break PHP down, then all we have to do is analyze what we did to come up with an idea
of how to do what we're trying to do. Relatively speaking that's all you need to do to do this, and it's better than
nothing (sitting here staring at the screen).

So ok, what is a type, in PHP? We'll make a programmer out of you yet! So ok a type...why a type? We figure we would use
types to delineate the difference between multiple things in PHP. Does this make sense? Umm...hmm...before you know what to
do with a type, it makes no sense to detect it. The two, the checking of the type and the doing something with the type,
are therefore one and the same.

So ok, what do we do? Umm...freaking...freaking a dude...ok, so, if we make this thing...if we have string(s), when it
comes down to it, we go ok, we need CRUD on those strings and thats it. So ok we put some CRUD on a string and thats it.
We have one set of CRUD for one set of strings. Ok, so lets assume this works, now what? Lets not assume.

So ok, like we've said, the parts are completely interchangeable, so we can just change out the parts if this doesn't work,
but lets roll with it for now.

So we have some string, or potentially have some string, and what we do is...we go ok, we take this string, and we go...
umm...ok so there is a like neo-point where this string just is, like there's nothing to it, it just is, and that is all it
is. There is a point BEYOND that where we do things like edit this string, or use our CRUD on it, so ok we go...:

string
	add
	edit
	delete
	(read)

Now, everything coming from the server is string, so this should work all-throughout. So freaking ok, we have some string,
or we don't, what do we have before we have "string"? "1". So ok, we have "1", then we go ok, the thing about that is it's
string. So freaking ok, we have some string! We successfully have some string. So ok we would go pow, we convert our string
to the different types...well ok we could convert our string to anything, since its unilateral. So no need to worry about
that. So ok, we have some string, then what? Ok...what if the whole thing is one big-ol' string? All the code, everything,
in one fell swoop? Ok, so we would need an operating system, an http server, php, the php code itself (and the html, js,
etc.), and the string. So ok, now lets code on a freaking two-button video game controller. How do we freaking do this,
dude? If we can refine the means enough the ends will poke their head out. This is freaking SO bad. I mean Brent, Cinder,
you are a bad boy dude.

Ok if we use a one-button controller, we're done. Or if it's one thing, we're done. So it just fundamentally runs...
beautiful, lets do that. Ok so now lets run it in a circle...so ok basically, with what we're doing...well lets figure out
what we're doing before we figure out how to do THAT.

So ok, we're building a system that stores and retrieves data on and from the (a) server. So freaking ok, what we do is go
ok, we...so we're saying we'd use some string, so we build a database...then we store and retrieve data on that database...
and as far as the server-side of things are concerned thats it.

So now ok, how can we elaborate on what we have going on here...so ok we would start with the php, which would run off of
string. Now, we go ok, we have some string and some php...basically we have some string. The php is for telling the
computer to display the string or not. It's for displaying the string. It's intermediary. The important part is the string.
So we go ok, the PHP is therefore elastic, stretching and contracting, dependent upon the string. How do you make something
like this?

Ok whats the difference between two things? What if we have two of something that have the same value? What if we have two
of something that are equal in all ways except that they are two different things? Umm then we have a "count" of two, and
that is about it. The best way to approach this is with one thing, in and out. So ok, where do we draw lines? Or should we
even do so? Or do we even do so? Umm...freaking...so freaking...we go...ok if we have two "1"'s, we have two of the same
thing, the only difference is that there is two of them. Or ok the only difference that we would denote in PHP is that...
umm...ok there would be no reason to use one or the other. And freaking what if we need to use both of them, like at the
same time? We would only need one of them. Oh my freaking god it works. Like it goes screaming through there, but it works.
Ok so at the point at which we use one or two of them, we're unilateral, so either one works. At that point anything works,
just you have to use it unilaterally. Ok so its "working", so go on. And you were saying?

Wow thats funky. Freaking ok, now, go on. So how do you build this bad boy? Wow ok, so I mean we might as well start
anywhere. So freaking ok, we go ok we have some string, and...or what? So freaking ok, how do we do this dude? Freaking ok,
we go dude, only the deftest, only the most daring...naa, too common. Hmm...it tick-tocks like a clock, completely
mechanically logical, just what it is is what makes it so badass. So what that is is...pure life-force? Is it something
that can be described with words? Umm...so freaking ok, what if we, now this is way far out, but what if we programmed a
completely objective system...so it would take some string and go...it would make as much sense out of it as it would, so
like if we typed some english in there it would make some sense out of it, but would it fully make sense? How is what is
happening not what we want to happen? The two are one and the same. Hmm...interesting dude. How is what is happening not
ideal? Or thereabouts? What is what is happening? It's something unique, so there's no describing it or accounting for it.
Accounting for it/describing it is not the thing itself. So what I am seeking is faux order out of real, unique, order. Or
is it? There is a way to do anything. Therefore there is a way to "deal with" the unique.

Now, if we use a unary system, we have a system that is much more consistent than binary for dealing with numbers and
things. It even starts at 1! So basically, we just account for 1 or 2 (11), and we're good. So ok, thats what that is...
the thing about that is that it doesn't "skip" while it counts up, so its' form is much more consistent (if not just
completely consistent) than binary, or anything else for that matter. To get to 1, we simply reduce by 1 and voila, we're
there. 0 would be represented by an empty string...its self-explanatory.

So go on? You were saying?

Ok, so freaking...how would we do this bad boy? Ok so we have like a database class that does all the database querying and
stuff, then we have a string, that is the current string of the whole dang thing. And that is pretty much it, the rest of
it is just goo, javascript, html, sometimes directly output to the browser, sometimes relayed to JS...so we would have php,
then we would have our string...ok first we would have string, then we would have php, then the database class, then the
html and the javascript. So ok we would have: a php class, a database class, an html class, and a javascript class, beyond
pure string, all in php. So we have pure string, then we have php.

Ok. The thing about this is all of these classes are string. So we would have a string class. Again, we would have our
data and our interpretation, our string and our compiler. So what we do is commodify on this and write the whole system
this way, in pure string fed to an interpreter (or something like that). Ok so what we would do is put "1" at the core,
then string, then the interpreter. Why string? Why an interpreter? So we would have "1", then what? Then we would have
things I hereby dub "generalisms". These would describe what to do with the "1", or from that point on, in a logical
fashion to create a functioning system.

Ok so the way this thing would go is it would start with "1", then it would use a unary system (or that "1" would be unary)
to denote "2", "3", and so on ("11", "111", etc.). So freaking ok, umm...yea ok, "1" would be 1, "11" would be 2, and that
describes the breadth of it. So freaking ok, now we take all our information and filter it through there...so we have...

A "1" at the core
A "11" (2) just after that
A system of string
A system of interpreters to interpret that string

And this is, beautifully, all string.

So ok, the way we would do this is we would have a (huge) string of interpreters, data, and so on, that would all be
interpreted (at the top) by the interpreters (or, simply, PHP). Ok, so this makes sense...ok so the computer is hard-wired
(with its bios) to interpret this string in a certain way, resulting in something like an operating system, or whatever is
built out of that interpretation. The important thing to remember is that this is all just string. There's no bells or
whistles, just string. So ok, so we have a machine interpreting string, so way out, like at the point at which that is
physical reality all the way out, that is string as well. So the beauty in this is that at the point the string is in the
machine, we have a system made out of string. So ok, what we have to do then is figure out everything inside of the
machine. So ok, we go...now ok what if we break our unary down such that: "1" is odd and "11" is even? Therefore "1" would
break down to "1" in binary (for example), and "11" would break down to "0" in binary (an so on). From this point on we
have a nucleus within which to work to do what we are trying to do. So the beauty in this is that "1", which would be the
start of the unary, would be the first thing, and "11" would be the second. So what is happening here is completely inline
with EVERYTHING. What this means is way-faster translation times and therefore processing (inside and out). We can thus
simply translate to binary, or whatever (unilateral translation) and we're set.

You will want to make a point of seperating "1" from everything else, at the core. Although a unary system greatly reduces
processing time, it still allows for numbers bigger than one, resulting in utter failure. Therefore you will, at least,
want to delineate a difference between "1" and, say, "11".

So ok, lets say we give this bad-boy a run-through and see what we get. We feed it some string, and we go ok, now what do
we want to do with that string? Ideally we don't want to do anything with it, it's just there. Beyond that point we would
want to do stuff like edit and delete it (for our CMS, for example). Note the difference.

So, purely, we would have a "1" and that is it. If everything were ideal and stuff that would be the end of it. Anything
beyond that point is a "11" and is utter failure. The processing times, at that point, are directly maximal, and not
minimal, as they would otherwise be, and the system completely fails.

Ok, so how do we make sense out of this? So if we have a system of "1", like, we delineate things like success and failure,
wherein both are (fundamentally) equal to "1", so, I mean, basically, that is what that is. So freaking ok, what should we
do at this point? Should we go for it, regardless? What is the logical path from this point on? So ok the logical path
would be "1", so...I guess we just embrace a system of strict indifference. Lets just go with it, since its logical.

Ok so we have a system of "1", and freaking...ok so everything...would be syntactical. Since thats what THAT is. But it
does beautifully put it all on the screen. So freaking ok, now lets say we're coding and we come up with an error. This
error would be the same as a success ("1"). What are we trying to do by creating a difference? Well, being very much facile
about it, we're trying to come up with an "11" instead of a "1". Ok, so now, contrasted against what we're trying to
accomplish, very much from very little, what we have here is an error ("11") as opposed to a success ("1"). The thing is,
thats what that is when there is a difference. Now, there are two ways of looking at this: "1" and "11". So ok, what we
have (at least on the surface) is a syntactical system. The thing is, thats string baby. We can do string! Ok, so how this
goes is:

We have some string, and that string equates to either a "1" or an "11". Now, if that string is an "11", we generally want
to re-run it until it comes out as a "1". So, now, if we can denote what a "1" is, we just remove one "1" and we get a "1"
from the "11". Syntactic. String baby. So far so good. So now what we need to do is delineate what a "1" is. Pee and smoke
one dude.

Ok, so what we would do here is we would go: "1" would be a success (completely fundamental) whereas anything greater than
that ("11", "111", etc.) would be different types of failures. So ok, what if we could trace what kind of failure something
was with syntax? We take an "1111", and denote that there were 3 different failures, or something like that? Then we simply
correct the failures, one by one, until we get a success. Ok, how would we do this? Again, we need to figure out what a "1"
is to do this. So what is a "1"? Everything is a "1". To reduce things to more simplistic terms, we would fundamentally
have either a "1" or an "11". Hit or miss. The thing about this is we need to figure out what a "1" is to do this. What if
we use a super simple method to do this, like simply denoting that something is a "11"? Everything would be a "1", only
those deemed "11"'s would be such? That would be how the structure would be, should we code this thing up to this point to
see what we get? See what kind of syntax comes out at that point? It seems like the problem is something more fundamental
than that. Like it would be a facile thing. We would be doing something like literally typing an "11" in there or
something.

Hmm. So chewy.

Ok so here's a thought: everything is "1", but not everything (therefore) is "11". What if the problem is that you're
using a "1" to delineate success when it isn't? This would be consistent with binary, too. 0 would be failure, 1 would be
success. Hmm...then we would go ok, everything would be an "11", which would be a success, and failure would extend that
and would be a "1". So a "1" would extend an "11". This like doesn't make sense. The syntax declareth that an "11" would
extend a "1".

Failure - 1
Success - 11

So everything would be a failure, but not everything would be a success. Success would have to be dubbed. This makes a lot
of sense. Furthermore, there would be several types, and levels, of success: "11" would be an unsuccessful of a success as
something could be. So ok, then we would need to know what a failure is to figure out what an "11" (success) is.

Therefore, a failure would be anything completely fundamental: that which is not interpretable. This cannot be passed to an
interpreter successfully. Therefore, a success would be simply something that can be interpreted by an interpreter. Makes
sense.

Ok so a freaking failure would be what everything is, a success would not. It would take (at least) two failures to make
a success. Therefore, what is a failure?

A failure is at least a type error. More fundamentally, a failure is a false (instead of a true). So freaking ok, what we
would do is go ok, we have...huh, what WOULD we do?

Umm...ok it wouldn't matter which one was which, they are relatively stable. The fact of the matter is that 1 would be a
failure whereas 11 would be a success (much like 0 and 1, respectively). Or would they? 1 is odd, whereas 2 is even (like
0). It is more consistent to use 1 as success and 11 as failure, therefore. Ok, so we have:

Success - 1
Failure - 11

Huh...yea I mean that is consistent. It's unilateral, is what it is. Everything works, not everything doesn't work. Makes
some funky syntactic sense. Does this all add up? Should we try it out and see what we get? Ok what if we are looking at
this way too hard: fundamentally there would be a "1" and that is it. Now if you build the thing from that point on, it
should completely work out. So lets do this, in pseudo:

We have a master class with a value of "1"
	From here, lets say we want to delineate successes and failures:
		We would have two subclasses (or some-such):
			Success
			Failure

Now, from that point on, everything should work. Makes REALLY beautiful sense. Completely relative, free-flowing syntax,
lean, mean, syntax machine. Now lets say we build on this a little bit, just enough to make some relative sense out of
this:

We have a sort of string class, that handles like everything inside the thing
	The code itself is also handled by this thing
	It would need to be able to read and write from and to the filesystem

So freaking ok, now...what comes to mind is the multitude of errors that could occur while we're doing this. Already. We
could have any number of errors. Furthermore, what if we don't have PHP to interpret our string? We would have to "place a
certain amount of weight" on PHP, at least initially. Ideally we wouldn't do this. Ideally we would do this with our mind
so there is never, say, an absence of php. However, doing both at the same time...

Ok so if we can get one thing right about this we can start...I guess...so fundamentally if everything is fundamental...
umm...ok so how would we start? We would have to build some sort of core...

Freaking ok, like...freaking...ok if you build the core, then you build everything else, all you have to do is hammer it
all into place. So ok, there's no difference...there's strictly no difference...

Ok, so the first thought that comes to mind is that there would be no point to coding big ol' classes that do stuff like
read and write from the filesystem: if we ever needed to code the details of such stuff our classes would be useless. These
would have to be moved to a sort of sub-tier. This also maintains the purity of the code. Basically, unless we plan on
having massive classes that do every tiny little thing, this doesn't make sense. You would have this great big thing for
doing stuff (which doesn't necessarily make sense). If you could widdle these down to size at the point you are going to
export the code this would make sense, however. You would be telling the computer, effectively, to run the data through so
much length of some string before returning the data. Makes a LOT of sense. Doesn't make so much sense that we would have
this huge, bulky class in there at all times, though. So ok, effectively what we have here is a system of functions that
would do every possible combination of the "machine code" of the system. If we can tell the computer which ones to do (and
which ones not to do), this is definitely something we want to do. What this does is reduce a LOT of code to a LITTLE code.
In fact reduces all code to a single function-call. The interesting thing about this is: in order to, for instance, read or
write a file, we have to "fopen" that file. The only thing here is there is a syntactic twist that requires that we splice
some code in the function parameters (the second parameter). So it holds that we would have string and splice. So, here we
have:

string
splice
syntax
	"$fh = fopen('filename', ('r' or 'r+'));"

We would effectively have to splice the second parameter into the function call. This is consistent with have an array of
strings and, say, a single string to replace in the code ("%replace%"). We just run through the code, replacing strings,
one by one. Ok, so now what we would do is...ok so we would have "machine code", and we would call this code...ok so in our
example we would fopen a file, whether we are going to read or write. We would, along the lines of what we are talking
about, have something like the following:

"$fh = fopen('filename', '%replace%');"

Where we would replace "%replace%" with whether we wanted to read or write. We could then read or write (whichever we
wanted), all with a single syntax. The point here is not that we use less syntax, but that we use a single syntax.
Therefore, when we get there, it will come down to a single thing (and not two things!). So we replace, then we either
read or write, depending on what we want to do, then we...heres the pseudo:

function readOrWrite($filePath, $stringToWrite = "") {
	$fh = fopen($filePath, $stringToWrite !== "" ? "r+" : "r");
	if ($stringToWrite === "")
		$fileContents = fread($fh, filesize($filePath));
	else {
		if (fwrite($fh, $stringToWrite))
			$writ = true;
		else
			$writ = false;
	}
	fclose($fh);
	return isset($fileContents) ? $fileContents : $writ;
}

Now, the thing here is that what we have is one thing. There aren't two things to make sense out of. So in fact what is
happening here is we have some syntax, and it works. I mean thats basically it. So what is going on here is we have a
repeating pattern: we have to check to see whether we are reading or writing over and over again (every time we do
something with $fh). So freaking ok...huh...ok so basically we have to determine what a 1 is and what a 0 is and we're
good; we account for enough variance (any at all, on the efficient end) to get it done.

So freaking ok, what we do is...ok so what is happening here is:

We check whether we want to read or write
We open $fh, based on whether we want to read or write
We check whether we want to read or write
we read or write accordingly
we close $fh
we return the results

So what is happening here is we have to check whether we want to read or write multiple times. It's interlaced into the
code, at this point that's just how it is. What we do is reduce this to a single thing:

Check whether to read or write
open $fh
read or write
close $fh
return results

Ok so we can reduce it to a single thing by using "r+" as the second parameter of fopen. This makes it read or write. So we
have:

function readOrWrite($filePath, $stringToWrite = "") {
	$fh = fopen($filePath, "r+");
	if ($stringToWrite === "")
		$fileContents = fread($fh, filesize($filePath));
	else {
		if (fwrite($fh, $stringToWrite))
			$writ = true;
		else
			$writ = false;
	}
	fclose($fh);
	return isset($fileContents) ? $fileContents : $writ;
}

or in pseudo:

open $fh
read or write
close $fh
return results

No redundancies. Freaking ok, I'm kinda cooked. Call it a day or what? I'ma smoke one. Ok so freaking, we have to go back
to our first code with a tiny change ("r+" needs to be "w"):

function readOrWrite($filePath, $stringToWrite = "") {
	$mode = $stringToWrite !== "" ? "w" : "r";
	$fh = fopen($filePath, $mode);
	return $mode == "w" ? fwrite($fh, $stringToWrite) : fread($fh, filesize($filePath));
}

So the thing here is we have to check our mode at least twice, which is more than once, which is not good. What this means
is there is redundancy going on in the code (which means we have to code more, the computer has to work harder, and all
around everything is broken). So freaking what we do is go...we would have to generally open the file (without a mode), or
skip seperating opening the file from reading/writing it (and closing it), and go from there. Therefore we would simply
have:

function read($filePath) {
	if ($fh = fopen($filePath, "r")) {
		if ($contents = fread($fh, filesize($filePath))) {
			if (fclose($fh))
				return $contents;
			else
				return false;
		} else
			return false;
	} else
		return false;
}
function write($filePath, $stringToWrite) {
	if ($fh = fopen($filePath, "w")) {
		if (fwrite($fh, $stringToWrite)) {
			if (fclose($fh))
				return true;
			else
				return false;
		} else
			return false;
	} else
		return false;
}
function readOrWrite ($filePath, $stringToWrite = "") {
	return $stringToWrite !== "" ? write($filePath, $stringToWrite) : read($filePath);
}

So freaking we have to break all that stuff up into single bits. So I broke it up into three functions. Here it is in one:

function readOrWrite($filePath, $stringToWrite = "") {
	if ($stringToWrite !== "") {
		if ($fh = fopen($filePath, "w")) {
			if (fwrite($fh, $stringToWrite))
				return fclose($fh) ? true : false;
			else
				return false;
		} else
			return false;
	} else {
		if ($fh = fopen($filePath, "r")) {
			if (fread($fh, filesize($filePath)))
				return fclose($fh) ? true : false;
			else
				return false;
		} else
			return false;
	}
}

So freaking ok...we have two different fopens...I mean they are logical, I guess that's what that is. What if we had a
seperate thing that set the mode of the fopen:

class File {
	
	private $path;
	private $mode;
	private $fileHandle;
	
	public function path($path) {
		return $this->path = $path ? true : false;
	}
	public function mode($mode) {
		return $this->mode = $mode ? true : false;
	}
	public function open() {
		return $this->fileHandle = fopen($this->path, $this->mode) ? true : false;
	}
	public function read() {
		return fread($this->fileHandle, filesize($this->path));
	}
	public function write($contents) {
		return fwrite($this->fileHandle, $contents) ? true : false;
	}
	public function close() {
		return $this->fileHandle = fclose($this->fileHandle);
	}
	
}

Then, to write our code we wrote previously, we would go:

function readOrWrite($filePath, $stringToWrite) {
	$File = new File();
	if ($File->path($filePath)) {
		if ($File->open()) {
			if ($File->mode($stringToWrite !== "" ? "w", "r")) {
				if ($return = $File->mode === "r" ? $File->read() : $File->write($stringToWrite))
					return $File->close() ? $return : false;
				else
					return false;
			} else
				return false;
		} else
			return false;
	} else
		return false;
}

So freaking...ok it's way more compact, in certain ways. We had to write a wrapper for it. Is this the way to do it? We
have way less code in our readOrWrite function than we previously did. So ok we'll have to pick through and deal with all
the redundancies, so we go one to one, every one thing has one "access point"; "fopen" has one access point, its parameters
each have one access point, and so on. 

Ok, so I figure if we break it down to single things we'll need access points for every character in the string. So
freaking, ok so for "fopen" how would we do this?

$fh = fopen($filePath, $mode);

$fh is one thing
fopen is one thing
$filePath is one thing
$mode is one thing

Should we just hack away at it till we break it all down? Or I mean...shouldn't we break it down to individual characters
just to be thorough? Ok so what we do is break it down per function. So...whatever a function requires, we follow that
chain of logic to break everything up. So like fread requires a file handle that has read privileges, and a filesize of a
file path, so we make sure we have the file handle all broken up, and we make sure we have a file path on hand. One thing a
piece: a path, a mode, and a handle. Ok so we need to delineate what one thing is. So one thing would be delineated by
whether something has, or could have, whitespace around it. This should make sense. So freaking ok, we go...huh...I think
this is working...ok so we do this consistently...and...we end up with a system that relatively works. I mean it works,
just, it works within php. So ok, this is good! This is real good. So freaking ok, what do we do here? Freaking...umm...
huh...like ok, we go...so what we like trace the perimeter of PHP and classify everything? Then what? Umm...so ok we write
a few classes, we would need a class for Database stuff, ...can we abstract database handling like this? Umm...that would
be big.

Ok so freaking...umm...ok so even if you can't do that, you can write whatever you want, so freaking you could just write
whatever you need to to do whatever you need to do. So freaking go on, you were saying something about writing classes in
PHP for everything?

Ok, freaking, ok, we would like, freaking, umm...so we write our classes out all nice and everything, then what? I'ma
smoke one. So freaking ok, you write these classes...so everything is all laid out and everything, umm...lets try one more
to be sure of some stuff:

class DbConnector {
	
	private $host = "localhost";
	private $username = "cinder";
	private $password = "alphanumeric13";
	private $database = "test";
	private $query;
	private $mysqli;
	
	public function __construct() {
		$this->mysqli = new mysqli();
	}
	public function host($host) {
		return $this->host = $host ? true : false;
	}
	public function username($username) {
		return $this->username = $username ? true : false;
	}
	public function password($password) {
		return $this->password = $password ? true : false;
	}
	public function database($database) {
		return $this->database = $database ? true : false;
	}
	public connect() {
		return $this->mysqli->connect($this->host, $this->username, $this->password, $this->database) ? true : false;
	}
	public query($query) {
		return $this->query = $query ? true : false;
	}
	public send() {
		return $this->mysqli->query($this->query) ? true : false;
	}
	
}

Resulting in something like:

$DbC = new DbConnector();
if ($DbC->host("localhost")) {
	if ($DbC->username("Cinder")) {
		if ($DbC->password("alphanumeric13")) {
			if ($DbC->database("test")) {
				if ($DbC->query("YOUR QUERY HERE")) {
					return $DbC->connect() ? $DbC->send() : false;
				} else
					return false;
			} else
				return false;
		} else
			return false;
	} else
		return false;
} else
	return false;

And, shortly, not something like:

mysqli_query(mysqli_connection, "YOUR QUERY HERE");

Which would mean, like the file example, you would have to call the mysqli_query function twice every time you changed one
of the parameters you're passing to it.

I'm pretty sure this makes sense. Lets assume it does. Go on. You were saying, something about coding everything from this
point on?

Ok, so freaking...now we like comb through our code and look at the types we're using to do stuff. We return to our File
class, and check out the types. Or what? Ok, so I'ma smoke one real quick.

So freaking ok, umm...so yea like we can code these classes and stuff, then what? What's the next step? Then we...umm...
then we freaking...I have no idea what to do next. Freaking...we could...what COULD we do next? Umm...we freaking...so like
we build something here, not sure what, but something. So what we do is build our way down...how do we get down from here?
So far up high. High in sky. High in the night. How do we get down from here?

Well, what we do is jam it out. So freaking ok, we have some classes, some encoding...what if we build our encoding? 1's
and 11's? Umm...is there a point to doing this? Which one is true and which one is false? Wouldn't 1 be true? And always
true? It would be consistent. So freaking ok, we have a 1 and an 11. The 1 is true, the 11 is false. Why not just use 1's
and 0's? Is there a good point? What if we break everything down to single variables?

So the reality of this is even if you used 1's and 11's, you'd have to figure out which was which, and even after you did
that you'd have to put them to hardcore use to see any light out of them. Like, just because...you know the thing is there
is no point to doing this anyways, what we're looking for is "1". One thing, "1". So freaking ok, what does that do for us?
We still have to break everything down to build the thing up anyways. What if we take...you know I freaking have no idea
what to do here but to keep banging on it. Eventually it will go down. It's like a freaking mountain and I'm sitting here
banging on it with a sledge hammer, lol. I'm freaking getting nowhere:) Anyways, on with the program. So freaking ok, so
how do we do this? Do we break it down, build it up, what do we do? Umm...freaking...so we go, ok, we want to build this
grand and glorious thing...ok so what everything has in common is "1". The thing is we have to...relate two things...we
have to like mesh two things together to make a single thing, and that is what that is. So we go ok the one thing any two
things has in common is a "1". Now, what this means is that, strictly speaking, this is what we are looking for. Strictly
speaking, meaning we aren't looking at...ok so any two things...so ok, now, if we specify two things, we may have overlap
greater than just "1". So what this means is that any two things have anywhere from 1% to 99% in common, but not 100%. Ok,
so what we are looking for here is...ok what we have is two things that have as little as possible in common, because we
don't know which two things we have, so...ok so, the thing here is that we COULD have two things that have 100% in common,
simply because I say so. So what this means is that...ok it could be all over the map...we could have two things that have
100% in common, two things that have 0% in common, I mean freak yea dude. So, ok, like, you have to define some stuff. What
exactly do these two things have in common? Are there two things, or is there one thing? Umm wow ok, yea so...the reason
this works is...so lets say you have one thing, "1", and a second thing, "0", and basically you just have what you have, a
1 and a 0. One exists, the other doesn't. So that's why that works. So freaking ok, what we're doing here is...so freaking
ok, the thing is if you...ok basically if I use one thing I surpass all this stuff instantly. If there's one thing there's
no comparison or anything to do, so there is at least LESS to do than consider two things...or is there...ok if we
consistently compare two things and one thing, when we use two we have to do stuff, when we use one we don't. So that's
what that is, so ok one thing. Now what? Ok so if we use two things, or one thing, unilaterally, there's no difference. So
there's no difference...is that a two or a one? That is, conventionally, a one. But, a one is unilaterally a one, which
means there's no difference. Hah. So ok, then what? So there's no comparing things. Ok, so, umm...is there any way to break
this pattern? Oh freaking kay, if we had two things, and they were different, what we could do is...we could use, say a 0
and a 1, or a 1 and an 11, and work off of the fact that they have different values (they are unique). So like basically
we could have one thing, and there's no comparison going on, or we could have two things, and pretty much they would have
to have different values for it to work out. If we provide for them having different values or not, we account for the
"whitespace" and we're good. We're drawing a difference. Other than indifference, that's all there is. So the thing is at
this point we have everything accounted for, so we can move forward.

Ok, oh freaking kay, now what? Umm...so if we use a 0 and a 1, there is a difference (in values), and directly at that
point everything is gravy. So ok, now the thing is that the reason this is right is because it accounts for the widest
possible situation: there are two, which is greater than one. If, on the other hand, there is one, the thing is that is
much simpler than two, so you might want to do that (if you can). Can you do that? If we do something simple, like
arbitrarily use a system that only has one, we can (subjectively, objectively) do that. So freaking we can simply so
declare that we can do this...there is no difference, therefore these two systems are compatible, therefore we can do this.
Yea, that's what that is. So ok what we do is use a system of "1", and totally go from there. Even if we're not right we
can just change the parts out at any point in time. Oh freaking kay...

Now what? So ok what if we build something...like basically anything...and we go ok, we look for any areas where there are
two possibilities and basically break them up so everything has only one possibility, so all is one? Like what if we take
our File class:

class File {
	
	private $path;
	private $mode;
	private $fileHandle;
	
	public function path($path) {
		return $this->path = $path ? true : false;
	}
	public function mode($mode) {
		return $this->mode = $mode ? true : false;
	}
	public function open() {
		return $this->fileHandle = fopen($this->path, $this->mode) ? true : false;
	}
	public function read() {
		return fread($this->fileHandle, filesize($this->path));
	}
	public function write($contents) {
		return fwrite($this->fileHandle, $contents) ? true : false;
	}
	public function close() {
		return $this->fileHandle = fclose($this->fileHandle);
	}
	
}

And we go ok, now break it all the way down until it can not be broken down anymore. Ok so freaking, what I was thinking
earlier is we can use whatever we want, since at this point everything is compatible (and not compatible). Therefore it's
fair game to use something, based on it's compatibility, and therefore I choose "1".

So ok, now, how do we do this bad boy? Lets run our File class and see what we get.

So this is what the working code looks like:

class CFile {
	
	private $path;
	private $mode;
	private $fileHandle;
	
	public function path($path) {
		if ($this->path = $path)
			return true;
		else
			return false;
	}
	public function mode($mode) {
		if ($this->mode = $mode)
			return true;
		else
			return false;
	}
	public function open() {
		if ($this->fileHandle = fopen($this->path, $this->mode))
			return true;
		else
			return false;
	}
	public function read() {
		return fread($this->fileHandle, filesize($this->path));
	}
	public function write($contents) {
		if (fwrite($this->fileHandle, $contents))
			return true;
		else
			return false;
	}
	public function close() {
		return $this->fileHandle = fclose($this->fileHandle);
	}
	
}

So freaking ok, now, umm...ok...so freaking...play some wow or what? Umm...freaking...keep the keyboard lit up dude. Ok so
I was thinking: if we knew what to tell the computer in terms of a mode in our CFile class, we would be set. If we knew the
difference between two things we would be done. We could then completely automate the computer and thats that. That would
be freaking so rad. Thats rad dude. So freaking all we need to do is figure out the difference between two things and we're
good. This SHOULD work. I gotta make SURE it works, though.

So freaking ok, I figure what I have to do is study indifference until I get there. There's no difference, even strictly
speaking, so that's how it is and we'll just have to like study it or something until we get it. In the meantime, it's high
time to get some stuff done, so I'ma start getting back into the groove building websites and stuff.


Ok so building an extrapolator...ok...so we take a number and we...we basically take booleans and do the work
(binary is basically just a truncated form of boolean). So what can we do with boolean? We can "&&"/"||" them:

true && false
true || false

Ok...so those are something like the building blocks...can we build everything out of one or the other, perhaps?
Lets build this whole thing out of one thing. So we have 1, to be true, and then what? The best I can think to
do is like jump to boolean and use and/or logic. So we have the previous, and then what? Then we go ok, what are
all the combinations of the two that we can use to build stuff?

(true && false) || true
(true || false) && true

Ok...with breadth:

true
false

true && false
true || false

(true && false) && true
(true && false) || true
(true || false) && true
(true || false) || true

Ok so that is the breadth of it...now, how do we use these to compose an extrapolator? It's grilled cheese
time.

Ok so freaking...umm...when we extrapolate we...take a known value and "generate" another value, accurately,
based on the known value. So what do we do with a 1 to "extrapolate" another value? Umm...hmm...we take some
kind of formula and put the known value through it to come up with another value. So what exactly is that? We
know (with some sort of resolution) that 1 wins over 0. So 1 or 0, 1. Now, how exactly, EXACTLY, do we know
that? Ok lets compare 1 and 0 and see what we come up with for proving 1 over 0.

Ok so we have a simple program that compares 0 and 1 to see which one wins. Now, testing for which is GREATER
is what we did, so I mean, does this work? Whats the difference? Or like, ok, how is that logical? How is it
logical to test for which is GREATER, as opposed to testing for, say, which is LESS? Hmm...all that matters is
we know we're right, and furthermore, there's no difference, so I mean it might as well be string cheese. So
freaking ok, now, don't we need to prove this to continue? Not just side-step it on internal, "hidden" logic?
If we don't know, in concrete, what the answer to this is, we won't know whether that is true or not, unless
there's no difference. If there's no difference we can proceed anyways. So freaking ok, there's no difference,
...we do both! There's no difference, and while we're, I guess, sitting here figuring this out, we have that
going on in the background. So freaking ok, umm...lets figure this out.

Ok, so we start by having an input, which is true, and testing it for truth. If it's true, it works, if it's
false, it doesn't. So it works, and now we figure ok, now what if our input is something other than true? What
if it's string, an object, false, etc? Umm...ok so I figure the "preface" of the input would be string then: a
string version of whatever the input is. The unparsed string that the input is (once parsed). So ok then we
have something like:


Ok so the way we build Fractal is:

- if installed
	- run
		- go to main page
			- add, edit, delete, and view entries
				- need CRUD for images, video, sound, all files, and rich-text
					- need to seperate all of these so they can be uniquely defined
						- image(s)
						- video
						- sound
						- etc.
				- should try and use a generalized CRUD
					- make it extensible so it can be added-to/subtracted-from
						- filesystem system
					- everything should be generalized like this, so everything continues to be applicable in the
						future
- else
	- run installer

So ok what we do is go...fractal is made up of single things, and these are all replica's of a single thing, and
what that single thing is is, well, whatever that single thing is. So what we should do is offset this to Cinder,
since it's how the fundamental core of the thing works, and go from there.

So what we have is a system made up of single things. Each of these single things can be like anything. So ok we
have to define what these things are...

What these are are...oh yea thats how you do that. You put the two together and roll with it. So freaking ok, what
we have, like overall, is a system that has multiple "things", and we have to further define what these things are,
but like basically what we have is a system that comes to a single point: Cinder. So ok, what we do is...well ok so
this is correct because furthermore what that single point is is our 1. So ok, what we have is a system of things
that are generalized and housed in 1, or, furthermore, Cinder, and...and it all comes rolling out. So ok this
works, so just don't screw it up. So freaking ok, what we do is...

We figure out what one of these is and go from there. So what one of these is is like a string, so it can handle
everything we can throw at it on a computer. So freaking ok, we can open anything in a text-editor, and
text-editors...CAN you open anything in a text editor? Ok so thats string, for sure, and even if it isn't we can
always come back and edit whatever we have, so ok what we do is go ok, what one of these is is...

It's at least a...string with CRUD. It at least has CRUD, so that would have to generalized as well. Whether or not
it's a string is like up in the air as well. So freaking ok...makes a lot of sense. So basically it's string with
CRUD, so if we roll with it from there we should be good, and if we're not we can always edit it. So ok the reason
it's string is because...lets say we had some data:

Hello world

and we wanted to store it, the quickest and dirtiest way of doing that is to store the string itself, and in fact
that is pure in that it doesn't adulterate the data or anything, so we'll go with it under the condition that it is
consistent and will therefore be extensible and, most of all, compatible in the future.

So ok we have string, then we have crud, and whatever else we define, for that string.

So ok how do we do this?

So in Cinder we define this string, then we go ok, we load the CRUD definitions and...ok so there are multiples of
these strings, so that comes first, so ok lets start laying this out...ok so if I have an array to store all of
these the question comes to mind: what if these aren't strings? What if we specifically build it to handle anything
the array can store instead of just strings? This is compatible with 1. Lets do it.

Ok now what if we dynamically define these things...? Like freaking ok so...huh...I'm thinking this because I'm
starting to look at Cinder and relate it to 1 and I'm going ok whatever comes out of that 1 is like dynamically
defined, so like what we have is...some string "earth" that "guides the water"? So like Cinder would be some
"earth" "guiding some water", and "like" "One" could be "THE" "earth" that "guides the water". So freaking this
makes some sense...the thing is you're already like way fundamental...you should get much further along like this.
So ok, go on? You were saying, the "earth" "guiding the water"?

So ok you would define one thing, that could go in $Cinder->data (as an array element), so freaking ok, first thing
that comes to mind is you would have a type...mmk...now what if you defined what Cinder does, dynamically? So like,
in like pure syntax, you define the fact that it stores data in an array? And then in fact what THAT is is
something that the system would load...so like, ok, you would have something like an "index.php" file that loaded
everything, and that is basically what that is, only if you needed to go one step further than that...I mean that
is basically it, since we're talking about something housed in PHP. So ok, now this "index.php" file is therefore
the "earth that guides the water", so...ok so from there...we load Cinder and get crackin'. Or do we? So ok we
start from "index.php", in our sandbox, then we load everything from there. Then what do we do? Then we like define
one of these as Cinder and load that, so...so like yea that would be what we do, because if these are what the
whole thing is made out of, it's one single thing unilaterally. THAT makes sense. So ok, furthermore, if you can
get that done you have a circlet of what your extrapolator should look like. So freaking ok, hmm...

So what do we do from "index.php"? Ok lets start building Cinder and see what comes to mind. Ok so what if these
things are primarily made out of string, like a file, and thats what that is. That way we can manually load them,
or we can generate them however we want. Translates directly to the view...ok this makes sense, so what we would
have is...a thing that is string, so ok...now...if we have some string, this kind of doesn't make sense, because
in order to do this we need the thing that parses the string (Cinder!) to parse the string, so I mean it doesn't
make sense when we're trying to figure out how to build Cinder.

So ok, what we have here is like a conundrum: the thing itself is what runs the whole show, so we need something to
build THAT to run everything else. So freaking what we have is a starting point, made of string (some PHP), and
we run that and it runs everything else. So what this is is "index.php", and that runs everything else. So ok what
we do is...build that! So ok what we would have is like...ok so you were saying, we have Cinder (or something) that
runs all this code?

Ok so Cinder would make these things, and what it would do is...it would load, then it would load everything in
like an "extensions" directory or something like that, and the "index.php" in those would load everything from that
point on, so ok if we program one of these we should have the whole system all laid out, so lets say we build the
thing that deals with multiples on a website, so what we would have is a sub-system that would take single things
(images/etc.) and load an array with them, and then we would custom-program the "frontend" that would display these
to the client. So ok, what we do here is...so ok this thing would be made of single things, which would be dynamic,
so ok like we would load a "class" of these things and build them out of that, and that class would be loaded by...
the program, and that program would be loaded by Cinder, and Cinder would be build out of...single things that
would be, at least, "programs", that were each one thing. So what these would be is...clusters of these single
things...so we ALMOST have like some XML or something like that and an interpreter and that is it. Basically we're
good, we have like some XML and an interpreter. So ok lets code this bad boy?

We still need to define what one of these things is. So it would be 1...then it would be some string (code) that we
would load via "index.php". So ok, umm...like...freaking...what one of these is is...an "extension" of Cinder or
something like that, so what that is is...umm...freaking ok what we do here is...now we just code it...so ok in
pseudo we would have:

1
	Cinder
		Fractal
			Manages multiples for a website
		Some other extension
			Does something else

So quick n' dirty what we have is a system (Cinder) that loads extensions, and then those extensions have (are) a
datum that has extensions (CRUD), so at least what is going on is a system of a datum and some extensions (for that
datum). So like we would have:

1
	extensions
		read
	Cinder
		extensions
			Fractal
				some image category
					create
					read
					update
					delete

So ok, this is a little more complex than I thought, so maybe lets build the thing and see what we get...

Ok so in pseudo, we have 1, then we have Cinder, then we have like our thing that deals with multiples on a
website. So freaking ok, 1 would be rather implicit (we can't run it in PHP or anything), so then we would load
Cinder via "index.php", then we would go ok, so...freaking...ok...so one of something that is an extension of
Cinder would be:

An extension of Cinder
	some kind of "thing", a string, or some other type
		some dynamically loaded stuff for dealing with this thing (CRUD, etc.)

One of something that would be on the level of Cinder would be:

Cinder
	some dynamically loaded stuff for dealing with this type of thing (CRUD, etc.)
		basically, this would be a "shell" for everything from this point on. So we would load extensions/etc. from
			here that would be like, "Fractal" (our thing for dealing with multiples on websites), etc.

So what these have in common is they have dynamically loaded CRUD, etc., and that is about it. So ok if we load
Cinder we go: we have some php...ok we want Cinder basically because we want a central, single place for doing
everything. So if it's a little shanty at first it's no big deal. It would be better, though, if it were completely
loaded and everything, or at least as good as possible. So freaking ok, Cinder would load Fractal, Fractal would
load data from the database, and thats it!

So ok, what if we had a thing that loaded Cinder and so on? Umm...it would go...well I mean really it would just
load the index.php file and thats it, so that's what we'll do. This way, too, we keep our sandbox index clear, just
about for purity's sake. So freaking ok, lets build it.

Ok what if we just FORCE...just code the thing...

Ok so if we code Cinder to be the center of everything, what we have is...like ok what we have is an array, inside
of Cinder, that holds all our data, then we have CRUD/etc. dynamically defined for each element of that array, so
like what those array elements would be is each one would be an object, and inside that object there would be a
value, then there would be an array of CRUD/etc. loaded for the object, or specifically for the value of the
object, so like ok what we would have is...like ok we would have an array of CRUD/etc...ok so the thing is Cinder
doesn't do the same thing that Fractal does, so there wouldn't be an array of objects "with CRUD/etc.", there would
be an array of extensions and thats it. All it would do is load extensions...so ok...now we want this there simply
as a center of everything...so what if we define what one of the things in Fractal is in Cinder? So like it would
be a type with some CRUD/etc. defined for it, so I mean...if we define that at Cinder everything is all kinds of
centralized and stuff...if we don't we freaking have to define this stuff over and over again, so I mean...so like
ok what if we define one of these as a single character in some string, then we go ok, we make extensions of Cinder
out of that string, and those define "clumps of string", and that is what? Umm freaking...hmm...so umm...if Cinder
had a single value all of a sudden we would have a recursive structure...a fully recursive structure. Ok so what if
we just give it a value or something? Or I mean it would HAVE a value, and that value would be undefined, so that
is a way of looking at that. So freaking ok, umm...so we define one of these things as:

An object with a
	value
	an array of extensions for doing stuff with this value

Then we recursively apply this stuff and bam, Cinder. Yea I mean thats what dude. So what if we define one of these
things as a type...so some kind of data we can store, or something like that.

Umm...like more generalistically speaking we have classes...but more specifically we have classes with...well ok so
like Cinders' "value" would be an array with a bunch of extensions in it...so I mean its a little funky but it
fits! Yea that sounds funky enough to work...so we'd have:

Cinder
	value
		array
			Fractal
			etc.
	extensions
		array
			create
				extension for creating something: creates an "element"
			read
				extension for "reading" something: reads an "element"
			update
				extension for updating something: updates an "element"
			delete
				extension for deleting something: deletes an "element"
			etc.
				extensions for doing anything we want to do to an element

So ok now basically what we have, or technically speaking what we have, is an array...yea this fits...ok so
freaking lets build one of these things...ok so one of these would be anything on the right-hand side of an
assignment in php. So ok what one of these would be is a value. Huh...seems simple enough...so ok it would be a
value...thats for sure...I mean for sure for sure? We can always fix it if we're wrong, so lets roll with it. It's
pretty darn much a value though.

So ok, we have a system of values. Thats damn fundamental lol. I mean ok dude, freaking...ok, so freaking we have
a system of values...then for each of these values we have some stuff defined (CRUD/etc.). So freaking ok, we would
have:

Element
	value
		any value in PHP
	extensions
		extensions for dealing with the value of this element. So freaking ok, like, lets say the value of this
		element were some kind of string, we would have crud/etc. for dealing with this string...so ok now the
		thing about this is we would have...umm...we would like have everything hard-wired, so freaking ok...ok the
		beauty in this is you've managed to hard-wire everything. From this point on all we have to do is deal
		directly with the value of something, not the peripheral. Thats good dude...if that even applies...does
		stuff have peripheral? Or is it just a value and thats it? Huh...good question...a value is one thing, so I
		mean...ok so now what we do is hard-wire all this stuff...so lets say we needed to edit our value, we would
		just assign it a new value, or lets say we needed to create it, we would do this with the __construct of
		the Element class, lets say we wanted to delete it, we would do this with the __destruct function of the
		Element class, and lets say we wanted to read it, we would have a simple function that returned the value
		of the Element class. So I mean this makes a lot of sense...how is it in practice, though? Should we code
		one of these bad boys and go from there?

Ok so freaking the thing is all we do is come up with one of these, then we come up with the stuff to deal with
this thing, and we're done. So I mean the beauty in this is once we figure out what one of these is, and it's a
value, we just code the stuff to deal with it and we're done. So freaking ok...keep coding...so freaking ok, now
what we would have is freaking...like...some freaking...we would have a value, and then...we would like extend this
value...ok so we would have a value, then we would like...freaking...umm...we would be able to do stuff with this
value, like edit it and stuff...then we would read this value with some frontend/backend, and we would have the
edit/etc. functions for each value. So freaking ok, what all would we need to do with a value? Freaking ok, two
hot ass girls were just making out so freaking hard on tv lol. Ok so anyways, what we would do is...we have these
values, then we have...ok so we would have a value, then we would have CRUD for that value...so freaking this value
can be anything, an image, a video, anything, then...ok so thats BASICALLY what we would have. Now what we would
have is a value, and that value could be anything, images, video, anything. So then we would want to be able to
edit/etc. these values, so we need like an image-cropper/etc., and what we do is go ok, so we have a value, then we
have an extension of that value, which deals with stuff like cropping images/etc./whatever we define, so that's
what that is...now does this work? Lets code it and see what we get.

Ok so basically what we have is something that is so simple its like super freaking versatile. I ended up with a
value and thats it! Then you have, say, Cinder, then you have, say, Fractal, and thats it! Freaking so far so
good...now I'm just wondering how to extend Value, or whatever, so that everything is completely fluid and
everything. So like what I want is you have Value, then you have...ok just code the thing from the top down and
account for all of the generalities.

So freaking ok, like what we would have here is...ok so we would have a value, go on...then we would have CRUD/etc. in general
for that value, so now the thing to figure out is do you have dynamic CRUD/etc.? I mean basically it will just poke through, so
you might as well just code it, but I mean if you want to sit here and figure it out you might as well, you'll end up in the
same place as if you code it. So freaking ok, like, so what we would do is go ok we have a value, then we want to CRUD that
value. We want to read it onto some front-/backend, create it, edit it, and delete it. So what we would have is some general
CRUD for the value, and that is about it...so ok this might be WAY more simple than you thought. So you have a value with some
crud, then what? Would you ever...could that value always be represented by something like a string? Does it matter? In syntax
it doesn't matter, so we jump to the point of using string, overall, then we go ok...what if we mock this up a little bit...:

Cinder
	value
		home
			simple page and thats it
		portfolio
			array of portfolio pieces
				client
					project
						name
						description
						screenshot(s)
						etc.

Now, we would go ok, we have Cinder, which extends Value, which has a value of an array, then the first array entry is "home",
and the second is "portfolio". Then, under each of those, so on and so forth, but the important point here is that "home" is
the first element, and "portfolio" is the second. So can we work with these parameters? Umm...yea we totally can. What we do is
come up with something like classes for each element of Cinder->value...so ok, this naturally flows. Now, what we want is...ok
so what we have is...a value...which is one thing, so we're good. I mean everything is one thing, but I mean ok so anyways...:)
Ok so what we would do is program each element of Cinder->value, so...the thing here is we program an "Element", and then press
out a bunch of elements (as many as we want). So ok what we do is...what if each Element has a value, like Cinder, and that is
what THAT is? So like "home" would have a value of some rich-text, and "portfolio" would have a value of an array...works!
Works well in terms of syntax too, therefore. Ok yea man this is jivin'. So freaking ok, what we do is...we program one of
these, lets say "home" (its the simpler of the two), and see what we get.

Ok so "home" would consist of some CRUD for some rich-text. So...lets just code this bad boy:

<?php

require_once("Value.php");

class Page {
	
	public function __construct($value) {
		$this->value = $value;
	}
	public function read() {
		return $this->value;
	}
	public function edit($newValue) {
		$this->value = $newValue;
	}
	
}

?>

So that is just about all that would be; we would have to code databasing and stuff but I mean thats basically it. The skeleton
of it, that is. So freaking ok, now how would this connect to the rest of the code? Cinder would load this...where would Cinder
get it's data from? Umm...or would it even be Cinder? Or would it be Fractal? Whatever it is, where would it get it's data
from? Umm...the database. Ok, so freaking...so Cinder would do something like load Fractal (amongst all of its extensions), and
Fractal would load this data from the database, so basically you just need to figure out how this thing would load this data
from the database. You need to reach Database Point, and then ur done. So freaking ok, umm...so whatever it is, Cinder or
Fractal or otherwise, it would connect to the database and retrieve this data. Now the data structure would look like:

Cinder
	Fractal
		Pages
			Home
				Instance of something called "Page"
				Value
					CRUD
			Portfolio
				Instance of something called "Portfolio"
				Value
					CRUD

So ok each has CRUD, so these would be one thing, so ok...now is there a point to putting this all in Cinder? Or should it
(maybe) be Fractal? Umm...Cinder would be better because its the core of the thing. But I mean just in case, lets figure this
out. So freaking ok, Cinder would have a value (it extends Value), and that value would possibly be the layout of the site,
so...the thing is we want Cinder to be the central hub of all existence though, so its value would (at least) be equal to all
of the clients of Cinder. So ok what we would have is:

Cinder
	value
		Home
		Portfolio
			clients
				Eric Carr JKD
				Couchboys
		Contact

So freaking ok this makes a lot of sense, Cinder would (also) be the Cinder website itself, would be the master system
installed on my sandbox, and would freaking...ok now what if...what if now you implemented your splicing so you could splice
the code, much like hooks work? So freaking you could take your Page class code and splice code in and out of it? This would be
freaking nuts. I mean it sounds kinda dumb but it would allow developers complete control over the thing. I think it's a good
idea, at this point. So lets say we nominate it for Cinder at this point. So freaking ok, now what we do is...ok so at that
point we just code the thing. Anything we need to add/remove/ANYTHING, we just splice in and out of existence. So freaking ok,
what we do is...so ok I mean at this point...I keep saying the same things over and over again:)...but anyways at this point we
would have something like an element, which would be an element of an array, and that is pretty much it except it would have
something like custom CRUD, so lets say an array element were an image, it would have CRUD that would...ok don't worry about
this on the backend, just put everything in its' slot. So freaking ok, we have array elements that are mixed, so we store those
on the server...:

Images and Video can be stored on the filesystem
Text and other smaller things can be stored in the database

So freaking ok, what we would do is...PROBABLY what we would do is...umm...lost my train of thought smoking a cigarette;) Ok!
So freaking anyways, what we would do is...Cinder->value is an array. Then we just iterate through this array and do stuff
accordingly. So what one of these array elements would be made of is a template...just code it. Ok write it out dude: one of
these "elements" would be a template of Fractal, or Cinder, or something, and what it would be is a series of objects...well,
what it would be is...we would have the element, which would have a value, and we would act upon that value with CRUD (and the
like), so like what we would have is...umm...is there a reason we would have altered CRUD for these things? Umm...ok so what we
would do (ideally) is filter data on the client-side, so when it got to the server it either just went in to the server or out
to the client. So freaking ok, what we do here is...we have an array element, we have some CRUD, so what we do is go ok, we
take our CRUD...do we have the same CRUD for every element, or no? If we do, we simply...ok so an array elements' value would
be either a string, a number, a boolean, a file (image/etc.), etc., so what we would have is a system that detected what kind
of data we had and dealt with it accordingly. So lets give is a pseudo-run-through: we would load the website, some HTML (or JS)
would prompt the user to input some data (or request data from the server), then...if we requested data from the server (Read),
what we do is go ok on the server we call up the element or elements of the array, so we would have to have a system on the
server that...stored data...so freaking ok, what we would have is:

frontend
	request (Read) data off the server
		read, at this point, any part of the array from the server
			request one array element
			request a whole node of the array
			request the whole array
	send (Create, Update, Delete) data to the server
		send data for a new element (as well as data identifying where to put that element)
		provide information identifying an array element (to Update or Delete that element)
			also provide the new array element value

So the thing about reading is we would only need to identify a single array element to read successfully: we identify either a
single element or a bunch of elements by identifying a single element. So ok lets mock this up in pseudo:

frontend
	request data from the server (index.php)
		read main page from server
			authentication
				read whole array into view
					read each element of a given dimension into view with:
						a way to add children to the current element (array)
							a simple 
						a way to edit and delete children from the current element (array)

Ok the thing at this point is that Cinder would not be just a CMS: it would not have a value of an array that we would display
on a website, so...umm...ok so freaking every time we...when we take "1" and turn it into an array, we introduce complexity
into the system. Suddenly we have to account for multiple elements (of that array), and what that means is we have to be able
to add, edit, and delete elements from that array. So what this means is...I mean ok, so if we have a "1", we have a point that
is simply sitting there, hanging in the balance. So freaking ok, if we have one thing, and TRULY one thing ("1"), there is
minimal complexity to that thing. If we extend that by one, we introduce potentially exponential complexity to that thing. So
if I have a "1", and I introduce CRUD to it, suddenly I have introduced a magnitude of complexity of "2" or more to the "1". So
freaking, ok, therefore if the thing is semantically "1", it will work. Now ok, like, what this means is we have to trace every
bit of syntax we add to this thing to make sure it stays "1". So ok, now, this shouldn't be impossibly hard to do.

Now, otherwise, more fundamental to the point, we would have "1" with CRUD. So ok, now, syntactically what is the reality of
this?

1
	create
	read
	update
	delete

Basically, we have five things, not one, so ok what comes to mind is we can chock create, update and delete, because we already have
the "1", and we don't edit or delete it (it's constant):

1
	read

So now we have two things, so...ok why would we read it? If our output was "1" we would have a "1", in and out, so:

1

And now we have purity. Now, why would we change anything at this point?...well, I mean ok...so even if we had two of the same
thing:

class One {
	
	public $value;
	
	public function __construct($value) {
		$this->value = $value;
	}
	
}

$array = [
	new One(1),
	new One(1)
];

They have the same value and everything, just we have two of them. So freaking ok, what is it when we have two of something? It
means we have two numbers, so something like "11". So what this is is...:

$array = [
	new Number(1),
	new Number(1)
];

And what that is is...it doesn't matter that we have two Numbers, or two Ones, what matters is that we have two array elements.
So if I trace the syntax above I should come up with what I am trying to come up with. So if I test the above code, the working
code is:

<?php

class One {
	
	public $value;
	
	public function __construct($value) {
		$this->value = $value;
	}
	
}

$array = [
	new One(1),
	new One(1)
];

?>

So freaking ok, umm...so the answer is somewhere in this syntax. So ok, like we said before, all that matters is that we have
two array elements, so the following would work:

<?php

$array = [
	1,
	1
];

?>

So what we do is...ok we test our code, and this is what we get as working code:

<?php

$array = [
	1,
	1
];

?>

So ok, now we go ok, what is important here is that we have two array elements, so what we have (in terms of syntax) is:

1,1

So we have a 1, followed by a seperator (a comma), followed by another 1. So ok, the importance here is the comma? The thing
that "creates" two elements is the comma. So without the comma we would have a single element: 11. So ok, the comma is what we
are looking for. So basically, what we do is put a comma in between any two elements and voila, we have an array of multiple
things. Ok, hmm...is it really that simple? 

Ok, so if I make a (massive) system based on this logic, I have a single thing, then I have more than one thing, and more than
one of those things are seperated by a comma, and then I have a humongous structure that follows. So freaking ok, umm...

So lets say we build Cinder, and we go ok, we have a single thing, then we have two things, and we seperate these two things by
a comma in an array, so...ok so now lets say we program this thing in pseudo...or what if we program something simple. We would
have, say, two things, then we would iterate through these things with a loop, do a callback or something like that on each
thing, output our data, input with that output, and round and round it goes. So freaking ok I think this works...should we
start building or what? Umm...coffee time. Umm ok so, uhh...should I code or what? So lets pseudo this thing out:

We have potentially multiple things
	we could have a single thing
		we store these as a "value" of a variable, so we can switch between an array of values or a single value easily
we handle each of these things individually

So like what we have is an array full of values, then we have a battery of functions and stuff to act upon the array elements
and...ok so what we would do is store the value(s) in an array, to kill two birds with one stone, then we go ok, we...
freaking...then we act upon that array with a loop and a callback for each array element, so...ok so now lets say we wanted to
edit an element of that array off the top:

we have an array full of elements
	we select a certain element out of that array
		we select by a unique identification number, or even like a series of unique identification numbers
			basically we select by array indexes
	we gather the information for the edit from the client
	we select that array element
	we edit its value

So freaking what we have is:

an array full of elements
a way of "selecting" a certain element out of that array
a way of gathering information from the client
a way of editing the value of the element

So freaking ok, if we break this all up into syntax (characters):

We have a "main" thing, that would be some string, that would directly be code (or anything else for that matter)
	This could be anything. The idea is to be quick and dirty about it; something that we can whip it in an instant.
This string would naturally be broken up into individual characters
We then have an interpreter of this string
	This interpreter could be anything. It could interpret comma-seperated values, code, anything.
		This would be, for example, some PHP that would interpret the string
	This interpreter interprets the string, so the string could be PHP code and the interpreter could be PHP itself
We then code PHP/MariaDB/etc. via the string and the interpreter, resulting in a functioning computer program
	We would basically just write the code then interpret it with the interpreter
		The beauty in this is we would have a string (possibly some code), then we would have an interpreter...

Ok so now what if we went one step further and put the string inside of PHP...we wouldn't want to do this because the string is
intended to be the "quick n' dirty" end of things: it could be something other than a string, it could be anything, its merely
a means of transmitting data. It could be a rock for all it matters.

So ok, we have some string, then we have an interpreter, so lets say we write some code, then we pass that code to php, then we
go ok, we parse the code into a functioning php program, then we could even read that string back in through PHP and work on
it, I mean if we wanted, then we would go...so ok, all told, what we have (in pseudo) is:

Cinder (itself)
Some string (or something) - Data
an interpreter - Interpretation
	php, js, etc. (some kind of interpreter, some kind of interpretation, of the first thing)
code - all the php, js, html, etc. for a Cinder "project"
	by "project" I mean any web design done by Cinder, as a web design company
		ultimately whatever this is called would be seperated from "project", which would mean any old project.
			So like what we would do here is have some string, and wherever we "escaped" "project" we would have any old
				project. Works!

Dude...what if this is all coming together! I mean ok...so freaking what we would have is...we would have some string, and that
string could have, for instance, escaped commas in it, then it could have straight commas in it, and those would seperate it
into two (or more) things, so thus we account for multiple things, then we account for formatting with the same logic: we could
have escaped data, or we could have non-escaped stuff that would denote things, so basically like some XML, just what we would
have is...we would have some string that would somehow define the rules of the interpretation (what special characters were,
etc.), then we would otherwise escape those characters, and we come up with a full-bodied, functional system. So freaking ok,
how would we do this? What special characters would we have...we would be able to define any special characters we wanted...we
could use the following syntax for doing this, generally speaking:

we would escape a character with a forward slash, like usual
that character would be indicated within parentheses, so a comma would be (,)
all told, an escaped comma would be \(,)

This way, we could use multiple characters as the "special character". So ok, it basically works, we can refine it as we go, so
ok, now, lets define some data:

Hello world, (question)How's it going?(question)

So ok yea, this works out in syntax. Now what?

Ok, so freaking code some stuff with it, see how you like it.

Ok dude! This is going to be freaking nuts. So ok, what we have is...what kind of repeating pattern do we have here? How can we
reduce this to some really simple code...hmm...so fundamentally what we would have is...a character of string. So what we would
do, then, is make a "string" out of individual characters, then we would go ok, each character has a specific character code,
so in that way they are unique, then we would compose data...ok so ideally the data would be completely seperated from the
interpreter, which is like what we want, or what we have defined (the data can be ANYTHING), so ok we have our data, then we
make an interpreter for that data, so...is there some kind of happy medium for this kind of thing? Umm...so ok umm...like we
would have some string or something, then if that were ANYTHING, our interpreter would have to be beefed up so it could make
sense out of the data accurately, and without special characters or anything like that. So what this would mean is...basically
if we have one thing, we're good, because we don't need to blow it apart by seperator characters or anything like that, and
therefore any old thing will fit in there. This is consistent with the fact that we need one for the thing to work. So freaking
ok, so we have on big ol' string or something like that...makes sense, then we have an interpreter of that string, so yea
that's how you do that: you have on big string, then you have, say, sections of that string that need to be interpreted as code
or whatever, so then you have "files" of code and stuff like that...so ok I mean therefore this "thing" would not be like one
file with a heaping ton of text in it, it would be simpler than that. It would be "1". It is therefore so simple it can handle
every- and anything. So freaking ok, lets say we have...freaking...ok charge your computer bro.

Ok so freaking umm...dang dude...so freaking how would you build this bad boy?

Ok so we start out with some string
	Again, this could be anything, not just string
We then have an interpreter of whatever that is
	So like, our primary interpreter would be ourselves, "observing" this thing
	At some point we would define the fact that we would use, say, PHP to interpret (secondary interpreter)
		We would have like a browser that we would point to a php script and bam, it runs
			We would have a sandbox that would be the center of everything happening on our sub-system

So ok, what if we could define a couple things, just TWO things:

<?php

$myArray = [1,1];

?>

Even if we have two of the same thing...ok so for all intensive purposes 1 and 1 are exactly the same thing, exactly the same
string. They are exactly equal to one another. So freaking ok, umm...lets say these were instances of a class:

<?php

class MyClass {}

$myArray = [
	new MyClass(),
	new MyClass()
];

?>

Freaking ok, at a point, they are exactly the same thing. The only difference is they are two different things, so freaking ok,
umm...they are syntactically the same thing...so freaking ok, umm...what we would do is...freaking...like the problem stems
from the fact that you are trying to do two different things. If you do one thing, you just build one website at a time, end to
end, no replication, all one thing. So freaking ok, umm...so ok, lets say we have an array, and we want CRUD on each element of
that array:

<?php

$myArray = [1,1];

function create($value) {
	array_push($myArray, $value);
}
function read($index) {
	return $myArray[$index];
}
function update($index, $newValue) {
	$myArray[$index] = $newValue;
}
function delete($index) {
	array_splice($myArray, $index, 1);
}

?>

Now is there anything else we would need other than CRUD for one of the array elements? Umm this is rather ingenious. Umm...ok
so lets say for example we get an image from the client, then we store the image in the array, then we store it somewhere on
the server, after cropping it/etc., so lets say after cropping it once, so what we do is...we go...we output to the client, so
we display a web page to the client, which has buttons and stuff on it. Specifically it has a button on it for adding an image.
This button would also send information indicating where the image would go, so what parent it was a child of, etc. So ok, our
image would look like:

The image itself
Identification of the parent
Identification for the order this image goes in

Ok, so this defines the image and where it goes, so we stick it in there...ok so what happens when we send this data to the
server is:

The data is received
The image is cropped
The image and its data is stored on the server

So ok, umm...:

The data is received
	Cinder, or Fractal, or whatever, receives the raw data from the client
		the uploaded image is cropped and saved to a temporary location
		the image data is saved to a database
			the image data has a unique ID number
			the image data has a unique parent ID number
			the image data has a unique order ID number
			the image data has a path for each cut of the image (thumbnail, medium, full, etc.)
Cinder sends the client to the appropriate webpage

Ok, so freaking...what we need is a database, a filesystem, php, and thats it as far as the backend is concerned. So on the
frontend we would have:

We would start with the index.php file
This would display the frontend of the site, unless otherwise specified
	this way we can bottleneck traffic through the site: we just redirect other folders to this file with a header
		is this the way to do this? What if we create folders and then don't hit the index.php file?
			the folders will be vulnerable
		we'll have to do it with an htaccess file or something
			just don't expose any vital information
			yea its gonna have to be an htaccess file...couldn't get it to work, but we'll work on it :)
				you don't have to do it with an htaccess file anyways, you can just make sure no info is displayed
					if it HAS to be an htaccess file, do it!
So ok, the index.php file would display the site...or an html file, keep this slippery...
so for the backend, we'd have a Cinder folder with an index.php file in it or something like that
	the index.php file:
		authenticates the user
			kicks them out if not authenticated
			displays the backend if authenticated
				the backend consists of:
					a tabbed navigation bar:
						"Users"
							a display showing all of the registered users of the site
						"Pages"
							a display showing all the pages of the site, as well as an (optional) add page button
								each page is an object with several properties:
									a property can be a simple string that is displayed on the screen
									a property can be an array of children
								each page has an edit and delete button
									the edit button sends the client to a page where they can edit the page object
										once submitted, this data is sent to the server and processed
										cancellation sends the client back to the page they came from
									the delete button busts a confirmation of deletion
										upon confirmation the page is deleted
										upon cancellation the client is returned to the page they came from

So basically what we have is:

Cinder
	authentication
		success
			taken to the backend
				"Users"
					"add user" button
					display all users
						display edit and delete buttons for each user
							edit edits user
							delete
								confirms deletion
									upon confirmation, user is deleted
									upon cancellation, client is returned to "Users" page
				"Pages"
					"add page" button
					display all pages
						display edit and delete buttons for each page
							edit
								displays children-without-children of page in editable, rich-text forms
							delete
								confirms deletion
									upon confirmation, page is deleted:
										database information is deleted
										all files on server are deleted
									upon cancellation, client is returned to page they came from
		failure
			returned to the login screen with a failure message

So, basically, you would have:

Cinder
	Users
	Pages

Cinder would be the hull of the thing, which would authenticate users, etc.
Users would be the panel where users could be edited
Pages would be the panel where pages could be edited

So freaking ok...umm...I think I'm done for the day...

Ok, back at it. Freaking ok dude, so if we have a repeating structure, what we have is an array...ok so lets say we have two
arrays, a users array and a pages array. So ok what we have is two of the same thing, so we make a thing that programs an
array...so freaking ok, umm...like ok we could just have an (associative) array that has "Users" and "Pages" in it, along with
anything else, and...so what it does is...it takes one of these, so any value, and runs with it. It would have some hard-wiring
for interpreting the array, so like something that said that...would we need to do this? Ok so to put it out on the table:

<?php

$array = [
	"Users" => [
		new User("Cinder")
	],
	"Pages" => [
		new Page("About"),
		new Page("Portfolio"),
		new Page("Contact")
	]
];

?>

So freaking ok, umm...so ok at the point at which we create these objects we don't need it to shoot anything off. These would
be completely seperate from the view, at least I think so, so we would have something like an MVC framework, or rather ok we
would have a User class and a Page class, and these would be independent of like everything else: highly fundamental. Not
completely fundamental, because they are not "1", but highly fundamental. What they would do is store the data for that
user/page, and then what we would do is...ok they MIGHT do this, then what we would do is...ok so on the view, at the actual
foot of the website we would have an object or something that displayed...ok so basically what we do is go ok, I mean since we
have to code all the "slats" in here anyways, we might as well just start with a repeating structure and work our way out from
there, so ok we have an array, a main array, for handling multiples, and what we do is...ok so this array stores all of the
data on the website. Then, we go ok, now we need to display this information on the view of the website, so actually in the
browser, so we go ok we have a slat where we have some classes or something for displaying that data on the actual browser
itself. So then what we do is go...ok so we have the data, then we have an interpretation...so ok to keep it pure we don't
necessarily have data/interpretation, but what it DOES have is some data, at least hypothetically, our user and page data, and
then the data is just sitting there. So then what we do is go ok, we...so what we need is a generic way to handle that data. A
way we can handle that data where that data can be anything and we can handle it. So ok, if one of these is a value, ok so what
we do is...we have a completely...:

Value
	array
		CRUD
			create new array elements
			edit existing array elements
			delete existing array elements
		display
			actually convey this data to the browser
				a generalized structure that:
					displays a (tabular) view of the data in the browser.
						So like what we would want is...
							we could have abbreviated columns (if there are too many of them to display well)
							something that looks like:
								+-----------------------------------+
								| Users								|
								+---------------+-------------------+
								| Username		| Password			|
								+---------------+-------------------+
								| Cinder		| ****				|
								+---------------+-------------------+
									only it could have any data, so like users, pages, any array data.
										so what we have is an array "viewer"...or a table "viewer"
											Ok so if this is array data...we have some funk in here where:
												if this is tabular data, there is a point where an array element is an array
													ok this fits with our model, what else is wrong?
					So what this would be is an array "displayed" in the browser
						On the backend...ok never mind the details, so what we have is an array we are working with
							why do we want an array?
								because it can handle one or more elements (works both ways)

Ok so what we have is:

an array
	so what we would do is run this array with php, so with index.php...or some php file
		would we want index.php?
			smoke one

Ok so what this would be is a system made of values. What we would do is trace the type of a single value and display
accordingly. So the types are:

"boolean"
"integer"
"double" (for historical reasons "double" is returned in case of a float, and not simply "float")
"string"
"array"
"object"
"resource"
"resource (closed)" as of PHP 7.2.0
"NULL"
"unknown type"

So for boolean, integer, double, string, resource, resource (closed) and NULL we would just display the value. For array and
object we would display the values. So freaking ok, this SHOULD work. What this is, however, is just a "wrapper" for the value,
and what that is is a tier of stuff that would be extensible. Does this make sense? Umm...ok so we would have a value, and this
value would be...so freaking ok, umm...yea this makes sense, so freaking ok, we have a value, which is...

So freaking ok, should I build this bad boy? What exactly is this thing? It's like a...its a system wherein we have values, so
ok, now what is a value? Umm ok if we do this right it doesn't matter (i.e. we could get it right or wrong and we'd be ok). So
freaking ok, umm, freaking, ok, so freaking ok umm...yea ok umm...yea man. Freaking like ok this thing would be a value...so
the beauty of this is its a completely repeating pattern, so it's like a fractal or something, just what you wanted. Now what
you do is go ok, so you have a value in php, so you just be consistent at that point, so like ok you either would or wouldn't
need to be completely consistent at that point, but ideally you wouldn't, which works because our system is wide-open, so
freaking ok, we go pow, we have a...we have a value in php, then we go ok, if this value is an array we loop through the array
and display it's contents on the screen, then we go ok, so we have a value...so freaking ok what we would have is a "value", or
relatively such, so the thing is relatively stable. Now what we do is go ok, we freaking...so we have indifference, then we
have a single value, and that value can be an object or an array, in which case it could contain multiple values, and this we
account for one or more values ("things"), and we just ride it from there. So freaking ok, what we do is...first there's no
difference, then we have a value, so first we program a value:

<?php

$container = "Hello world";

?>

So freaking ok, now what we have is...a value, a string, and that is one thing. Just like an array is one thing. So what we do
is switch types and go from there...so freaking lets code this thing:

<?php

$value = "Hello world";

echo "<pre>";
switch (gettype($value)) {
	
	case "boolean":
	case "integer":
	case "double":
	case "string":
	case "NULL":
		echo $value;
		break;
	
	case "array":
	case "object":
		print_r($value);
		break;
	
	case "resource":
	case "resource (closed)":
	case "unknown type":
		echo "Resource, closed resource, or unknown type.";
		break;
	
}
echo "</pre>";

?>

And just to be sure that's working code. So freaking ok, what we do is go...ok so I think we have something that truly works...
the only thing is that freaking ok, what we would do is...ok at the point at which we have empty php we have a white screen,
which is compatible with indifference. So freaking ok, what we do is go ok, we have a value, then we process that value
(as text), and freaking...so if we do this with text we have a quite quick n' dirty system for doing stuff, so freaking...like
from that point we could code data directly into php files for all it matters, so freaking ok, umm...

So we have a single value, this we know for sure, then we go ok, we work on that value depending on what that value is, or
basically have a simple thing to edit that value, so what we need is...freaking ok, umm, like, we would need a system of
freaking umm...like...try and smoke one dude...

Ok so freaking umm...we would have a value, and that is one thing, so yea I mean it appears to work and everything, so now
what? So freaking ok, umm...we would like put some data in there...so freaking umm...like...what do we do with it? Everything?
Freaking umm...

Ok so what we would have is anything...the sky is the limit...so what do we have then? Phone numbers? Addresses? Umm...like we
can have anything, freaking anything. Freaking beautiful dude. So beautiful I have no idea what to do with it.

So freaking what we would do is...freaking...umm...code some stuff...now what? Now do we build the freaking thing? I mean ok,
it has a repeating structure, so we should be able to code the whole thing like freaking from the ground up, like ok, we SHOULD
have a freaking system that: takes the value and comes up with a massive system for dealing with that value. So like ok,
depending on what that value is, we do certain stuff with it. So like we have a...so like ok on the way in we have some string,
the code itself, that defines what the value itself is. So freaking ok, umm...so ok what you would have is...some string...
fundamentally what this would be is some string that would be parsed that would equate to our value, so umm...or it would be a
value itself, so umm...it would be a "value", so freaking...umm...

So freaking ok, what we would have is a value, then we would have...like basically we would have an array made of objects.
These objects would do whatever they wanted, and that is what that is. So like ok, umm...

So like ok what we would have is:

we would have a value, and that value could be an array full of objects, and those objects would have properties (proper, as
	well as methods like __construct and such)
if that value were an object, its constructor would be called when the object was constructed, therefore this is what we do
	when we want some sort of functionality to fire off
if that value were something other than an object, pretty much nothing would happen. So basically what we have is an object.
	HOWEVER, this is not exactly what this is.

So what we do is...start off with something like an instance of a class to get the ball rolling, and thats about it. The
__construct function would fire off and start the whole process and the rest would naturally follow. So ok, what we would do is
have a master class (Cinder), and we would shoot that off and it would fire off the rest of everything. It's either this or, I
dunno, have an array that...has objects that have been __constructed and therefore have fired...so I mean, ok if we have such
an array...what if we have a boolean? There would be no functioning code to do anything, we would simply "have a boolean". So
what we need is an object, because it is the only way we can have functionality to actually do stuff with our data. So what we
do is...we have a master class, then we have...then we have any functionality that follows from that point. So, what THAT is is
Cinder, then the functionality of...building multiple websites/etc., so what THAT is is we have Cinder, then we have...sub-
classes like "Website", etc. that Cinder creates instances of (inside of Cinder)...then we can have any structure that we have
inside of a class, so...the thing is we have multiples covered with an array...are you sure thats not how you do things? Then
you could store your whole thing...so what this means is you store your whole thing in a class called Cinder. Now why would you
ever not want to do this? Umm...freaking...ok so what we're trying to figure out here is what is the repeating structure of
this. If we have a master array, how do we do stuff with this array? Do we simply edit its elements and that is what? Lets try
something...ok so if...freaking...so do we have multiples or do we have one thing? So we would have Cinder, then Cinder would
do stuff...so...back to square one?

Ok so what is the repeating pattern going on here...we have an array and we do stuff with that array: we add elements to it,
edit its elements, and delete elements from it. So like we have an array, then we have a wrapper, or like we have a sort of
array class, and we do stuff with that array. Now, what we do is...so ok we need a single place where all the action happens:
an object. So freaking what we do is...just patch it together: so you have an object, and that object does stuff, what does it
do?

Ok what is our data?

Cinder
	projects
		clients

Ok so the first thing that comes to mind is our data will need to be maleable: when we extend it in the future we need to be
able to move elements into new arrays and stuff. So ok, we have an array, even an associative array, why not an object? If we
have an array...this doesn't make sense, at least in terms of php: if you have an array you have some like inert data. You need
data that moves and shakes, you need a way to do stuff with that data. You "need" to because you say so.

So we have, at least, an object, and the sky is the limit from there. So freaking ok, what we do is go...ok lets say we just
want to operate on some data: we have a value, then we have stuff doing stuff with that value. So we have a string or
something, then we have functions and stuff doing stuff with that value. So lets say we have some string, then we have
functions for splicing that string and such. Is the extent of what we can do with string representable by CRUD, or some other
finite thing, or do we need things to be extensible at this point? It would be better if it were both. So freaking ok, what we
have is...a freaking...system...wherein we have like Cinder, then we have an array, and we act upon that array with Cinder. So
ok, ideally what I want is a system that is basically just an array (nice and quick n' dirty), just I also want to be able to
do stuff with that array...is this too much to ask? It's not, we just have to figure it out. So ok, we have an array, then we
do stuff with that array...so we have an array, where did we get an array from? Freaking something had to put the array in
there, lol. Well, it didn't, just, you'll have a hard time coming up with an array without sticking one in there. So ok, we
have something that sticks an array in there (Cinder), and what it does is it has an interface wherein you can play with this
array, and you stick an array in there (or any value). Then, depending on what that value is, we do certain things: if its an
array, we traverse that array (potentially doing things with the elements as we go), if its something else, we do something
else. So specifically with an array, what we do is...traverse the array...so we basically just have an array, so...what do you
want to stick in the array? A bunch of stuff. Favorite albums, email addresses and phone numbers, notes, tons of stuff. So ok,
just make an array with all this stuff...so ok if we specify a range for, say, viewing elements, and we specify the range of
elements we want to view, if we specify a range that includes all of the elements, that is a thing. It is a thing to max out on
something. So freaking ok, we specify a range...then what? Umm...so ok damn near all we would have is an array...it COULD be
anything though, so it could be an object, so go on...umm...so ok the technical details are definitely seperate from the data
itself. So freaking we have a value...ok so we have a value. Any computer programmer could update this value for you, this is
completely seperate from a "backend" view of this value. So ok, not mixing the two together, what remains? Ok so that is that,
what we have is a value and that is it! Then what we have is peripheral. Furthermore, when it comes down to it that value is
"1", so I mean...

Ok, so how do we proceed from this point? Freaking ok, umm, what we do is...ok so we have a thing...we have a single thing, now
what we do is stretch that thing thin until it covers the entirety of the thing. So what we have is...we have a value, then we
go ok, now what is the potential of this value? So potentially this value has a __construct function, potentially its an array,
there are a bunch of possibilities. That's pretty much it though, it potentially has a __construct function, is potentially an
array, and otherwise potentially is something that doesn't really have anything to it (e.g. a string, a number, etc.). So
freaking ok, what we do is...we go ok, ...what do we do anyways?

So the system that is the peripheral of this thing would need to be extensible, that is for sure. So we can just build and go
from there, just it would be better if we did it in one fell swoop. So ok, lets say we had an html view for this thing that
was...

Ok so freaking the thing is what this is is a battle between php and js, and php wins. If we need the data in php, we have to
somehow communicate that to JS. I mean it's all just technical details. Therefore, what do we want to do with this thing? So we
need to get some stuff DONE, so I mean we should probably...well I, not we, should probably get my portfolio done, so I mean I
guess I better get started doing that. But, the beauty in this is I get to do some graphic work and some other stuff that has
NOTHING to do with code, so I mean thats good. Some visual stuff would be rad right now.

Ok, I'm back at it and...I think I should delve deep into this and get it done. I mean ok, what exactly IS the peripheral of
this thing? It's constant, so the peripheral is constant, so what IS it? Freaking ok, umm, hoopty doopty. Freak yea dude
there's no difference so this totally works dude, we can totally go to heaven (and beyond)! Freak yea! I mean ok there's no
difference, so there's no difference between whether something is up or down, so freaking ok, whats the difference? Even if it
doesn't work, what's the difference? There's no difference between up and down. So it doesn't even matter if the polarities of
the things are right and stuff like that, it goes through there. So freaking ok, what you do is...go...ok, here's what you do:
go ok there's no difference, so there's no difference between whether things are up or down ("up or down" doesn't really apply
anymore), so freaking ok, if there's no difference, if we can't calculate something being greater than something else any more
than we can calculate whether two things are true or not, or rather we CAN, or even if you couldn't, what is the difference? If
you have no means of calculating what the difference is, there is especially no difference, lets say strictly speaking there is
no difference at that point, so THEN what is the point? Like ok, if you tried to code this, you WOULD be able to do is, just
the thing is the outcome would be no different than nothing at all, so like ok, what is the point of coding it? So if we don't
code it, what do we do? Do we even ask our question, can we go to heaven from here with a qi? What if we don't? Will we still
go? There's no difference between up or down, there's no point to rationalizing anything at this point, knowing as a matter of
fact which of the two something is does nothing. Nothing different. So even if you freaking bombed it and you were completely
wrong and everything, there's no difference, still. Still. Still up is down and down is up and up is up and down is down. So
freaking ok, now what if up is down? Then everything is down. What if down is up? Then everything is up. What if up is up? Then
up is up. What if down is down? Then down is down. So if these are all scrambled, there's no difference. You might as well just
claw for something and hang on tight (once you find something to hang on to...what if you don't?). So freaking ok, umm...so ok
there's no difference, so up is down and down is up, so like effectively nothing makes sense at this point. Do you go to
heaven or do you go to hell? Do you cling to something and hope for the best, do you sit in peace and wait to inevitably go to
heaven? Is there a difference? If there's no difference, there's no point to hope, to actual reality itself, to anything. All
there is is basically chaos. So freaking how do you make sense out of chaos? The thing is, this is not chaotic, it's a
completely organized thing. So freaking ok, what that means is...what this is is we have to not change the thing in order for
this to work. That we have. Whatever it is, that is, at least, what it is. So like what we do is bite the rag and go ok,
there's no difference, so we're already doing it, so just bite the damn thing and hold on tight. Other than that, what we do is
break the difference between up and down and go for it. So why does up win over down? It's greater than down, and something
being greater than something else...what we DO know is it IS greater. So what we do is go ok, so up, then there's no
difference, so ok then the thing is that even if we're wrong (about up), there's no difference, so what we do is cling to our
indifference and that is that! There's no difference between up and down, so all we have then is indifference, so we cling to
our indifference and that is it! Indifference worked in the past.

So freaking ok, what we do dude is race time itself and try to get to heaven before the inevitable happens and we face the
freaking music and freaking go ok dude, if we have one thing...so freaking ok dude...umm...if there's no difference...so what
we have is basically indifference: there's no difference, so in fact it IS indifference, and stop there. You're dead on, as you
must be anyways. So freaking ok, umm...

So freaking ok, what we do is have a freaking system...a sub-system...the thing is, we have a system of indifference and
freaking ok, so there's no difference, then we go ok, we want to code PHP. Why do we want to do this? So freaking ok, freaking
what we do is...we...freaking...ok so there's no difference, now in terms of PHP what does that mean? That means we have an
empty PHP file, and that is it. So freaking ok, now if we add a single element, a single variable or constant, what do we do
from that point on? So ok if we have a variable, we have a single thing...so ok what if you simplify your approach...what if
you make it SUPER simple and go ok, instead of a visual console or something like that you just use straight PHP to manipulate
it, so you go...:

<?php

class Value {
	
	public $value;
	
	public function setValue($value) {
		$this->value = $value;
	}
	public function getValue() {
		return $this->value;
	}
	
}

?>

So freaking ok, you have a single value with I/O, so freaking this is way fundamental, so ok from here you go ok, now lets say
you want to build Cinder or something...what you do is go...so you make Cinder extend Value, then you go...or should you just
clump it all in Cinder? Keep them seperate until further notice. So ok, what we do is go ok, we have Cinder:

<?php

class Cinder extends Value {
	
	
	
}

?>

So freaking ok, now we have Cinder with a value and I/O, then we go ok, now we want to...freaking umm...then we want to do some
stuff...so it's important, I think, to note at this point that what we want is...freaking...ok what we want is...umm...like...
we don't really want to adulterate the thing too much...the more fundamental the better, so like what I'm trying to accomplish
at this point is something that is both as fundamental as possible and yet extensible, in case we want to change it in the
future, so...ok so keep it down to one thing, unilaterally, so one central hub (Cinder), one function/variable at a time...so I
mean we're like skiddering on just plain coding the thing, so ok...now there's no difference between coding and anything, for
that matter, so freaking ok...so Cinder would have something like an array of information, and this information would have...ok
so like what you would have is an array of values, and that's just plain it...so freaking ok, umm...so what if we define a
couple things...ok there's utterly no difference at this point, so I freaking mean ok...umm...freaking ok dude...like...I don't
really know what to do at this point, so what if we come up with a methodology or something to work with. Or like, a protocol.
So what we do is...hammer away at it until we get it, there's no difference: maybe just go ok use a two-way circuit and go ok,
there's no difference, so do ANYTHING, think, write, whatever, then code, and thats what we'll do is either anything or code.
If we ever want to change this in the future there's no difference and we can.

Ok, so freaking umm...so ultimately what we can have is either a single value or multiple values, so what we (at least) need to
do is nail down what one of these is. It should probably, therefore, be a class or something, although this kind of doesn't
make sense because...just hammer that shit out dude, tinker along until you get it. So freaking ok, what we do is...we go ok,
we have...a value...and this value potentially has several values, so ok, we have something like a Value class, like our Value
class with I/O, then we have...ok so what we would have would be more fundamental than that, so like...we wouldn't necessarily
have a class, because it would be easier (shorter) to just directly handle the value, so a value is one thing, then we have
an extensible library of functions for doing stuff with that value, so...umm...what we do is go...so we have a value, now, the
thing is that everything from this point on can be coded, so in plain english what do we want to do with this value? We like
freaking want to edit this value, we want the value to be maleable, so it's not a constant...this isn't that reliable. What if
it were constant? What would that be? What if the peripheral for handling that value were constant, because we struck the mark,
and then what we do is...ok so that value is one thing, so go on, then what? Then we go ok, then we have a battery of functions
and whatnot to deal with that value, so like, the thing at this point is we can directly manipulate this value with built-in
PHP functions, so ok, we have our value, we can do whatever we want to with it, without there even being a difference, so then
what? So the shelf is moved up to the point of indifference. So ok, there's no difference, and we're in PHP. Then what? So then
we have to code a system or something. I mean there's no difference, we COULD just code individual projects and stuff like
that, but I mean we ALSO COULD build a system for doing stuff.

Ok, so here's where we're at: there's no difference, and we're inside PHP. So ok, now, umm...so freaking if you attach your
eyes to the view, if there's no difference at any point in time in your program there should be no output to the screen, we
should have a white screen, so from this point on proceed carefully in those terms. Or don't, there's no difference. ;)
So freaking ok, umm...what we do is go ok, we freaking...umm...like...ok so there's no difference all throughout, so freaking
ok, what we do is go ok, we freaking...umm...like ok, what we do is something like we just code dude. There's nothing there,
there's utterly no difference, there's nothing to do but code individual little tidbits...what if we don't code? Freaking umm,
like ok, so we just sit here and do nothing, there's no difference.

So ok how do we build this thing? Umm...so there's no difference, so we have an array or something, then we have some functions
and stuff to deal with that value, then we go ok, so we integrate our system...

So we would have indifference, then we would have the view of the computer, then, we would have this file, then we would have
our sandbox, then we would have our filesystem, then our password, then our computer, then the big blue sky over our heads. So
what we do is...so freaking ok, if I (re)code the breakdown of PHP, I have that, then what I do is go ok, now within that
system, so lets like juxtapoz this against a system of "0" and "1", so then we go ok, we just have to hammer out the details in
terms of these two things, or taken one step further, one thing ("1").

So ok, strictly speaking there's no difference, so we might as well just sit here and let it come to us or something like that,
but I mean I might as well work. So freaking ok, what you do is go...so freaking ok, umm...there's no difference, so what if we
program indifference? What if we bump it up a notch and describe what that is in PHP? Ok, so what that is is a blank PHP file,
like strictly speaking. So what that would be if you coded it is...the thing is, if you code it you dilute it by introducing
elements that must be used instead of the main scope of the PHP file (PHP itself). So I mean it really doesn't make sense, just
what if we program something BETTER than PHP inside of PHP? Something that works so well that pow, something pops out of thin
air? Umm...freaking...ok so what is the macro-system? What is the main, big bad-boy?

Ok, what this is is...at least an object (Cinder)...what this does is make sense of any data, so we could take in a single
value and get away with it...so ok, lets say we have Cinder and a value, now, how do we do it? How do we do this dude? Freaking
ok so there's a value, then there's whatever you would want to do with this value. What all would you want to do with this
value? Read and edit. You wouldn't want less than one of these because...if you had less than one of these you would have
something ELSE, at least, and that isn't what we want going on here, so I declareth that we have a single value, subject to
change. So ok, we take this value, and we go ok, now if we statically run through it, lets say its an array, every element is
defined in ascending order, so any __constructs should therefore make sense, we just build the array and we're done. Ok, then,
we loop through this array and...what if we have an object instead of an array? We would want the value in a central location,
so what we do is...ok this value could be an object, so that is a possibility. Now lets say we start building with this object,
we go ok, we call it Cinder, and then we build a website. Now, what we want is to be able to update Cinder to handle, say,
websites, and not just a single website, after the fact. So we make a single website with Cinder, all is well, then we build
ANOTHER website with Cinder, and suddenly we need to account for multiple websites. We come up with a class to represent a
website...now stop right here: what if we generalize the construction of these classes? What if we make it dynamic (or, rather,
both)...what is similar between any two of these? So we would have a value, then we would have Cinder...we would somehow
dynamically build these things. So like what we would have is an array:

Cinder
	website
		about
		portfolio
		contact
	clients
		ECJKD
			website
				home
				what is jkd?
				...
		Couchboys
			website
				etc.

So already we can see that: websites don't necessarily reside under Cinder, so what we do is go ok, we have Cinder...ok so my
preliminary thoughts about this are that we would have Cinder, ECJKD, and Couchboys, and each would have a website, so what our
array then looks like is:


Cinder
	website
		about
		portfolio
		contact
ECJKD
	website
		home
		what is jkd?
		...
Couchboys
	website
		etc.

Where we have "entities", so ok what we would have then is: we would have Cinder, then we would have clients, and that would be
the difference between those two, so what we need is a system that deeply embraces a philosophy of One. So ok, now what we also
want is the ability to put these things in any order, so what we have is a fundamental class that each of these things extends
(Value, or something like Value), then we dynamically define classes or something like that from that point on, so that what we
have is Cinder, ECJKD, Couchboys, website, and "webpage" (about, portfolio, etc.), all completely capable of being nested and
so on however we want. So what we have, fundamentally, is an array of these things, which is a single thing, so this is good,
so then we go ok, what this is is that each of these has to be the same thing for them to be intermixable and so on like this.
So like XML would be a good candidate for this because it has tagnames:

<Cinder>
	<website>
		<about></about>
		<portfolio></portfolio>
		<contact></contact>
	</website>
</Cinder>
<ECJKD>
	<website>
		<home></home>
		<what-is-jkd></what-is-jkd>
		<...></...>
	</website>
</ECJKD>
<Couchboys>
	<website>etc.</website>
</Couchboys>

With it, we can inter-mix these things, all throughout, and so on, and it is directly syntax, at this point, so I mean it works
well. This MAY not be what we want, however. So freaking ok, umm...so what this is is each of these things are the same thing,
so what that is is, at least, all of them are instances of the same class, so something like "Value", then ok, what do we want
to do with these things? So freaking ok, we have some XML, which is string, which works well with our system (all string, at a
point), so freaking ok, umm...how do we make these things interchangeable...we could just make it an array, if we make them all
instances of the same class they are quite interchangeable, just is that what we want? Umm...can what we want be achieved with
simpler means? Can we just use an array to do that? I don't see why not. So ok, we have an array...so now what would we have,
a straight array or an associative array? If we had an associative array we could store each element under a name, but is this
what we want? Do we need something more logical than that? If we store it in a straight array we have to indicate what each
element is, so like we would have to hard-wire what "$array[0]" is in our hard-wiring at some point. That's definitely not what
we want, but we DO want our array to be iterable, which either is. What comes to mind at this point is that you might have a
conflict of array keys, or rather you WILL have one, when the time comes, so you want to use a straight array. Ok, so we have
an array, and we interpret this array, so ok its a little clumsy sounding, just we can iterate through this array to no end,
which is what we want.

Ok, so from here what do we do? Ok, so each of these array elements is a value, now what we also want is for this thing to be
extensible in that: each of the array elements can be interpreted as an instance of a class, or subject to any other code, so
what that means is that there is a single point at which we have to code the whole array. This makes sense in PHP, and is
facilitated in any (other) programming language. So it works.

Now ok, in cascading logic, we have a value of some sort, then we interpret that value, so that value would have to BE an
interpreter. So ok, what we do is each one of those values is the result of a function, or an instance of a class or something
like that. So ok, now, we have:

PHP
some code processing our array before we construct it
an array

So ok, now what we do is nitpick, so what kind of code would we want to process our array before we construct it? So ok at this
point in time it would be good to define the input of this array. Now, to be precise, this value doesn't have to be an array,
it's a value. So it's input would allow for any value in PHP, or, furthermore, any value, period. So it could be a star, it
could be some string, it could be anything. So ok we have whitespace, so we have the input of the value, now what is one step
further in the fundamental direction? We have a "1", then we have some input. This input would not affect the 1, so effectively
this works and we can move on...I think? Ok at this point what if we jump into our 1/0 system and go ok, we have the 1, now we
just assume the 0, and like start building? Like we piece it together until we get it all the way down and go from there?

So ok, in our system, a 1 would be PHP itself (even without any code), so freaking ok, umm...what would we do here? Ok so from
that point, a 0 would (at least) be an explicit assignment of 0 as a value. So ok, in filesystem functions, a failure could be
denoted as a 0. So we, to be consistent, have to denote failure as, at least, a 0. Ok, so beyond that point, if anything
returns a 0 it's a failure...are you sure this is what you want? This makes beautiful sense: we thus have a two-pronged system
that purely handles successes and failures. This will work, in the long run. What else can we glean about 0? Do we need to know
anything about it from that point on? So ok in PHP what we would have so far is (something like):

<?php

class One {
	
	private $value = 1;
	
	public function getValue() {
	
		return $this->value;
		
	}
	
}

class Zero extends One {
	
	private $isZero = false;
	
	public function toggle() {
	
		$this->isZero = $this->isZero ? false : true;
		
	}
	public function getIsZero() {
		
		return $this->isZero;
		
	}
	
}

?>

Works. So ok, then what we do is...just start building, and then crunch down on the thing when it puffs up a little bit, until
the thing is solid rock. So what we do is go ok, just start building dude...this is BAD. This is what I want. This is like
99.9% what I want. Ideally the thing would just be a qi, and that is IT! But I mean this is way close, pretty much because it
has a "1" at its center. So freaking ok dude, now what do we want to do with it? Now we want a repeating structure built on
this that: has a single line of inheritance (>= extends "Zero"), and...ok so lets define something, ANYTHING, about this thing.

So lets take our File class that we wrote earlier:

<?php

class CFile {
	
	private $path;
	private $mode;
	private $fileHandle;
	
	public function path($path) {
		if ($this->path = $path)
			return true;
		else
			return false;
	}
	public function mode($mode) {
		if ($this->mode = $mode)
			return true;
		else
			return false;
	}
	public function open() {
		if ($this->fileHandle = fopen($this->path, $this->mode))
			return true;
		else
			return false;
	}
	public function read() {
		return fread($this->fileHandle, filesize($this->path));
	}
	public function write($contents) {
		if (fwrite($this->fileHandle, $contents))
			return true;
		else
			return false;
	}
	public function close() {
		return $this->fileHandle = fclose($this->fileHandle);
	}
	
}

?>

And extend Zero with it:

<?php

class One {
	
	private $value = 1;
	
	public function getValue() {
	
		return $this->value;
		
	}
	
}

class Zero extends One {
	
	private $isZero = false;
	
	public function toggle() {
	
		$this->isZero = $this->isZero ? false : true;
		
	}
	public function getIsZero() {
		
		return $this->isZero;
		
	}
	
}

class CFile extends Zero {
	
	private $path;
	private $mode;
	private $fileHandle;
	private $contents;
	
	public function path($path) {
	
		if (!$this->path = $path)
			$this->toggle();
		
	}
	public function mode($mode) {
		
		if (!$this->mode = $mode)
			$this->toggle();
		
	}
	public function open() {
	
		if (!$this->fileHandle = fopen($this->path, $this->mode))
			$this->toggle();
		
	}
	public function read() {
		
		if (!$this->contents = $this->fileHandle, filesize($this->path))
			$this->toggle();
		
	}
	public function write() {
		
		if (!fwrite($this->fileHandle, $contents))
			$this->toggle();
		
	}
	public function close() {
		
		if (!$this->fileHandle = fclose($this->fileHandle))
			$this->toggle();
		
	}
	
}

?>

Untested. So freaking ok, this works. Why not take it one step further, though, and just go:

<?php

class One {
	
	private $value = 1;
	
	public function getValue() {
	
		return $this->value;
		
	}
	
}

class CFile extends One {
	
	private $path;
	private $mode;
	private $fileHandle;
	private $contents;
	
	public function path($path) {
	
		if ($this->path = $path)
			return true;
		else
			return false;
		
	}
	public function mode($mode) {
		
		if ($this->mode = $mode)
			return true;
		else
			return false;
		
	}
	public function open() {
	
		if ($this->fileHandle = fopen($this->path, $this->mode))
			return true;
		else
			return false;
		
	}
	public function read() {
		
		if ($this->contents = $this->fileHandle, filesize($this->path))
			return true;
		else
			return false;
		
	}
	public function write() {
		
		if (fwrite($this->fileHandle, $contents))
			return true;
		else
			return false;
		
	}
	public function close() {
		
		if ($this->fileHandle = fclose($this->fileHandle))
			return true;
		else
			return false;
		
	}
	
}

?>

So ok, go one step further, and reduce your return values to a single character, "1" or "0"...then, only return something if it
works...ok thats a little too far for me to understand, so lets rewrite the code thus far:

<?php

class One {
	
	private $value = 1;
	
	public function getValue() {
	
		return $this->value;
		
	}
	
}

class CFile extends One {
	
	private $path;
	private $mode;
	private $fileHandle;
	private $contents;
	
	public function path($path) {
	
		if ($this->path = $path)
			return 1;
		else
			return 0;
		
	}
	public function mode($mode) {
		
		if ($this->mode = $mode)
			return 1;
		else
			return 0;
		
	}
	public function open() {
	
		if ($this->fileHandle = fopen($this->path, $this->mode))
			return 1;
		else
			return 0;
		
	}
	public function read() {
		
		if ($this->contents = $this->fileHandle, filesize($this->path))
			return 1;
		else
			return 0;
		
	}
	public function write() {
		
		if (fwrite($this->fileHandle, $contents))
			return 1;
		else
			return 0;
		
	}
	public function close() {
		
		if ($this->fileHandle = fclose($this->fileHandle))
			return 1;
		else
			return 0;
		
	}
	
}

?>

Oh freaking kay, so umm...so now what we want is the whole thing to fire a "1" or a "0". So recode it to do that...:

<?php

class One {
	
	private $value = 1;
	
	public function getValue() {
	
		return $this->value;
		
	}
	
}

class Zero extends One {
	
	private $isZero = false;
	
	public function toggle() {
	
		$this->isZero = $this->isZero ? false : true;
		
	}
	public function getIsZero() {
		
		return $this->isZero;
		
	}
	
}

class CFile extends Zero {
	
	private $path;
	private $mode;
	private $fileHandle;
	private $contents;
	
	public function path($path) {
	
		if (!$this->path = $path)
			$this->toggle();
		
	}
	public function mode($mode) {
		
		if (!$this->mode = $mode)
			$this->toggle();
		
	}
	public function open() {
	
		if (!$this->fileHandle = fopen($this->path, $this->mode))
			$this->toggle();
		
	}
	public function read() {
		
		if (!$this->contents = $this->fileHandle, filesize($this->path))
			$this->toggle();
		
	}
	public function write() {
		
		if (!fwrite($this->fileHandle, $contents))
			$this->toggle();
		
	}
	public function close() {
		
		if (!$this->fileHandle = fclose($this->fileHandle))
			$this->toggle();
		
	}
	
}

?>

So now we have a single place where things are "1", and a single place where things are "0" or not, so ok...ok so what we want
to do is go a step further and...ok no we don't want to do that, just like we don't want to have a "Zero" class. So freaking
ok, umm...ok so what we have is...so freaking ok, umm...lets just roll with what we have for now, so ok, now, Cinder...what
does Cinder do? Potentially it does everything, but mainly what we want is for it to have a single value, and what that value
boils down to is Zero->isZero being true OR One->value. So freaking ok, so lets define some stuff:

One is the center of everything
Zero is second to the center of everything
Cinder is a central location for, like, everything
	It will handle everything having to do with the business, Cinder
		This includes:
			Websites
			Graphic design
			Projects
			Art

Ok so what we do is come up with a system that can handle everything in general, not just Cinder, so everything is all up in
everything else and all over the place. So ok, what we do is...what if we make Cinder and go ok, it has a value of 1, then it
has...yea lets do that, its a step further in the right direction:

<?php

class Cinder {
	
	private $value = 1;
	private $isZero = 0;
	
	public function getValue() {
		return $this->value;
	}
	public function isZero() {
		$this->isZero = 1;
	}
	
}

?>

Ok so wait a minute, the fact that we have 1 defined as "One" is better than having it defined as "Cinder". It's not
subjective, which is objective. So ok, thats what we want, so go on...

Ok, so, now, what we do is start programming. We have contrast, we have everything we need, so lets start coding.

Ok, so what we're going to have here is Cinder, which will interpret indifferent data, so like we custom code interpreters for
that data, so thats good. Now, in general, do we want some way of formatting data? XML? MariaDB? So far we have a loose folder
structure that has a "notes.txt" file in it along with numerically ordered folders within that, so like ok:

sandbox
	052521 (MMDDYY)
		1
			notes.txt (or not)
		2
			notes.txt

Ok so we would want the folder structure to be as wide-open as possible...so ok, when we have multiples we simply have
multiple folders (with different folder names), and we go ok, we want as much order and structure as possible, so probably
store all your notes in one place...umm...more on this later.

So ok, to the matter at hand: so we have a 1 and a 0, now what? Now we just start coding...so ok, what we do is go ok, lets
start pseudo-coding Cinder...

Cinder
	fires up
		reads folder structure of sandbox

So ok, what comes to mind at this point is this thing does so much stuff that it's not even funny! So where we could begin is
the layer that handles everything, whether it's JS or straight PHP. We could also start by coding a database connector...from
there everything should flow out...so ok first things first, how does everything come together, accounting for script and
noscript tags? First its straight PHP, then its PHP-to-JS. So what we do is code straight PHP, with JS in mind. So lets get
down to business:

We would have PHP
Then we would take things one thing at a time
	So we would:
		connect to the database
			connect
			query
			close connection
	This would be seperate from:
		sending this data to the browser (noscript)
		sending this data to javascript (script)
	At some point...

So, procedurally, line by line, what we have is:

1
(potential) 0
connect to the database
query the database
disconnect from the database
display the results of the query...

Ok, if we code a database connector, it should all come out. If we code anything, it should all come out. So lets say we have:

<?php

class One {
	
	private $value = 1;
	
	public function getValue() {
	
		return $this->value;
		
	}
	
}

class Zero extends One {
	
	public function zero() {
	
		die("Something went wrong...");
		
	}
	
}

$Zero = new Zero();

if ($Zero->value)
	echo $Zero->value;
else
	$Zero->zero();
	

?>

Ok yea so it totally works, now what should we do? Now we come up with tiers and tiers of logic, all kinds of stuff...so ok,
continuing to get down to business:

One
Zero
Cinder
Error handler
Database connector

Ok, now, how do we generalize all of this stuff? So ok at the point at which there are two things going on, there's no way to
do that. At the point at which there is one thing, there is a way to do this. So ok, 1 is at the center of it all, everything
is secure and all that, so what do we do? Generally speaking, in syntax, we would have something like an if (or switch)
statement guiding things along. The core of this statement would be a value, ok lets try something: lets code a database
connector and see what we get (along these lines):

<?php

// include classes

class DbConnector {
	
	private $host;
	private $username;
	private $password;
	private $database;
	private $connection;
	private $query;
	private $result;
	
	public function __construct($host = "localhost", $username, $password, $database, $query) {
		
		$this->setHost($host);
		$this->setUsername($username);
		$this->setPassword($password);
		$this->setDatabase($database);
		$this->setQuery($query);
		$this->connect();
		$this->send();
		
	}
	public function setHost($host = "localhost") {
		
		if (!$this->host = $host)
			$this->fail();
		
	}
	public function setUsername($username) {
		
		if (!$this->username = $username)
			$this->fail();
		
	}
	public function setPassword($password) {
		
		if (!$this->password = $password)
			$this->fail();
		
	}
	public function setDatabase($database) {
		
		if (!$this->database = $database)
			$this->fail();
		
	}
	public function setQuery($query) {
		
		if (!$this->query = $query)
			$this->fail();
		
	}
	public function connect() {
		
		if (!$this->connection = new mysqli($this->host, $this->username, $this->password, $this->database))
			$this->fail();
		
	}
	public function send() {
		
		if (!$this->result = $this->connection->query($query))
			$this->fail();
		
	}
	public function getResult() {
		
		return $this->result;
		
	}
	
}

?>

So the working code (appears to be):

<?php

class DbConnector extends Zero {
	
	private $host;
	private $username;
	private $password;
	private $database;
	private $connection;
	private $query;
	private $result;
	
	public function __construct($host = "localhost", $username, $password, $database, $query) {
		
		$this->setHost($host);
		$this->setUsername($username);
		$this->setPassword($password);
		$this->setDatabase($database);
		$this->setQuery($query);
		$this->connect();
		$this->send();
		
	}
	public function setHost($host) {
		
		if (!$this->host = $host)
			$this->fail();
		
	}
	public function setUsername($username) {
		
		if (!$this->username = $username)
			$this->fail();
		
	}
	public function setPassword($password) {
		
		if (!$this->password = $password)
			$this->fail();
		
	}
	public function setDatabase($database) {
		
		if (!$this->database = $database)
			$this->fail();
		
	}
	public function setQuery($query) {
		
		if (!$this->query = $query)
			$this->fail();
		
	}
	public function connect() {
		
		if (!$this->connection = new mysqli($this->host, $this->username, $this->password, $this->database))
			$this->fail();
		
	}
	public function send() {
		
		if (!$this->result = $this->connection->query($query))
			$this->fail();
		
	}
	public function getResult() {
		
		return $this->result;
		
	}
	
}

?>

Now, nothing really comes to mind as far as what we should do at this point except...extending it to handle multiples, so like
multiple connections, multiple queries, and multiple results. Lets do it.

This appears to work:

<?php

class DbConnector extends Zero {
	
	private $host;
	private $username;
	private $password;
	private $database;
	private $connections = [];
	
	public function setHost($host) {
		
		if (!$this->host = $host)
			$this->fail();
		
	}
	public function setUsername($username) {
		
		if (!$this->username = $username)
			$this->fail();
		
	}
	public function setPassword($password) {
		
		if (!$this->password = $password)
			$this->fail();
		
	}
	public function setDatabase($database) {
		
		if (!$this->database = $database)
			$this->fail();
		
	}
	public function connect() {
		
		if (!($this->connections[] = new mysqli($this->host, $this->username, $this->password, $this->database) ||
			  $connectionIndex = count($this->connections) ||
			  $this->connections[$connectionIndex]["queries"] = [] ||
			  $this->connections[$connectionIndex]["results"] = []))
			$this->fail();
		
	}
	public function setQuery($connectionIndex = 0, $query) {
		
		if (!$this->connections[$connectionIndex]["queries"][] = $query)
			$this->fail();
		
	}
	public function send($connectionIndex = 0, $queryIndex = 0) {
		
		foreach ($this->connections[$connectionIndex][$queryIndex] as $index => $query) {
			
			if (!($connection = $this->connections[$connectionIndex] ||
				  $connection["results"][$index] = $connection->query($query)))
				$this->fail();
			
		}
		
	}
	public function getResult() {
		
		return $this->result;
		
	}
	
}

?>

So what we have is a simple index.php file in the root of our sandbox that require_onces "php/classes/"-"One.php", "Zero.php",
and "DbConnector.php", then instantiates a DbConnector. No errors, so assumed to work just fine.

Ok, so, now what comes to mind is generalizing syntax: we have multiple Zero->fails, as well as multiple...

Ok so we don't use multiple queries/results from database connections because if we change the database in between queries the
data is inaccurate, so if we try to do anything with the results of a query, or the query itself, against the current data,
it's inaccurate. So ok now if we have multiple database connections...lets say we connect to the database, then we make another
connection to the database (or another database), freaking...just keep coding dude...lets just assume we can have more than one
connection and go from there, this makes (certain) sense.

So ok, you have a database connector...now what? Now ok I'm thinking what we do is use cascading logic to build a HUGE system,
so what we do is go ok, we have ALL the bells and whistles: freaking errors, PHP and JS, warnings, notices, layers of data
storage mechanisms, freaking...ok dude, what would this bad boy do? So it would fire up Cinder, then it would read the sandbox
folder and assimilate everything...done for the night dude. Don't even wanna get started on this hah. :)

Ok dude, I'm freaking going in! I'm so freaking down dude, what the hell is this?! Freaking ok, if we have a database
connector, then what? Ok, so then we extend that and see what else we get. Ok so what is the point of coding a view for this
thing at this point? Doesn't really make sense? I mean if we do, we have to freaking do ALL this stuff, like ALL of it. So
freaking ok, before it comes down to ALL of it, what if we code something like a File class and line it up with what we have,
then see what we have? I don't think it'll really reveal much...it will clarify some stuff though. Lets try it, it's quick and
easy. Ok so these could basically go in any order, because they aren't dependent upon one another. So freaking ok, umm...
DbConnector would extend CFile because CFile...ok which one would extend which? Freaking umm...like...the...ok so if we had a
file, and we wanted to do something with that file with a database connector, like put its content in a database, what we do is
we have the file, then we open the connection with the db connector, then we put the file in, then we close the db connection,
then we're done. Now, if we want to put the contents of a database in a file, we open the database connection, get the data we
want, put the data in the file, and close the database connection (and the file handle). So which one comes before which?
Umm...ok so a database connector would come before a file class when: the syntax of the database connector "comes before" that
of the file class, so ok when we create a file class instance, we don't need any information, when we create a database
connector, we have the option of specifying details like the host, username, etc. So freaking ok, now, in general, when we're
using a database connector and dealing with files, which comes first, the database connection or the file? Umm...we could put
the contents of a file in a database and the contents of a database in a file, so, I mean, then what? Handling files is done
directly in php (there's no "mariadb" or anything that we're dealing with), therefore files come first? So freaking ok, what we
do is assume this is the case until further notice. Freaking ok, so files...

Ok dude, so freaking ok, now, if we have two different databases, in cascading logic, what do we have? We have a "database",
so any "type" of database...then from there, what do we do? Freaking ok, so we have a database...so we program a generalized
database class, so freaking...umm...ok so like what is that? What that is is a system that has all of the bases covered, so...
quick n' dirty, if it is 1 and fails (dies) it failed, if not it succeeded. So ok, umm...freaking umm...dude...its happening...
we're working through it dude...freaking ok dude, so what this is is...:

database
	mysql
	pdo(?)
	...

So then what we do is program a database, moving more towards the fundamental, so I mean we use cascading logic to go up the
chain ("database"), then we use it again in the opposite direction? Freaking umm...freak yea dude...this is so freaking bad...
dude if this works freaking RUIN it dude, completely fucking bring it down dude. Smash it. Walk right up to it and take it,
take it for all its worth.

So freaking ok dude, what do we do here? Umm...so I'm thinking what if we make an error class that extends the Zero class
and...what we do is...freaking umm...so what we do is...so we have an error class, which doesn't handle death, so...it's
fluff...I mean if it just returned a simple string, like for the time being, this would be cool. So ok lets build this bad boy
and see what we get. Ok so I'm thinking if we freaking have a database, then what? Ok so the thing is the line stops there,
unless you advance it at all, so what if we simplify it...:

1
	database
		mariadb
		pdo
		...

So freaking ok, what we have is...we have a 1, then we have...a database...then we have some string...so freaking ok what this
is is...our DbConnector class, so:

<?php

class One {
	
	private $value = 1;
	
	public function getValue() {
	
		return $this->value;
		
	}
	
}

class Zero extends One {
	
	public function __construct() {
		
		
		
	}
	
	public function fail() {
		
		die("Something went wrong...");
		
	}
	
}

class DbConnector extends Zero {
	
	private $connections = [];
	
	public function __construct($host = "localhost", $username, $password, $database) {
		
		$this->newConnection($host, $username, $password, $database);
		
	}
	public function newConnection($host = "localhost", $username, $password, $database) {
		
		if (!$this->connections[] = new mysqli($host, $username, $password, $database))
			$this->fail();
		
	}
	
}

?>

So freaking ok, what we have here is some string...this is compatible with our system...so freaking ok, what we do is...
Freaking umm...what we have here is we have a thing, DbConnector, written in string, this is the importance of this at this
point is it is written in string, so ok...like ok it creates a database connector (mysqli), with string, so ok what this does
is...ok if we look at it WAY fundamentally, freaking...we create a mysqli with DbConnector->newConnection, and freaking...
umm...what this does is if it doesn't work it fails (dies), if it does work it pushes the connection into
DbConnector->connections (array). So ok, the answer is somewhere in here. There are two of them, so I mean...ok first thoughts
are we should make our zero class either flash a zero or not (so its string, like One), then both are string. Lets do it. Ok,
so now what we have is:

<?php

class Zero extends One {
	
	private $zero;
	
	private function setZero() {
		
		$this->zero = 0;
		
	}
	private function resetZero() {
		
		unset($this->zero);
		
	}
	
}

?>

So freaking ok, umm...now what we can do is use a single...no we can't do that...ok this isn't fundamental enough. I mean it
kind of is though, what exactly is that? How do you lay down a 1 and a 0? So a 1 would just "be there", so as long as...it's
there somewhere, the string is there, so it's good, the rest of it can come or go. Now, what about the rest of it? So in
general, with our DbConnector class, we have a two-way circuit, one "1" and the other "0", so then what we do is...:

<?php

class One {
	
	public const ONE = 1;
	
}


class Zero extends One {
	
	public const ZERO = 0;
	
}

?>

So freaking ok, umm...ok what we do is...this is much better, much cleaner...so now we have a binary system, quite binary as
the "1" and "0" are constant, or "const", so...freaking ok, what we do is...freaking wedge that shit in there dude...freaking
ok what we do is...ok so it would be even LESS string to just use "1" or "0", so lets chock the one and zero class..."1" and
"0" are each a single unit of string, so that works...or just this works within the current working version of PHP installed on
this machine, so...what we have is:

<?php

?>

Hah. That's what that is;) So ok, now from this point, what you need is...ok so rather strictly speaking, "1" and "0" are each
a single thing, so we can advance from here. Either way it will work, so lets do it.

Ok, so freaking what we do is go...now we have some string...so ok "0" would be false (in the current working installation
of)...

Ok so what we do is go ok, we're talking about PHP from this point on, unless otherwise specified, so:

1 would be true
0 would be false

Now what we do is go...

So I aksed Nancy "What is true"? (outside of PHP)
She said:
	opposite of false (positive, false = negative)
	true can be negative
	true is always correct
	"gold" versus "lead"

So now take this and apply cascading logic to it and bring it to a point.

So freaking ok, what "1" is is...a number, just the thing is "0" is a number too, so that doesn't apply (we need to know what
the difference is between the two of them, not how they are the same). So ok, quick n' dirty, 1 is a success, 0 is an error...
so on 0 we should die or something like that, and on 1 live (or something like that;). That describes, at all, what the
difference between 1 and 0 is. So freaking ok, umm...what we freaking do is go ok, so there is a difference between 1 and 0:

Number (or so)
	1
		success
	0
		failure

Now, what we do is like extrude this into a system...so ok umm, now what is a success? (In PHP) a success is something that
"works", so something that doesn't generate a fatal error or something keeping the rest of the script from running (crashing
PHP), at least...and the opposite is a failure, so what exactly is a success?

Umm...freaking...ok so if PHP doesn't crash (die), code can continue to run...so that is at least what that is, is the ability
for code to run, so ok what else? Isn't that the end of it, then, hit or miss? Well ok, so freaking...lets say it doesn't crash
php, therefore it isn't a failure. So freaking yea thats what that is. So freaking...what our Zero is is what we had, pretty
much. So we have:

<?php

class One {
	
	public const ONE = 1;
	
}

class Zero extends One {
	
	public function crash() {
		
		die("Something went wrong...");
		
	}
}

?>

Freak yea dude...thats freaking bad, quick n' dirty, you name it. Now freaking build dude. So ok what we have here is:

<?php

?>

Perfect! Empty PHP file! Ok dude, so freaking now what? Now we build. Now we fundamentally build. So ok dude, build it well,
and you will be equally rewarded. Time to go get my shot, bbl.

Ok back, now freaking ok, what we do is...now we just keep stuffing stuff in there until we get what we want: so freaking what
is the same about any two things? "1". Ok, now, how do we program a LOT of stuff with very little code? The thing is what we
should have is a repeating pattern, so something like:

succeed
crash

So ok, what would happen is we would succeed (an empty PHP file), then we would crash (the end of the php file). So ok, this is
consistent, so freaking what we do is...we go...we freaking use something like:

if not something
crash

Then we just bulldoze php. So what we do is...what does everything have in common, coming from the broad end? Umm...so ok lets
say everything would have an error handler, so we code one of those...now more fundamentally, yet still taking this into mind,
what does everything have in common?

Ok so lets build an error handler...what if we use our DbConnector class to do this? So lets say everything would have a
database connector, so freaking ok, umm...so like fundamentally everything would have a type...so we would have something like
types, then we would have...ok so this is also transparent in php, so we're consistent, we're good...so freaking ok, now beyond
types what would everything have in php? 

So ok what if we had a system that...so then lets say we have a buffer of values, then we run through those values and check
for any false values, and fail if we have any. So freaking ok, then we just load our buffer, check for errors and crash if we
find any, OR, we just run any old script in php and if it works it works (php doesn't crash), and if it doesn't it doesn't.
This is simpler than what we have, and still works, so lets do it (it works; if we want to change it back or something later we
can).

So freaking ok, now what? Now, in general how do we do stuff? So we run some code, and it either runs or doesn't. Now, what
else about it? I want more. I want more than this.

Oh freaking kay dude, o freaking k, what we do is...so if we have a callback on an array, and we check each value for truth,
what do we freaking get? Umm...freaking a dude, you're totally doing this dude, I am forcing you to do this.

Ok dude, so like in cascading logic how far out can we go before there is no more? So ok in terms of PHP we would have:
success, an error, a database connector, some string, a value, a type:

success
	type
		value
			error
				string
					database connector

? Does this make sense? Freaking umm...makes relative sense? Ok, can you see how the more fundamental something becomes the
broader its application? Yes. Ok, now, so at a point the broadest application in php is string, the code itself. So freaking
ok, so what is this in code? So ok, lets go back to...now if we buffer the output of all of our function calls and stuff in a
buffer, then check it for truth, freaking what we come up with is something that works when: ok if we just fail when we fail
everything is all broken up...the ONLY thing I can think about this is that if we fail on any false value we correctly apply
true and false to all of php, and from there we have a (very) consistent thing going on in php...so ok lets...ok so we have a
buffer, then we run some functions through there, then we fail if we find any false values in there, now it would be better if
we failed the moment we hit a false value, so we wouldn't need a buffer for false values, we would need a single thing that
fails (on any false value). So what we do is...now ok if you fail on any false value, you fail whenever you have a zero. Umm...
ok so back to what we were talking about, there IS a way to do this, freaking ok, we have something like an error handler that
fails on any error...so freaking ok, what we do is set an error handler...umm...ok so so we build this thing from the ground
up, both work. Ok, so freaking umm...what we do is...ok so if we approach this with cascading logic, how do we freaking do
this? There's no difference, and we use cascading logic to do this. So freaking ok, what we do is...freaking...ok in cascading
logic how does our database connector go down?

So it connects to databases
it queries databases

Ok so stop right there, so the cascading logic there would be that it connects to a database before it queries a dataabse, so
we have kind of an idea of what is going on here. So what is the syntax for doing this?

<?php

$mysqli = new mysqli("localhost", "Cinder", "alphanumeric13", "Cinder");
$mysqli->query("SELECT * FROM `test`");

?>

So freaking ok, umm, what we have here is...ok so something that comes to mind is that we need function arguments before we
call a function...so freaking ok, umm, what we would do here is...we would freaking...so hard dude...so freaking what we would
have is like ok everything would have a value...would everything have a value? Umm...freaking...so if we had a function that we
passed some arguments, those arguments would have to be values. Other than that, there's...ok run with it dude, so everything
in php is a value (or some string?), so freaking ok what we do is go...every value has a type...ok lets try something:

<?php

$value = "Hello world";
function myFunc($value) {
	
	echo $value;
	
}

myFunc($value);

?>

So freaking ok, everything in php would be a value, and php would output some string, and...this string could be buffered and
assigned to something, so freaking...freaking ok, umm, so freaking...freaking dude, lots of freaking...so ok, what we would
have a value, or some output, so which is it, value or output? Output. Ultimately, it would be output. Ok, so freaking we have
some output...then we...ok so if we didn't have any output...our script could still work, just...the output is the only thing
on the screen, and not the value, so its output and not value. This is the way.

Ok dude, so freaking...so freaking so freaking...we would have some cascading logic, and what this would say is...that we
either do or do not have any output from the script. So ok, lets say we have some string (the php code itself), now the thing
is that the code is string, so ok if we output this to the browser we have some output. Ok, now freaking umm...so what this is
is...ok so what is so high and mighty about the output? The view. Ok just keep riding it dude, so freaking ok, so we have some
output (or something), so now what is that output? So freaking ok, echo converts everything to string...ok so freaking umm,
our output is string, or some string-like substance, so its safe to assume its string (we can always correct ourselves in the
future), so ok we have some string. So freaking ok, we have string in, string out, so fricking then what?! Umm...so freaking
ok, clinging to the white, it would be string output because of the white background of the browser. So freaking ok, umm...ok
so it would be string output, because it would be (at least) string, and other than that it would be nothing, so other than
THAT it would be string. So its string!

So freaking ok dude, now, if this doesn't work we can always come back and fix it. So ok, umm...so the broadest something gets
in php is string. So from there, in cascading logic, what is going on here? So freaking ok, dude, umm...I think this works
dude: if there is freaking 1 in, and 1 out, don't we have 1? There would be no difference, so we would have 1, then there would
be I/O, and both would be 1, so in our indifference we would insert our input (1), then in our output we would have 1, then we
would so much as still be in our indifference, therefore 1? So if we have a pipe in a vacuum, isn't that what that is? Isn't
there therefore no difference?

Freaking ok dude, umm, ...ok so if there's no difference, there is 1, therefore output? Or what? Ok so out of the big picture,
what is the cascading logic to get from point a to point b? So ok, in general, then, what are things? They are at least
numbers, they are at least strings, they are at least...ok so our input is string, so that is the end of it as far as that is
concerned. Now do we have any output? Lets run with our input (input is one thing) and see what we get.

So our input is string (we're still inside php: remember, I said we're inside php until I say otherwise?), and that string
doesn't have to be php. So we would have string, then we would have "php code", and that would be the two shades of grey as far
as php is concerned. So ok, now, freaking...so inside of php we have...like, input and output. We have input, so our string
input, then we have output: whatever php is doing as far as output. It could be directly outputting string, it could be
outputting string to a file or something, there is more than one thing it could be doing at that point. So as a whole, it is
simply called "output". Now, our "input", on the other hand, simply takes some string, looks through it for php code and parses
that code. So ok, umm...now our input would be code, so what we have to do is reduce code to a point.

So what is code?

Neo question. Freaking what is code? Ok so if we back up a little bit, input is string, output is...should be one consistent
thing...at least string. Now if we need to store objects and stuff in files how do we do it? Umm...freaking...yea its string.
It's string or its object, so its string, then its object or string again, and its already string so its just plain string.
Again if we're wrong we can always come back and fix it. We can ALWAYS come back and fix it.

Ok dude, so we have some string, freaking what now dude? Freaking umm...ok so what we do is...freaking...ok so we have some
string, now what is the cascading logic of string? So in regular expression, we would: use or, and not and, to work with
strings, because it's more flexible than and. So freaking ok, umm...or is this how we would approach this? Ok so we would have
some string, then that string might have some...php in it...so lets say we have the following:

Hello world
<?="How's it going?"?>

Works. Now, what we have is some string:

.*

Then what we have is a php tag...freaking ok dude this is gonna be gnarly...are you sure you're down? What if we take a less
gnarly approach to this? Like ok, all we have to do is...freaking...freaking umm...ok so we would have some string...ok so in
general what is going on here? So we would have indifference, then if anything we would have a second thing that would crash
the system. Then, umm...so ok if we code something with these two things it should all just come out? Ok, so now is there a way
to get an idea of what that is, BEFORE we start coding (it's gonna be a lot of work to just straight code this thing, if you
could figure out a pattern or something like that maybe you could cut down the amount of work it would be). So freaking ok,
umm...freaking ok dude, so...what this would be...white dragon dude...what this would be is...surgical. So ok, here's what we
do: freaking we build, then we examine the cascading logic to figure out how to build this thing. Freaking ok, umm...

So we begin our examination:

So freaking ok, anything in php would output some string, based on: yea it would output string. If we escape php by one, we get
string, so all of php is made of string. So freaking ok, now, if we have a function (fopen was what we used to do this), that
function has arguments that have a type. Now, other than a function, what do we have to do stuff in php? A function is a
wrapper for re-usable code in php. So, umm...so freaking ok, now...if we have a function, we run some code in that function.
What that code does is either assign values to variables or directly output string (via echo, etc.). So freaking ok, umm...what
we would have here is...freaking some string, then umm...freaking...umm...freaking ok dude, so freaking what this is is...
umm...freaking ok we have something...so ok at least what we have here is types, every function argument has a type. Then we
have functions, then we have variables, then we have the output of php itself (some string). So ok, at the end of the line we
have string. This is consistent. So freaking ok, now, umm...ok so thats what that is dude...that's what that IS. So we would
have some string, then we would have some function arguments, then we would have some functions, then we would have a value,
then we would have a variable. So ok, a function...a function would return a value of a type, so freaking ok, thats what that
is. Now what does it look like? So we would have some string (php code), then we would have function arguments (of certain
types), then we would have a function, then we would have some string again. So freaking ok, what we would have is some string
(php input, so some code or something like that, lightly), then we would have running code (once we ran the php script), then
we would have function arguments (of certain types), then we would have a function, then we would have some string (either a
return or some output). So ok what we would have is either a value or some string (output). Now, the thing is, both output and
value can be string. Ok, so then we would have some string, then we would have some code (string). Ok, so then we would have
some string, then we would have a value of some sort (that converts to string). So freaking ok, umm...so we run a function,
then we have a return...or we have some output. So freaking at that point we have some string, still, so we have some output.
And that's that! Well I mean pretty much, so freaking we would have some function arguments, with types, then we would have a
function with a return type, then we would have a return, and ultimately we would have some output. So freaking ok, now we have
some string, then a function, then some output, all string. Ok, now, how do we do this? 

So ok we would have:

type
string (some php code, or just plain some string, in a .php file)
function argument(s)
function
return value or output (string)

...ok, so what this would be is...we would have a function, and that function COULD output some string, AND could have a return
value, so it's not a matter of or, it's a matter of and. So then ok, umm...freaking...we would have a function, and it could
output some string, ...ok lets imagine we have a value in php, and we want to store that value to a file. We would use string
to do this, so its string. Ok, so we could have a function, and that function could output some string (to the browser), and it
could return something: it therefore has a return type, so...smoke one dude...

Freaking ok dude, get your music going...ok, so freaking we would have some string...then we have a function, freaking umm...ok
so we would have a function, then we would have some output (directly to the browser, some string), then we would have a
return. Ok we would have some output, or not, then we would have a return, or not. So freaking ok, umm...then we would have
some string, then we would have some php code, or not, and that code would...have some variables, then some output...so then
we would have some string, or not, then we would have some php, or not, then we would have some variables with types, or not,
then we would have some output, or not. So we would have a pattern where we would have something, or not, or rather not have
something, or have something, and that something would be:

string
php (code) (string)
variables
output (string)

Ok so the only thing here is that...when we convert objects to strings we don't get a literal translation of the object to
string. So the only way an object is string is...or ok so how do we convert returns to string? Ok so then what we would have is
some output and a typed return. So ok, umm...so ok the thing is the output is equal to whatever it is after php is done
executing (the output is in the browser). So BEFORE that, when variables are still in play, we would have a typed return from
the function, so we would have: some string, some php (code), some typed variables, some functions with typed returns, and
finally, some output. So we would have some string, which is some output, so we would have some typed variables, some functions
with typed returns, and finally, output. So then we have some variables, which are not output, and some functions with typed
returns, which are not output. So ok, now, we can have variables in functions but not functions in variables, so lets say we
have some functions, and thats it. So we have a function. Ok, so freaking what we do is...ok so from this point we have to
escape the php to properly represent everything in string. Ok, so if we convert everything to boolean, or 1 or 0, our function
has a return of 1 or 0. Then, the rest of the php code runs, everything is converted to 1 or 0, and finally, the output occurs.
So if we convert everything to 1 or 0 we should be good. One step further and we're just plain good, as is. So ok, what we're
going to do is change our crash function to a zero constant, so we have a single thing to work with. Do it. Then we're going to
go one step further and just type a 1 or a 0 when we do that, smaller in syntax.

So we have a system of:

1
0

So ok, now, we have a two-way circuit, now we just need to hook everything up. So lets say we have a function (again), the
return value of that function is either 1 or 0, so Number(Boolean). Ok, so now what we do is...ok so we have a system that is
string, that is either a "1" or a "0". Now what we do is...go big and freaking translate every bit of cascading logic there is
in php, so ok...so if we code this thing...ok:

function arguments would have types
functions would have return types

So ok the output to the browser would be string, so maybe the output of php isn't just plain string, but thats a starting
point. So ok then we would have some php code, now, in the browser, if we don't have any output (string) we don't have anything
to work with in, say, JavaScript. So freaking ok, umm...lets just do that and say we're solely communicating with javascript,
to limit our input and output. Now we have php, so we have some GET or POST variables or something like that, then we have our
output, which is string so javascript can interpret it. So ok, umm...or lets say that purely in php we escape some php code, so
we're purely in php, then we go ok, umm...freaking...so freaking a dude...freaking umm...umm...so ok lets build this thing and
see what we get, it should all come out.

Umm ok, so lets say we have a function, then what? What were you getting at dude? Freaking ok, we have a function, which
returns something. Now, that something has a type, and freaking ok, so when we get this return we convert to 0 or 1, then what?
Then that's it. So ok, umm...so ok then we have to like...ok what about, how do you know something has the same value as
something else? What exactly is the cascading logic there? Freaking or what dude, how do we approach this thing...so freaking
we're in php, then what? Hah. Back to square one ;) So freaking we're in php, then we go ok, freaking...umm...we freaking...lol
dude what do we "freaking" do?! Umm...ok so a function would have a return type, and would be in php. So it might as well be
anything, who cares if it has a type or not. Ok, so freaking umm...freaking...what would we do dude? We would freaking...lol
dude! What would we do? This is kinda fun. Ok, so freaking what we would do is...freaking...ok so if something in php has a
type...umm...just drill a hole in there dude, so freaking it has a type, then freaking umm...then we have a variable. Then what
we do is do something with that variable; echo it, etc. So freaking ok, by a hair this works...so what we have is:

variable
function (return)

And like thats it. So freaking ok, umm...so we have a two-way circuit, one is 1 and the other is 0, so freaking ok, umm...now
what we would do is hard-wire these things...so...ok so we have the pattern...variables would come first, then functions
second, because variables store values and functions don't, so freaking ok, umm...what we do is...build a freaking system out
of these two things lol. :) So freaking ok dude, I guess this is where we hit it. So fricking what would this thing be? It
would handle freaking everything in php (and beyond), so umm...ok so freaking we construct variables with types, every variable
has a type, and then a freaking value, so ok...what we do is...we beef up our system and generalize everything. So lets take
our CFile class and generalize it.

So freaking ok, in general we have variables, then we go ok...umm...so lets say we have a mode and a freaking path, these are
strings, so ok we would have a type class...so we would have:

1
0
type

or maybe, now that I think about it:

0
1
type

So freaking ok, umm...so we have three things that indicate that we're just using vanilla php. So freaking ok, umm...if we have
three of the same thing, and fundamentally these are the same thing, the same logic applies in binary and here, that three is
the maximum complexity we can use before we're being overly redundant. So freaking ok anyways, so go on, everything would have
a type. Then what?

Ok so freaking we would have some input, some code, some string, then if we don't have any output effectively nothing
happened. If there's no output nothing changes, so ok lets run with this until we get there. So freaking ok, we have input,
then we have output, so we have some input, then every variable has a typed value, then...then we have variables, and thats it.
So freaking ok, umm...what we do is do stuff with our variables, then output them, or else nothing changes. If we don't output
anything (to the browser), nothing, 0, happens (and therefore php fails). That's definitely not what we want. Or ok, if we run
some php without outputting (to the browser or a file or something) a tree fell in the woods but no one heard it. So freaking
ok, umm...what we do is...freaking...ok so we beefed up our system a little bit...so we would have types, then we would have
variables, then we would have functions...ok so what happens when this completely describes php? Ok so just to be sure, if we
run some php but dont output to the browser or something, does effectively nothing happen? Something happens, just it doesn't
change anything, so effectively nothing happens. Ok so we know, if we don't go past that point, that effectively nothing has
happened. Now, if we write to the browser or something, something has happened. So thats what that is. So freaking ok, umm...
smoke one dude.

So freaking ok dude, what we would do is we'd have a freaking thing...we'd have some string, and that string would be parsed,
and then we'd have some stuff...now if we don't have any string out effectively nothing happened (in fact, inside of PHP, the
boolean value of this is false, and then the numeric version of that is 0). So ok, what we have is:

php runs (1)
some script parses (1)
no string output (0)

So we have to have output to have success. There freaking fore, so what we would have is freaking...umm...so freaking umm, so
we would have types...so ok, before we would have variables we would have functions, because these can output without
variables, so we would have:

0
1
types
functions
variables

So freaking...umm...ok what if we could do this without functions...like if we put the functions inside of objects? Freaking
umm, we would have functions after types because we can have return types on functions, then we would have variables because
we can have function returns assigned to variables, but we can't have variables assigned to function returns. So we would have
types before these because they have types, but types can't "have" functions or variables. Then we would have 1 because of a
quantum leap, then we would have 0 because 0 is less than (comes before) 1. I THINK this is correct. Ok, so freaking then what
we would do is...then its like wide-open, we can start coding and everything, so what we do is...we use this pattern to
dynamically code everything. So ok, lets say we wanted to code a File class...what we would do is...lets examine CFile to see
what we're doing here. So lets say ok, the first thing about CFile is a property called "path", which is a string. Now what we
do is go ok, so string is a type, and type is 1, then it is 0. So what we do is...freaking go...umm...uhh...so ok we have
something that is 0, then what? How does it become a 1, then a type, then a function, then a variable? Ok first of all I think
it goes like this:

1
0
type
function
variable

...so ok, whatever it is, its 1, then what? Then how is it 0, then a type, then a function, then a variable? Ok so on the way
down, or whatever...ok what if we coded this long-hand to like see how it goes? So in our CFile class, what is going on along
these lines? Ok so what we have is like fundamentally string (code), like or how else do we dynamically define a function? So
freaking ok, umm, what we do is...go...hah how the hell do you do that dude? Lol. Umm...so if we freaking dynamically generate
some classes or something, what we do is go...

We have an idea, then we translate that idea to...ok umm...how we would do this is...the only way to generate functions in php
is to eval some string (code), so what we do is generate some string, yes, this is definitely what we are trying to do, at
least a little bit, so ok we go ok dude, all we need is a little trickle, freaking ok we...so we generate some code, and what
we do is go ok, what are we TRYING to do? Lets say we're trying to read a file or something. Now how do we generate code to do
this? Umm...we go ok, we need at least our CFile class, so what we do is...we "detect" that we need to read a file, so what we
do is, lets say we have a string that is a path to an existing file, so like, umm...we go...ok so if we were to code...if we
were to code something by hand, what would we do? We go ok, depending on the input, we make the output a certain way. So
freaking, ok, what we do is...we go ok, umm...hmm...what do we do anyways? Umm...hmm...so we would dynamically generate some
string, which is what we want, which is strictly one thing, then we freaking go ok, umm...freaking umm...hmm...call it quits
for the day or what? Yea I think I'm done for the day, battery is almost dead anyways. Peace out until tomorrow.

Ok I'm back, not done with this thing yet. Gonna make good on my hours and stuff, so like im'a keep working. So freaking ok,
umm, now, if I hand-code this thing, what I do is go ok, I have...lets say I had some parameters guiding the build:

it needs to output some string
that string needs to be "Hello world"

So freaking ok, what we do is go ok, we need to "echo" the string "Hello world". So what we do is "output" to the "browser"
"Hello world". So we define our output, then we define our "variable" ("Hello world"), then we "output" our "variable". So
freaking ok, we define our output as something that simply echos a value, then we define our value as a variable with the value
"Hello world", then we output our variable and we're done. So freaking ok, umm...:

<?php

$variable = "Hello world";
function output($value) {
	
	echo $value;
	
}

output($variable);

?>

So ok, what we do here is generally take in some variables, then we generally define our output, then we generally output our
variables. Now, lets say we wanted to do something more complex: take two variables of certain types, do something with them,
then output the results. Freaking ok, so we input the variables, then we use a function or something to do something with them,
then we output that result. So freaking ok, umm...umm umm umm...hmm...so freaking what we do is...freaking...ok so if we
generate code what we do is...at least use some existing code to come up with the code itself. So in general, when we code
something, what do we do? So ok, umm, so what we do is we make one out of two, so lets say we wanted to code two file
classes...what do they have in common? Probably all of the filesystem functions they use to function. So ok, what is THAT?
Freaking so complex dude...ok so if we hand-fed this stuff in there, what we would have is filesystem functions that would...
take freaking...like ok if we needed a writable file handle, we would look up the file handle, then look up the writable file
handle, then look up the function that creates one (fopen), then we would look up the function arguments, then we would...come
up with a filename to write to, then we would open the file handle. So freaking ok, this DOES make sense! Ok, so there are
general functions for working with file resources, so I mean it's all there, just we have to code the thing. So freaking, ok,
umm, what we do is...ok so in general we can read/write files, so then what generally are the requisites of doing stuff with
files? So ok, we would have types, then we would...we would discern what types came before which, so like ok, umm...so we would
have 1, then 0, then a type, then we would have a function, then we would have a variable. So what we do is go ok, we have a
function, and that function might return a value, and that value...umm...dang this is hard dude lol, such chew though...so ok,
what we would have is...php...then we have some output, and that output is made out of code, like pure code, like its made out
of at least echo, which is like pure php. So freaking ok, umm...

Ok I have made the simple observation that numbers can only be positive or negative in terms of their sign, so the way we
translate numbers is:

0.1 would be the integer 1, because both are positive (and 1 is the next integer to 0.1)
0 would be 0

So freaking ok what this means is now we have a map of numbers. Or, rather, we have a map at all in terms of there being a
difference. So freaking ok what that is is...so freaking ok, umm...so we can work with numbers, now, freaking, how do we
translate string to numbers?

Empty string has a length of 0, whereas non-empty string has a length equal to how ever many characters that string has. So
freaking ok, umm...now, a character in string would have an encoding, so it would have a numeric representation of a character
in an encoding. Now, these encodings ARE logically laid out. They may not be ordered (or anything, for that matter), but they
make relative sense, and that's all we need to do this. So freaking ok dude, umm...lets do this tomorrow dude, its freaking
bedtime.

So freaking ok dude, I was thinking and: 0 is not a positive number ("negative"), whereas 1 is a positive number, so freaking
just like 0.1 is a positive number, and 0 is a negative number, so the way we would convert decimal to integer is to preserve
the sign, then use the next integer to the right.

So freaking ok, now what do we do? Now we freaking convert everything to Number and go from there. So freaking ok, umm...quick
n' dirty:

to-int
----
double - positive is 1, negative is 0
integer - same as double
boolean - true is 1, false is 0

Ok so what I'm thinking is what kind of system is this if we don't create it purely out of nothing? Out of default
indifference? So freaking ok, so what we do is go there's no difference, so what is that? How is, for instance, indifference
one thing?

So freaking ok, umm, freaking, if there's no difference, what exactly is that?:

<?php

$return = 1;
function someFunc($return) {
	
	return Integer(Boolean($return));
	
}

if (someFunc($return)) {
	
	// do something "indifferent" on success
	
} else {
	
	// do something "indifferent" on failure
	
}

?>

My point is that even if we successfully convert php to absolutes, we still have to figure out what indifference "does" to code
this thing. So freaking ok, umm...so something happens, and there's no difference. So ok, a function fires and assigns a value
to a variable, there's no difference, so...umm...freaking...umm...so there's no difference, then what? So freaking ok, umm,
if there's no difference, there's no difference on the way in, on input, so what is THAT? So freaking ok, umm, ummmm...so we
would have to code to account for the entirety of...we would have to code to account for every possible value in php, and then
we would have to see to it that those values were indifferent, so I mean fundamentally what this is is they all extend a core
class, which would have a value of "1", so umm...freaking...ummmm...so whether they had a value of 0 or 1 they would
fundamentally have a value of 1, so umm...now what does this mean in terms of code? So if everything has a value of 1,
everything works. So ok, lets say things have a primary value (of 1) and a secondary value of 1 or 0, so freaking ok, umm...
Ok dude...ummm........freaking I have no idea lol. Umm...ok so what is going on here is we have two things, so we have a fork,
just the question is how exactly do we use that fork? Umm...I mean thats basically what the question is...what is the question?
So ok if everything has a core of "1", effectively all of the input is (even strictly) indifferent, just ok is it? If it
doesn't literally have the value of "1", is it really indifferent? Umm...ok so if we nitpick we should be able to figure this
out, or ok being consistent, in cascading logic what is going on here? Freaking umm...ok lets say we have a massive amount of
numbers, how do we relate those numbers? So ok, we would go positive numbers would be true (1), negative numbers would be false
(0). So freaking ok, now how do we go one step further to reduce two to one? 1 or 0. So ok, what we do is...so ok, if "0" and
"1" have the same string length, we SHOULD be able to just jump from "0 || 1" to "1", because they are therefore
interchangeable. So freaking ok, umm...ok so in terms of string, if we remove the quotes, whatever we have is "what the string
is", so if there's nothing there, we have no string, if there's something there, we have some string. So we convert empty
string to 0, non-empty string to 1. So ok, what do we have here?:

"boolean"
"integer"
"double" (for historical reasons "double" is returned in case of a float, and not simply "float")
"string"
"array"
"object"
"resource"
"resource (closed)" as of PHP 7.2.0
"NULL"
"unknown type"

So what we're doing is converting everything to boolean then to integer:

<?php

$value = 1;
$convertedValue = (int) ((bool) $value);

?>

So ok:

boolean - true is 1, false is 0
integer - positive is 1, negative is 0
double - same as integer
string - empty string is 0, non-empty string is 1
array - 1, then count(array) then same as integer
object - 1, 

So freaking ok...consider the following syntax:

<?php

$array = [0, 1];
$array[0] = 1;

?>

So "$array" references something, no matter how small that something is, so this would be the primary means of evaluating an
array, so the array would be true, whether it was empty or not. The same thing goes for an object. We can always fix this in
the future. So ok I mean what is the point, though? So we convert everything to boolean, then what? Then we evaluate everything
in terms of boolean, so true or false, so umm...I mean what is the point? Without going up there's no point to doing this. I
mean there's a point, just that point is like infinitesmally small: things would be true or false, then they would be the
evaluation of that statement, therefore true. Then what? Ok so what we have to do is translate everything, EVERYthing, to "1".
Inside of PHP, this is what we must do if we want to get this done.

So ok, umm...ok so just to consolidate some stuff here, if we have positive and negative numbers, and those are true (1) and
false (0), respectively, we still have two values, which isn't one value. So what this means is we just go one more step (0 or
1) and we come up with a working system. So then ok, what we do is reverse flow, WITH our working system, so there is one
thing, then...freaking...damnit dude its freaking there, just how do we code it? Ok so if there was one thing, or indifference
(and so on and so forth), what we do is...basically we start building until we reach the point where we are repeating
ourselves, then we break it all down until we're not repeating ourselves anymore.

So ok, back to the ground, lets say we go back to our code-generator for Cinder (for generating plug-in's for WP/etc.). Now,
what we have is a system that makes multiple things out of one thing, so it makes multiple "plug-in's" out of a single thing,
so ok if we continue the pattern, all the way down, how do we generally make two things out of one thing? So freaking ok, umm,
ok dude just keep pushing through dude, we're going to make it. We are GOING to make it, we will FORCE our way through if we
have to. There's nothing to do but work on this dude, NOTHING, you don't have ANYthing, no one, nothing, to answer to, all you
have to do is work and get this done. There are two ways through: your work or brute force.

So ok dude, now lets say we even converted php to absolute types, what good does it do us? We still have to DO something with
THAT to get there. So freaking ok, umm...what do we DO? Freaking ok so ok, what we do is freaking come up with a generalized
system for dealing with stuff in PHP. So in general, what we would do with multiples is: we would, specifically, store them in
an array, then we would loop through that array and do stuff with each of the elements of the array, so freaking...umm...what
would we do here? Umm...freaking...we would freaking...do something.

Ok so what if we start coding with our system...

Ok! So, I went for a walk down to the pier and I thought: what we have here is a freaking system of more than one thing
(webpage), wherein each webpage can consist of "any" data. A webpage can be a collection of images, files, a simple text page
with some image collections, anything. It's one thing, some rich text, an image, a file, (potentially) over and over again. So
now then we have multiple websites, and those websites are made of these webpages. So ok, umm...now, a website is made of
multiple webpages, along with any other tom-kinkery that we, collectively, call a website. So ok, THEN we have multiple
businesses, and at that point we, like, obviously, have a recurring pattern where we have multiple things, and we (somewhat)
know what one of those is. So what we have is at LEAST one of these things, then a pattern.

So ok, what one of these is is:

a company (Cinder)
	web design
a website
	widgets, graphics, text, the whole lot.
a webpage
	any combination of some rich-text, images, other files, and other data, collectively called a webpage.

So freaking ok, now...at the point at which we can have ONE thing (so one company, one website, on webpage), we know that we
can succeed doing this. This is because one works. So ok, what we do is...figure out what a webpage is, inside and out, then
what a website is, then what a company is, then go ok, we can have one or more "elements" (array elements: purely because of
the potential of multiples we use an array), and from there on, what we have is at least a webpage, on a website, from a
company.

So freaking ok, what is a webpage?

A webpage is some html displaying one or more elements to a browser. So what that is is:

An "element" of an array in php
	this can be a value of any type
		For example, an image gallery would have an object at this point, because of the order of the image gallery
			categories would come first
			individual images would come after that...

Lets do this, lets mock up a webpage in pseudo, then break it down to types, then go from there.

So lets say we do the portfolio page of my Cinder website:

It would potentially have multiple clients
	each client would have:
		a name
		projects
			sometimes clients have more than one project
			each project would have:
				a description
				screenshots
					each screenshot would have:
						a thumbnail
						a full-sized image

So freaking ok, what we would do is...

clients (array)
	client (object)
		name (string)
		projects (array)
			project (object)
				name (string)
				description (string)
				screenshots (array)
					screenshot (object)
						thumbnail (object)
						full (object)

So ok, now, what we would do is...generally work with types (there are a finite amount of types: 9 or so in php), so generally
do stuff with each type. So ok, now this should work out just fine. So like what we would do is have like a master class that
would handle different types (to a point), so ok if I run this thing down:

Or rather, I mean, rather ideally, things should work as they are. So for each client we have a client class, and that class...
deals with properties of itself, so each client would have a projects array, so ok what if we burn it a little purer and the
thing is just one big ol' array? Then we go ok, we deal with each element by type, and...so ok, now what if we generalize what
a "project" is: lets say we make a project class, then we specifically deal with the individual project. What would it entail?
So umm in general we would have I/O for the name, description and screenshots of the project. So we have a means of inputting
information for each of these fields, so we would have a simple text field to edit "name", then a rich-text editor to edit
"description", then an "array editor" to edit the screenshots array. So the way this "array editor" would work would be to
iterate over the array and treat each element like we treated "name" and "description", there would be, thus, a file-uploader,
followed by an image cropper, to handle the images. So effectively what we have is an array, one big ol' array, which is what
we want.

Ok, so now if we make the main array include these arrays, we have one, huge array, where we take each element and send them
individually to an editor, which is the input of the thing, and the input occurs. And so on and so forth. So ok that reduces it
to a single array, then we just go ok, now how do we account for every single type of element in this array? Ok so this would
at least be extensible, so we don't even have to do it right, hah. So freaking ok, umm...what we freaking do is...something. We
most definitely do something. :) Ok so what we REALLY do, is, we go ok, so in general we have files and stuff...hmm...yea in
general what DO we have? String? So freaking ok, we would have...some text, some rich-text, some files, images, video, etc., so
freaking what does THIS mean? Umm...so this would be about where the shit would hit the fan, so I mean ok, what do we do at
THIS point? Ok, so we have multiple files, strings, etc., so what do we have? Well, we would have like a file format, so a
file-extension, then we would have...a filename, and like thats it, so thats what a file would be is a filename and an
extension, so like...ok so it could be some text (straight text, rich-text, numbers, "true"/"false", etc.)...:

text
	straight text
	rich-text
	numbers
		float
		decimal
	boolean
		"true"
		"false"

Ok so whatever it is, it has to be string-compatible: it's string and its files. Ok so furthermore the thing here is that this
thing can be anything, so I mean ANYTHING, so like ok, now, if we open a file in here and it has some string (don't be
surprised!) freaking umm...ok so in here, inside php, the contents of a file would be string (they are returned as string when
we fread a file handle). So freaking ok, everything you would have at this point would be string, which is consistent with our
previous data (all input is string). Freaking ok, fun shredding this stuff again.

So freak yea dude, so what you have is...:

php (string)
input (string)
data (array)
output (string)

Now, what if we make our data string? Like a CSV file or something? That would be bad dude. Freaking umm...ok umm...so freaking
umm...so our freaking data is freaking freaking freaking...freaking this is bad dude...umm...so we have some php, which is
string, and that string, when parsed, defines an input, which, when it reaches the server, is string, then...oh freaking kay
dude this should work. It appears to work.

Ok so how do you mix files and string? Like we would have input fields that would generate string...ok the thing about this is
you're going to have to deal with this stuff. It's not all going to be string, there's going to be image files, video files, so
I mean umm...hmm...I think we can dump this stuff in a database as string, and even onto a website as string, just...should we
do that? Well ok if it IS string, then it's all one consistent thing, then we just hammer it out from there. So it IS one
consistent thing, it IS string (it is fundamentally string), so what we do is keep tinkering along...

Ok so I would have the files and stuff themselves...ok so you wouldn't have to store everything as string, you would just have
to "treat" everything as string. So lets try this and see if we can get the two to line up, even though they're off, and see
what we get. So freaking ok, so we have...ok so what we would have is an interface for...so freaking ok dude, we could take the
contents of the file, as string, from a file handle, and hand them off, so this or that everything would fit nice and flush. So
freaking ok, umm...so we have a system that freaking works dude...freaking ok if you read the contents of a file as string,
then you output these contents somewhere, if that place is exactly fit to perfection, umm...it SHOULD be exactly fit. So I mean
this would work, so ok lets assume it works and go from there. So freaking ok, umm...freaking a dude, umm...freaking ummmm.....
ok so freaking what we would have is...we would have some string, and that string would be representable by an interface, so
umm...what we would do is...freaking ok, so it fits, so then what? So freaking ok, umm, data on a webpage would be at least
string, it would be string when it gets sent to the server, so umm...so freaking ok lets bump it up a notch, it would
POTENTIALLY be string, so from that point, if our files are string (which, by fread/fwrite, they are), everything is string!
Yay! Ok dude, so then freaking what you have is like a good view. So freaking ok, umm...what we do is...umm...try and smoke one
dude.

Oh freaking kay dude, umm...now what? Now do we build this bad boy or something or what? So ok, everything would be made of
string, so then I mean there's not really much left to do but code the thing. So ok what it would be is a simple array...I
guess what might be left to do is some of the layering: an array of data is rather fundamental, clients may want a little more
structure to the thing (restrictions on what kind of data can be uploaded/etc.). So freaking ok, we translate everything to
string...ok so everything would be string, so what we have is some code (an interpreter) interpreting the raw data (the array
elements themselves). So freaking ok, umm...what we would do is...ok yea so I mean if it IS all string, we're good. We just
freaking go ok, umm...ok what if you defined something with a number? Like you go ok, between 0 and 1, you define a number that
tells a program to program something? Freaking a...ok so a file would be at least string, because that's what php reads it as.
So freaking ok, umm...so what if we use the values of elements of an array to determine a number to drive an "interpreter"
along? So like we would define a number, which an interpreter would interpret to "extrapolate" the array (the value of each of
the arrays' elements)? Freaking umm...ok so if we have an array, we just use array functions to deal with the array:

<?php

$array = [
	"Hello world",
	[
		"Inside an array, inside an array",
		"One more for good measure"
	]
];
function input($indices, $input) {
	
	$referenceString = "$array[";
	foreach ($indices as $index) {
		
		$referenceString .= "$index][";
		
	}
	$referenceString .= "]";
	
	eval("$referenceString = $input;");
	
}
function output() {
	
	
	
}

?>

Ok so I mean like this thing would work, because there's no difference, so I mean...ok so is a two-way the way to do this? No,
it's not. A one-way is the way to do it. So freaking do it with a one-way. So ok, we would have like, we would have our array,
then we would have a function for reading/writing that array. So freaking ok, umm...hmm...yea how would this work dude? So like
do you even need to code this thing? Shouldn't it "be" somewhere? Umm...so like we see this all throughout nature, so freaking
ok, umm...so what do we do? We like go ok we find the sweet spot and like live there and stuff. So I mean is that what we want?
Or do we want something else? Umm...freaking...ok so what would be the point of using a two-way? Umm...there like isn't one:D
The only reason you would do that is if you wanted to change the order these things went in, thus you would need an input and
an output for each one, but ideally this doesn't make any sense: you would hard-wire the things into one. So freaking ok, umm,
lol watch it all stringify in a black hole. So freaking ok, umm...you got about 10 hours to kill...ok so lets say we code this
thing, that's not really what that is dude...what that is is where the thing (gracefully) goes all the way down and back up
again, so I mean we're not really striking our mark. So freaking what striking our mark would be is using a qi to do this, so
we have a qi in, and a qi out. So freaking ok, umm...the thing accepts a qi, so qi in, then it works, because it accepts a qi
and there is a qi in there, then qi out.

So freaking ok, umm...so you're absolutely sure that...freaking ok there's a qi in there, so there's indifference, then there's
you sitting here on your computer, then you put a qi in there, then there's THIS, which does not have a +1 for qi, then you
die, then there's a +1 for qi, then you're sitting there with a qi in there, and then it works. So in a line that's what's
happening...you have to be absolutely sure you're right though...so ok, there's THIS, me sitting here on my computer with a qi,
and then there's THAT, me sitting there dead with my qi, and it's going to work because being dead gives you a +1 for qi. So
does this work? Lets say there's one thing, indifference, then there's me and my qi, then I'm alive, then I'm dead. So ok, if
I'm alive, it doesn't appear to be working, but if I'm dead...so WITHIN indifference, IF we are dead then it works. So freaking
ok, thats what we're going to do, is we're going to use a qi to go up once we're dead. So freaking ok, now you're SURE this
works? You are absolutely sure this works? Umm...ok so if there's a +1 for qi and we use a qi, it therefore works. So if we
just focus on that we're good, because we're not dead, or even if we ARE, that's still what that is, so we just sit tight with
a qi. So that's what we're going to do.

Now, back to work. So we have an array of strings, and this array of strings is made out of string, so then we have some
string, and what that is is pure php code. So what we do is...ok so that's the core of it, now how does the breadth of it work?
So freaking ok, umm, freaking...so we freaking go ok, now what if we take in some input from the browser, what is THAT? So we
have some inputs, we would like ideally have a rich-text editor, and that is just about it. Not quite it, but JUST about. So
ok, what we would ultimately have is some string that was either rich-text or a file path, or something like that. The value
would either be rich-text or a file, so what we would have is like an encoded string, where we would have an escape to
differentiate files from rich-text. All string. So freaking ok, this works. Effectively what we would have is a file, so we
just put an intermediary step in there and go ok, either directly upload a file or create one with a rich-text editor. So
freaking ok, umm, yea that works, then what? 

So then we go ok, at this point we build the peripheral of this thing and...ok so at its core it would have a value of "1", so
other than that it would be some string, so freaking ok, umm, so how does it (whatever it is) go from whatever it is to "1"?
That is how we extrapolate, whatever that is. So freaking ok, umm, hmm...so I mean this is a trivial, surgical maneuver. We
just work our way down once, then build the thing from the ground up. So freaking ok, lets say we have some string, we have a
file, whose contents are string, so we have some files, so ok then we go umm...then we build a UI for all this stuff, and what
that is is...some string, just like everything else, and I mean that is pretty much it, just, what, in general, is that? What
is a UI? So a UI is a thing that displays our data, either for reading or writing. So freaking umm...so we would have I/O, we
would have output, the view output to a browser of the general public, then we would have input, the view output to the browser
of the administrative users. So freaking ok, the output would be...like basically both the input and the output would be the
output, just the input would have a few extra special features for like updating the information of the site and stuff like
that, so you know what would be cool is if you had it so the administrators directly update the information on the site on the
output. Freaking umm, ok yea that would be good. So ok, lets say every element, then, has I/O, so every element of our array
has I/O, and everything, all-throughout, has I/O. So freaking ok, umm...what we do is go...O, then I/O, so O, then I, just you
would need input to have anything to output, so you would have I/O, so freaking...umm...ok so lets go ok, lets say we have a
single html "element". Now, this element would have I/O, so freaking like what we have is:

Element
	Input
		Create
		Edit
		Delete
	Output
		Read

So freaking ok, like we could have a single webpage (for the website), that was both the input and the output: with priveleges,
the input would show, without, it wouldn't. This would make a lot of sense. It should be fairly easy to achieve as well: we
just come up with some core classes and voila, works. So freaking ok, umm...so now lets say we went ALL OUT, so like freaking
this thing is reading your mind and everything, how would this work? We would have some data, then we would break everything
down to a "1", then we would build everything up from that point, the same way that it went down. So freaking ok, I'ma smoke
one real quick.

Ok so freaking umm...how do we freaking do this? Freaking umm...so we have some string, so we potentially have some code (in
fact we have some php (code)), so ok we parse this code and that's it! So freaking ok, umm...hmm...now what do we freaking do
here? We go ok, I guess like we just start coding...so ok lets say we DID start coding, we would build the php that the site
would ride on, then we would build the site itself, so freaking ok, umm...so what if we build the Cinder site with this bad boy
to get it started and go from there? It gives us some ground to stand on.

Ok, so the Cinder site would consist of something like the following:

Cinder
	About
		One-shot rich-text webpage detailing Cinder as a company
	Portfolio
		clients
			client
				name
				description
				projects
					project
						name
						description
						screenshots
							screenshot
								thumb
								full
	Contact
		Simple contact form for contacting Cinder (requesting quotes, etc.)

So ok, what this would be is...some strings in an array, so freaking everything beyond that point should just flow naturally?
Umm...hmm...freaking a...so ok, "name" would be rich-text, "thumb"/"full" would be an image file. So freaking ok, umm...both
are effectively string...so I mean...umm...like freaking ok, so...we have a "file"...now what do these have in common,
unilaterally? Freaking umm...they are files so I mean...thats what that is. So freaking ok, now what do we do when we encounter
an image file versus a rich-text file? So we would have to program this behavior, so we would need something that detects
mime-types, then logically does stuff with that file based on that mime-type. So freaking ok, umm...so then we have a
mime-type, so when its the mime-type of an image, we display an image, and so on, so freaking ok, this too would be extensible,
so what we do is code these piece-meal, so umm...ok so thats what that is. We have a file, and we freaking treat it a certain
way. So freaking ok, now lets say we want to cut thumbnails for the Cinder website, should we have a way to do that on the site
or just count on the user manually doing it? Both. So freaking ok, we make an image-cropper, then we go ok, we indicate that we
need to cut thumbnails, so then, at some point, we have to define our array a little bit. So what we would do is go ok, so a
certain element would have this definition, and then the whole thing would reflect this. So freaking ok, umm...we would
freaking...like I guess we would lay this out in pseudo or something and hack away at it...ideally what we would have is a core
of code that we would expand upon, so we would have a core that would define our array, then we would expand upon that by
defining that we need thumbnails on our screenshots. So freaking ok, umm...what if we had some XML that defined the structure
of our array, then we create the array, then we I/O with our array? This, at least, makes sense. So freaking ok, umm...
freaking...umm...freaking umm umm umm...the thing is it would be the same thing over and over again, because it's all one
consistent thing, so freaking ok, yea dude...yea Brent, get some...so ok, every array element would be one thing, so one
"element" would have like filters on it, and thats what that is. So freaking ok, umm...so what THAT is is an element would have
one filter, because it would have one of them, and that filter would be some string (php code) that would define the structure
of that element. Then what we do is go ok, we define our array...dude this is freaking bad we could have a freaking interface
for doing that and freaking that is that. So freaking ok, umm...

Hmm...so freaking ok dude, umm...so you have some string, and that string is php code, and freaking its also some stored data,
and freaking...umm...like, umm...freaking...ok so we would have some files, or rather we would have some string, so ok we still
haven't like clarified...sometimes we have straight string, other times we have files. What do we do then? So the string would
go straight in, we know that much, because the whole thing is made of string. The files would go...in the filesystem, then we
would store a path to the file. So freaking ok, umm...huh...so freaking ok, what we would do here is...I mean that's what that
is, so what we do is...escape a file path, and otherwise just store the string. So freaking ok, umm...well escape one or the
other, so...both are string, but only one is a filepath, so the filepath would be what was escaped, so we just escape a
filepath and we're all good. If we're wrong we can always fix it.

So freaking ok, umm, hmm...

Hmm hmm hmm...freaking ok dude, uhh, like ok, so freaking we have a bunch of string, now how do we make sense of "a bunch of
string"? Freaking ok, there is definitely a pattern to it, a bunch of string is made of a bunch of string, hah, so now we just
trace the pattern to the top. So freaking ok, we have an array of strings, and that is it. So freaking ok, something like what
we would do is have "one big ol' string" and freaking have a php script that does everything. This would effectively make "one
big ol' string" out of everything.

So freaking ok, now more generalistically speaking, what is this thing? Ok so in general it would have I/O, for each array
element, so freaking umm...so there would be some input...is this the way to approach this? How would there be no difference?
Freaking umm, ok so there's no difference, then there's something like I/O for each of these array elements, so the output
would be displaying the information or just the output itself, and the input would be the CUD. So freaking ok, then we have:

array
	string
		O
			Read
		I
			Create
			Update
			Delete
	...

So freaking umm...and like that would be it! Then we have complete control over the array, and if we don't, we build it to
(also) be extensible so we can change it when we need to. So freaking ok, umm...so all told we would have:

array
	string
		create
		read
		update
		delete
	...

And thats it!

So ok then we can do anything with this array, create new elements, edit and delete existing elements, and read it. So freaking
ok, then what? Is that the maximus we seek?

By the way, you would make each element a file, to make the difference between files and string one thing. So roll with it
until further notice.

So freaking ok, umm...freaking ok so all of this is built in to php, so freaking ok dude, this is freaking BAD. Oh freaking kay
dude, now what?

So freaking ok, umm, freaking...umm...so like freaking ok, now lets say we wanted to build a HUGE structure on top of this
thing: so freaking ok, what would that be? Like lets say we wanted to style the output and everything, how would we do it? You
figure the best way to do it is purely in code, which is string, which fits (like everything does, since it's a unilateral
system). So freaking ok, what would we code? So like there would be...we would have the backend, so we would take the frontend
version of THAT...ok so you would need to differentiate between a priveleged view and not one, so like freaking ok, umm...like
ok you would need umm...freaking...ok so lets say you wanted to code one thing, priveleges, on top of this system. So what you
would do is...super-impose an image of this thing over the system, so we would have user levels and stuff, ...so ok lets say we
use this thing, so we go in, we put some stuff in there, then we view the website. So ok, lets say there just IS some stuff in
there (we hard-code it, for testing purposes), and we read that out to the browser. Now, how do we make a system where only
priveleged users can input? Everyone gets output, but only the priveleged get input? Umm...so you create two things, input and
output, and go ok everyone can output, but only the priveleged can input. So like this would be two classes (or sometihng like
that), so freaking ok...umm...the thing is everything needed to do this up to this point is hard-wired, so we "just code", both
when we do just that, and when we extend the functionality of this thing. So freaking ok, umm...in general, what do we have
here? We have something like I/O; a two-way system for doing stuff (when there's not just plain indifference). So freaking ok,
what you do is: either there's no difference, and freaking we code like that and everything, or there's a difference, and we
code like THAT and everything.

So freaking ok, umm, so you build a custom every time you build something. Now, what if we break THAT down and freaking code
THAT!? Freak yea dude, what would THAT be? 

So ok, generally, there would be no difference. Then, if we draw one, we differentiate between two things, and no more. So we
would use something like "Input" and "Output", so freaking ok, then we would have like priveleges on these things, then we
would have something like the actual mark-up of these things, then we would go...umm...so freaking ok, umm, we would like...
freaking...damn what WOULD that be anyways? As far as this is concerned it would be some PHP, then we would have two things,
0 and 1, then...or rather 0 OR 1, then we would freaking have...umm...so lets take the Cinder website for example:

Cinder
	About
		rich-text
	Portfolio
		clients
			name
			description
			projects
				name
				description
				screenshots
					thumbnail
					full
	Contact
		rich-text
		form
			name
			email
			message

So freaking ok, now what we would have is some PHP and that is it! Specifically, "index.php". So freaking ok, umm, we would
have to make extensive use of extensibility, and umm...I mean we would have to do that to fill-in, so thats good, then we go ok
we freaking have some php that:

somehow shoots off the website ("index.php")
stores everything as a series of files (strings) in an array (with built-in CRUD)
outputs the actual HTML of the site
...

Ok so freaking in general what would you be doing in php while you're doing this? We would be retrieving information from the
filesystem, based on input (GET/POST variables?), and outputting that information such that: specific array elements may have
customized output (certain webpages have certain elements, others don't), etc. So freaking ok, lets say we load, specifically,
the home page of the Cinder website:

Cinder ("index.php")
read GET/POST data to tell what to do
retrieve data
put header string on output string
style that data as a string of html, append to output string
put footer string on output string
output output string to browser

So in general thats what we would do on a website. Now, specifically, what is the maximum we could do with each of these steps?


Step #1 - "Cinder ("index.php")"
----
So ok, the Apache web server loads an "index.php" file by default, so that is why this is. So freaking what could happen at
this point is, well, anything. So freaking what we attempt to do is bottleneck this potential accurately, so I mean generally
what would happen at this point is it would load an "index.php" file from the root directory of the website. Freaking really,
though, anything could happen at this point. So freaking ok, we could like, umm...load a freaking...ok so we have an array of
strings, so at this point anything we can do with that within php works. So ok, umm...freaking...damn dude...this is bad...this
is badass...so ok I mean at this point, like, ideally, we would load an "index.php" file, but I mean if we don't have a web-
server or something like that, what then? Freaking umm, we would like,...ok I got a crazy idea: what if we make one class per
method and create a heirarchy of classes, and see what we get? Then what would we get?

Ok so in general what we're trying to do at this point is generalize the whole process of creating a website. So freaking ok,
what we DO know is we would have arrays of arrays and strings, so freaking ok, umm...so this is WITHIN php, so like ok,
freaking how do we do this...umm...like ok, so freaking what all can you do with arrays of arrays and strings? Umm...freaking
umm...huh...there's like no easy way to figure that out :) So ok, strictly speaking you would be doing one thing with this
array..."1"...so freaking ok, umm...ok so the thing is what if we wanted and ENTIRELY different system for doing stuff, so lets
say, for example, the OPPOSITE of what we have? Then the only thing the two have in common is "1". So freaking what we're doing
here is building something, something with form and structure larger than "1", so we're doing something non-fundamental. So
freaking ok, one must ask oneself, is there a way to successfully do that? Is there a way to extend "1" without losing
integrity? Umm...potentially there's a way to do that. So freaking ok, umm...all you need is an inkling of what that is and the
rest will follow.

Cinder
	Input
		Create
			Element
		Update
			Existing Element
		Delete
			Existing Element
	Output
		Read
			Existing Element

So we would have two things, elements and existing elements, or rahter, non-existing elements and existing elements. So
freaking ok, a non-existant element would be a 0, and an existing element would be a 1, so ultimately all of these would be "1"
because we would have to input each element before we read it. So freaking ok, umm...ok so what our model would look like would
be:

Cinder
	Input
		Non-existing element
			Create
		Existing element
			Update
			Delete
	Output
		Existing element
			Read

So freaking yea, thats what that is! Thats like a 2x2 and stuff dude, you can break it all down from there.

So freaking ok, umm, so then we scratch input/output (theres only one thing in either), and we get:

Cinder
	Input
		Non-existing element
			Create
		Existing element
			Update
			Delete
	Output
		Existing element
			Read

Or actually no we don't: there are two different things under input...so anyways...

From this point, freaking what we do is umm...we freaking...:

Cinder
	Priveleged user
		Input
			Non-existing element
				Create
			Existing element
				Update
				Delete
	Non-priveleged user
		Output
			Existing element
				Read

So ok what we have is recursion with two elements, so we would have Cinder, which would be the master array, then we have
priveleged/unpriveleged users, which are two things, then there is one thing, so there's two things but there's one thing, so
then we have one thing:

Cinder
	Priveleged user, Input
		Non-existing element
			Create
		Existing element
			Update
			Delete
	Non-priveleged user, Output
		Existing element
			Read

So freaking ok, umm...so when this thing forks it can never go back the other way, so...like what there are are either one
thing or two things. So freaking, umm...the only thing is that nested within these things are other things, so our layout would
(have to) look something like...ok freaking it would look about like what it already looks like, so we would have to mince up
some stuff to figure this out. So freaking then what do we do? One is 0, the other is 1...what if we extend our definition a
little bit:

Cinder
	Priveleged user
		Input
			Non-existing element
				Create
			Existing element
				Read
					Update
					Delete
	Non-priveleged user
		Output
			Existing element
				Read

Now if we micro-organize this: we would have to be able to "read" the data both whether we are inputting or outputting. So
freaking umm...ok first we would have Cinder, main array, then we would have read, to output the website (to both priveleged
and non-priveleged users, so including the UI for input), so like procedurally this is what we would have:

Cinder
Read
Non-priveleged user
Existing Element
Priveleged user
Update
Delete
Non-existing element
Create

So like ok basically what is happening here is we have an inter-dimensional thing going on: we read existing elements whether
we have priveleges or not and...either read existing elements or non-existing elements, so what we have is an inter-dimensional
element. So ok, what is THAT? Freaking umm...so like its a single line of code...a function invocation...umm...so freaking its
"one thing", which is? Some string. It's some string. So Cinder is some string (php code, to be exact), and that would fire off
the rest of the lines, if nothing else, so what that is is each line calls the next line, at least, so the process can short-
circuit at any point in time. So then what we would have is some string, so we have two things, some string and a call to the
next line. So freaking umm...ummmm...what we do is...what do we do? We like, freaking, do something, not sure what but we do
something! :)

So freaking ok, what we do at this point is...compare two of these things and figure out what they have in common? Yea that
makes sense! Ok dude, so lets take the first two lines, "Cinder" and "Read" and break em' down:

Cinder
	"index.php"
	"starts the whole process"
Read
	read GET/POST/other variables to figure out what to dish out to the client
		this is the point to otherwise deal with this sort of thing
	if reading input UI, put this in (first)
	then put in the standard UI

Now it strikes me that the thing about reading is that we might read a standard UI that has input, so THEN what do we do? Like
we could have read with or without the input...so we have:

Cinder
	...
Read
	IO
	O

So freaking umm...hmm...like freaking ok, we would...just keep expanding...what is the general pattern, though? We read line-
by-line and figure out whether we need to expand upon the current line within that line. So freaking ok, umm, what is THAT? :)
Ok so overall what do we THINK this thing needs to do? It needs to recursively read an array for strings and...then it needs to
parse those strings (those are assumed to be php). So freaking ok, umm...then like thats it, so freaking umm...now, how do you
maximize on the return of this? Umm...freaking...oh freaking kay dude, what we have here is a freaking conundrum: if you don't
finish this you have to do TONS of non-fundamental work, TONS of it, ALL of it, because there are two and not one. So freaking
ok, what you do is just keep rolling with the punches. So freaking ok, umm...

Cinder
	Priveleged user
		Input
			Non-existing element
				Create
			Existing element
				Read
					Update
					Delete
	Non-priveleged user
		Output
			Existing element
				Read

So freaking ok, what we COULD do is break the above down to little bits and pieces and see what we get. We'll get further along
by doing so, that is for sure. So ok, what we want is every tiny little bit accounted for, literally bits, as in 0's and 1's.
So freaking ok, if we start from the bottom and go up from there, there's no difference, then we have 0's and 1's, then we HAVE
what we want, something made of indifference and 0's and 1's. Now all we have to do is take the above and break it ALL the way
down to these 0's and 1's, and we're done! So ok, lets do this:

Cinder
Read
Non-priveleged user
Existing Element
Priveleged user
Update
Delete
Non-existing element
Create

Now, what is the total extent of what would happen in one giant heap of stuff?:

Cinder
	Read GET/POST variables
		Read
			Non-priveleged user
				Existing element
			Priveleged user
				Update
				Delete
				Non-existing element
					Create

So freaking in cascading logic, how would this go?

Cinder
	Read GET/POST variables
		Read -
			Priveleged user
				Non-existing element
					Create
				Update
				Delete
			Non-priveleged user
				Existing element

...

Cinder
Read GET/POST variables
Read user priveleges
Read
Priveleged user
Prepend (static HTML)
Dynamic data
Append (static HTML)

Ok so like first we would have Cinder, then we would do whatever we do that involves two things, so ok Cinder would be an
array, so that's potentially Cinder, so that's Cinder, so then what we do is...we draw up a little about what we do first, so
lets say first we would do input before we did output (to output the input), so then we would have input, so what we would have
to do to have input is read the user priveleges (to see if they even have the privelege of input) so freaking ok, umm, we read
user priveleges (GET/POST/SESSION?)...do we do anything BEFORE we do that? Ok so it wouldn't matter, but if it did, we would
read user priveleges BEFORE we do anything else (at least) just in case there is anything else dependent on that. So freaking
ok, umm, so again, we can change it at any point of time if we don't get it right, so ok, lets say Cinder fires up, then it
checks user priveleges, then freaking...umm...THEN it would read GET/POST variables, then it would start reading the website
itself, so freaking...freaking ok so what would happen in terms of one website?

The thing would start, then it would read...ok so basically then it would read GET/POST, then it would conditionally output
some HTML, and thats it. So freaking what it would do is:

Read GET/POST
loop and read conditional HTML

So freaking umm, what would happen is...:

Read GET/POST
Configure loop to read conditional HTML
Loop and read conditional HTML
Output

So freaking ok, umm...now thats basically what generally happens on a website, so what does this mean in terms of what we're
trying to figure out? It means that...we would freaking have...ok so now hammer it all out to exactly what happens when a
website loads:

(index.php)
Read GET/POST
	user priveleges
	create data
	update data
	delete data
	read data
On priveleges
prepend HTML
	for example: "<!DOCTYPE html><html><body>"
Loop and read conditional HTML/JS/etc.
	So what we want to do at this point is loop through PHP data and create accompanying HTML/JS with that data
	So we would loop through the data, then we would prepend some html on the data, then put the data itself, then append html
	So what we would end up with would be, for example:
		"<div>" . (the individual php data) . "</div>"
append HTML
	for example: "</body></html>"
Output this string to browser

So freaking I think that's it. So thats what that is when its a string. :)

So freaking ok, umm...again we can always change it if we need to or want to or whatever...so freaking ok, umm...freaking
umm...ok so if we have, at all, a working model of this thing, or view rather, we're good. Freaking go for the view dude, just
keep your ass focused on the view and keep plowing, you're totally getting it.

Ok dude, this is going to work bro. Just keep hammering on it. It's hard now, easy then. Always remember now.

So freaking ok dude, umm...what if we take a more direct approach at this and just try to hammer down on it and see if we get
it? Freaking ok, so we would have an array of strings and arrays/recursive and stuff, so freaking then what? Then...so like ok
if these strings are php you would have to somehow make sure that what they are doing is logical, so I mean...like freaking umm
you would have to like, do a ton of stuff? Or what? Fricking umm...you would have to like...do something...what is that though?
What exactly do you do here? Ok so, off the top, we have every possibility in the universe. Now, what we want is a sliver of
those possibilities: the pure core of those possibilities. So what this is is...how do we define a possibility? Or, what do two
possibilities have in common? Umm...freaking umm...so like ok, what we do is freaking...ok so if what we have above is what is
going on on any given website, start building websites? Lets try this out...ok so now for instance, when we deal with
priveleges (at the start of the process), freaking ok, so how do we deal with this? We need to know priveleges for: everything?
We would have to know whether the current user had priveleges for creating, reading, updating, and deleting data. So ok, if all
that was happening...:

read user priveleges - does user have priveleges to do the following where necessary
	create
	read
	update
	delete

Then, we would want priveleges to be completely extensible so that we could account for any kind of priveleging. So freaking
ok, umm...so like what we would have is a privelege creation system that created individual priveleges. This would probably
have to be code to specify ANY privelege. So freaking ok, umm...so lets say for example there is simply one privelege, and they
either have it or don't (0 or 1). So freaking ok, we check for the privelege, then we move on to...ok what is the cascading
logic of priveleges? If they have them, they can do whatever they permit, if they don't, they can't. So these priveleges would
all stem from a main privelege, something like the "read" privelege, so freaking...umm, so then there would be another one,
stemming from this privelege, which would be...fundamentally it would be a "write" privelege, so read would be 0 and write
would be 1, so then we would count up, and the next privelege would be "write, read", and the next one after that would be
"write, write", and so on. So freaking ok, what this would mean is that the priveleges would have to be made out of two
rather fundamental things. So ok ultimately what this would mean is that there would be stacking of priveleges, so we would
have read, then read + write (0 + 1), then read + write + read, and so on and so forth, so what we would do is...lets say we
had several "layers" of priveleges, like...several levels of user priveleges...so freaking ok, lets say we had create, read,
update, and delete priveleges. They would be represented by the following:

0
1
10
11

So freaking ok, what's happening here is the priveleges are stacking...umm...ok so how would the CRUD line up? First we would
be able to read, so any ol' user could use (view) the site:

0 - read

Then, what would happen would be that we would follow the logical order of things in general: first we have to have content to
edit/delete, so:

1 - create

Then we would have edit:

10 - update

Then we would have delete

11 - delete

So freaking ok, altogether we have:

0 - read
1 - create
10 - update
11 - delete

So freaking ok, fundamentally what we have is "read", "read + write", "read + write + read", and "read + write + read + write".
Whatever that means. :) So freaking ok, umm...so freaking what this is is...ok so now we have a general idea of what we're
going for, freaking I'm out for the night! Peace mothafucka! :)

Ok, back again. So freaking ok, what we would have is "read", "read read", "read read read", and "read read read read",
fundamentally. So freaking ok, umm, like, freaking...ok so what I was thinking is that we have:

Read
Edit
Add
Delete

Or "READ" (in acronym). So freaking ok, things SHOULD line up like this, right? Umm...ok so first of all, we need to be able
to read. We have to be able to read to read the UI for adding/editing/deleting. So "Read" comes first, at least. Then, umm...
we would edit existing data? Then we would have, at least, existing data. Yea we would READ. Makes quick n' dirty sense. So
freaking ok, then what? Ok so we "Read" the website, so freaking we read the "frontend" of the website, proper: the frontend as
seen by any user. So what this would look like is:

(index.php)
Read
	0
	1
		SESSION
			User Priveleges
				Edit
				Add
				Delete
		GET
		POST
...

So ok like what would be going on here is we would be razor-blading stuff off the freaking screen: we would read everything
first (we have to read user priveleges before we do anything, so freaking umm...this is at least what we would do, because we
have to read whether the user has read priveleges before we output anything. ANYTHING. If they don't have the priveleges
NOTHING is output the view. Not a single character of string.), so like we would read user priveleges for reading, so we would
have a...ok so what would happen is the user would either have the privelege to read the "index.php" file or not, so that's one
thing, then once they're inside that file (which is more what we are talking about, since we're INSIDE php)...ok so starting
from, at least, inside "index.php", the user would either have the privelege of reading the file or not, so if they don't, we
don't change anything, so no output to the browser (at least). So what we do is...freaking ok, so we have to start "reading"
data, we have to...read user priveleges to see if they can even view the page or anything, so...note that what we have,
"index.php", is a "webpage". So ok, we read user priveleges...so we need a privelege to "read" the user priveleges, which is
PHP's read privelege (whether we're reading data from a database or a file or something)...so we would have the privelege of,
we assume the privelege, of reading...ok we don't exactly assume, just SOMEHOW we have the privelege of reading the webpage, so
freaking ok, umm...so we are operating within php, so within php: ok so we read the file, then we read the priveleges of the
user: they can read, edit, add, and delete, or not. So freaking ok, umm...so we "read" the "index.php" file, then we're in.
Then we "read" the user priveleges, so operating purely within php, we read the user priveleges. Therefore we would load
mariadb credentials/session variables...:

index.php
	read
		SESSION
			Users
				ID
					1
				Username
					Cinder
		MariaDB
			SELECT FROM `users_table` WHERE `Username` = '%username%' AND `Password` = MD5('%password%'))
				SESSION
					ID
						...
					Username
						...
		etc.
			(at least) Authenticate user with
				Unique
					ID
					Username
				Password

If no session, confirm user with every page request: break down in cascading logic, so fall-back on GET variables. User must
then supply Username and Password with every page request via GET variables "Username" and "Password". So freaking ok, umm...if
we don't have GET variables, ok so this is at least what we would have. Moving on...:

index.php
	read
		Authenticate user
			SESSION
				Users
					ID
						1
					Username
						Cinder
			MariaDB
				SELECT FROM `users_table` WHERE `Username` = '%username%' AND `Password` = MD5('%password%'))
					SESSION
						ID
							...
						Username
							...
			etc.
				(at least) Authenticate user with
					Unique
						ID
						Username
					Password
			default "read" privelege
		commit any edit, add, and delete actions into DB
			custom error handler on failure/warning/notice/etc.
		read data for output (read multiples from sources)
			html
				prepend
				loop through data
					prepend
					data
					append
				append
		output

So like ok what we would have is a single thing, that we could have multiples of, that would be:

Single
	data
		from source
			MariaDB
			File
			etc.
	read
	edit
	add
	delete

...umm...ok so we would have the read privelege, we're inside php, so then we would need something like mariadb credentials,
then we would load data from mariadb, then we would output to the browser. So from this point on, we have our data, so then
what we do is simply format that data for output and output it. So freaking ok, that is what will happen on every single
website that ever exists. So freaking ok, umm...so what we do is "read" database credentials, so here you might want to try and
bottleneck "read" priveleges of the db, so freaking...ok now potentially we're reading from either a database or a file, so we
have a fork. So what we're reading is string...

Ok so we read the index.php file, then within that file we do everything: we (preferably) have the database credentials...ok
this wouldn't matter because we have to access the database, which is seperate from php. So freaking ok, what we have is a
point where we need exterior information, constantly, so we have the current working php file, "index.php", then we have
"exterior data": data from mariadb or other files, etc. So freaking ok, umm...thats what that is...so we have:

index.php
	interior data
		data (variables/etc.) within index.php
	exterior data
		data from
			mariadb
			other files
			etc. (information outside of index.php)

So freaking ok, umm...so we read this data with our read privelege, then freaking...umm...so ok if I break this up into chunks:

index.php
authenticate
based on priveleges:
read data

So freaking thats one thing. Thats "one" thing. So ok, then from there we know what one of these (at least) is. So freaking ok,
what we do is...get extravagant with what we have. So:

index.php
	authenticate
		interior
			SESSION
				user already authenticated
					ID
					Username
			GET
				authenticate user
					Username
					Password
				upon authentication, "set" SESSION variables
					if SESSION is available, use some other PHP variables
						a "master class" would work well for this
							this is, by no means, necessary though. So lets say, because it's one step closer to what we want,
								we just use something like "$ID" and "$Username"
			POST
				same as GET
		exterior
			mariadb
			files
			etc.

So ok like we would do "input" before "output" because we would need to input any new data coming in before we create the
output, so all the data is up-to-date.

So freaking ok, we would like...umm...so what is the point at which we would have string? So ok the code would be string, but
beyond that...so freaking we would have a user ID and Name, which would be string, so then we have code that deals with those
which is string, so umm...so then we can dynamically write this string...so then like umm...ok so like at least what we would
do is use a binary permission number that would start off at 0 and go up to 11, from read to delete. So freaking ok, umm...now,
hmm...ok so we have index.php, then we authenticate, wherein we check SESSION, GET, and POST to see whether the client is a
user or not. Now, if they're not, they still have the read privelege, so they can still view the site. We thus sort of
bottleneck the site in terms of extra-priveleged users (edit, add, and delete priveleges): if they don't have any extra
priveleges, the site will load just fine...but the thing is we have to load our data still, either from within index.php or
from an external source, so...:

index.php
	read
		inside
			php variables/etc. set within index.php
				SESSION
				GET
				POST
				etc.
		outside
			data from
				mariadb
				other files
				etc. (outside of index.php)

So freaking umm...ok so we would write when we read, so that we read the index.php file, then write any new data to the
database, then read the (updated) data from the source. So freaking umm...hmm...freaking nitpickery...so we freaking:

index.php
	output
		input
			output

So what that is is we load index.php, then we output, then we input (add new data etc.), then we output to the browser. So
freaking ok, this is highly alternative...so we would alternate, output, input, output, input, or the other way around (doesn't
really matter), so what we would do is...:

index.php
	output
		SESSION data
			user authenticated?
				if so:
					input
						add
						edit
						delete
					output
						to browser
	input
		authenticate user with GET/POST/etc. data
			if authenticated:
				input
					add
					edit
					delete
				output
					to browser

So ok the thing is the session data would be input, constantly, as would the get and post data. So freaking ok, umm...:

index.php
	input
		SESSION/GET/POST/etc.
			authenticate
				edit
				add
				delete
	output
		to browser

So freaking that's basically what would happen on a website, in terms of a two-way current (I/O (1/0)). So freaking ok, umm...
so WITHIN php, what is available in terms of input? GET and POST. Thats it. So freaking ok, umm...hmm...so we would have input,
which would be either get or post, then we would have output, which would be string to the browser. So freaking ok, umm...
Freaking umm...so ok I was thinking, and what we would have is priveleges such that: there would be 16 different permissions
for READ. So freaking ok, umm, what these would be is:

0 - no priveleges
1 - delete privelege
10 - edit privelege
11 - edit and delete priveleges
100 - add privelege
101 - add and delete priveleges
110 - add and edit priveleges
111 - add, edit, and delete priveleges
1000 - read privelege
1001 - read and delete priveleges
1010 - read and edit priveleges
1011 - read, edit and delete priveleges
1100 - read and add priveleges
1101 - read, add and delete priveleges
1110 - read, edit and add priveleges
1111 - read, edit, add and delete priveleges

So freaking ok, these stack up logically and everything, so freaking...if THIS happens logically, everything after it does. So
freaking umm, freaking...so ok what is happening is these are alternating a certain way, so THAT will tell us what to do. It
should, because it's unique and its linear. Umm...yea why is that? :) Umm ok so its a logical pattern, so I mean...so freaking
umm, like what we do is trace the privelege binary and go ok, so we...freaking...read...the...ok so what we do is we do
everything in the order listed, so first we don't do anything, then we delete, then we edit, and so on and so forth. So
freaking umm...so ok if we have a 4 bit sequence, we do whatever the binary SAYS to, so freaking umm...we...:

4 bit binary sequence
	first bit is:
		0
			don't read
		1
			read
	second bit is:
		0
			don't edit
		1
			edit
	third bit is:
		0
			don't add
		1
			add
	fourth bit is:
		0
			don't delete
		1
			delete

So freaking ok if we had two bits, lets say read and write:

0 - neither
1 - write
10 - read
11 - read and write

Umm ok, what that means is...freaking...like we start from the right and work our way to the left...because when we count we
count "1, 2, 3...", so freaking what that means is...ok so there are two things going on here, lol, freaking umm...so ok for
our purposes we would be better off with a two-way sequence (for priveleges), so freaking ok, umm...what we do is...fricking
thing dude hah, so ok, sequentially, one by one, how does this work? We start from the right, then we go off, on, and so on, so
umm...what we would have is freaking umm...ok so you have a left-zero-padded binary that indicates read/write right to left
(logically; we would logically write before we would read - if we read and there is nothing written...?), so what we have at
this point is:

00 - neither
01 - write
10 - read
11 - read and write

So ok, umm...or:

read	write
0		0
0		1
1		0
1		1

So freaking ok, umm...so thats tabular data, which is rigid, so umm...so ok an easy way to figure this out would be tabular
data: if we lay everything out on a table, we can clearly see what is logically happening, left to right. So what I'm getting
at is if we have any two columns, their rows are directly representative of them, logically. So umm...like what I mean by this
is that we have columns, then every row is consistently showing what is happening with data: as the binary ascends, so does the
row number. So like things should be lining up in certain ways, therefore. So like, umm...freaking umm...freaking...so ok, why
would we have read after write? Why not read AND write? Or vice-versa? Freaking umm...because thats the next logical step? 10?
Why not 11, though? We've already established the pattern of binary, so that is, at least, why. So freaking ok, umm...freaking
a dude, why is that? Freaking umm...ok so what we do is we alternate the first bit because thats what we did with the second
bit, and then we do the second bit all over again. Freaking umm...so freaking...freaking...umm...freaking a...so lets say we
have:

Output	Input
0		0
0		1
1		0
1		1

So freaking ok, umm...so we run every value of output against that of input...what if we just have two? 0 and 1? Where are we
at as far as that is concerned at this point? Freaking umm...hmm...so 0 would be output, 1 would be input, so we input before
we output, so "10", which is 2, and...what?

Ok, so if we have a 4-bit binary represented our priveleges, if we alternate one of the bits, we add or subtract so much from
the existing binary. The key to what you seek lies in that logic.

So lets say I take 1111, and I alternate the edit privelege: I subtract 4. Now lets say I take 1111, and I alternate the add
privelege: I subtract 2. So freaking ok, umm...so the pattern is like patternless...umm freaking ok, so ok, when I freaking
alternate a privelege I freaking...subtract so much and the privelege alternates, so ok it's not like I just add or subtract 1
at any given point in time to do this: I have to add or subtract a certain amount...so ok I would determine this by...ok so I
would always add or subtract the same amount to alternate a given privelege, so thats good...umm...freaking ok, ummm...

So off the top, we have a recursive array of arrays and strings that we're executing (its php code) and that is what is driving
the thing along. So ok, umm...so freaking...umm...ok so like systematically how do we do this? We go off the top, to the
bigger (biggest) thing and take it from there. So ok, what we have is...in terms of up, what this is is...we have to go off the
top and find our way (all the way) down. So freaking ok, off the top: we have our system, then it goes down to 0, then we
compare 0 and 1 and get 1. So freaking ok, umm...so it goes down then goes back up? If it went down it would then go back up.
It has to be up. Do we know this? Yes, as a matter of fact, we know this. So ok, umm...so freaking ok, the reason we have read
and then write...we don't have read then write? We have write and then read. So freaking ok, umm...ok so like fundamentally
what we have is a single privelege, either on or off (1 or 0). So freaking ok, before we move on to defining other priveleges,
we have to define like everything else...or something...so freaking what we would have is a bunch of freaking string, so what
we do is we load this string, first in first out, and freaking thats what that is...so by "load" I mean "parse with PHP". So
freaking umm...ok what if we (attempt to) build this thing from the ground up? We go ok, we turn out ONE website, Cinder, and
freaking do the good deed. We freaking build everything, then figure out how we can break it all down to completely small
little bits and pieces? So how would we do this:

Cinder
	Priveleges
		Read
		Write
	About
	Portfolio
	Contact

Ok what about this real quick: if you have to write before you read, then that changes our priveleges layout:

Write	Read
0		0
0		1
1		0
1		1

So first we can't write or read, then we can read, then we can write, then we can write and read...ok yea that makes sense
because it yields read privelege...does that make sense? We have to write...ok we have to figure this out before we progress
past this point, lol. :) So freaking ok, umm...if you don't write, do you have anything to read? Umm...can you write without
reading? That's something you have to figure out. In a vacuum, you wouldn't be able to read before you wrote. You have to write
(code) to read. You have to read...ok what if you had a scenario where you had an input text field where a valid filename was
expected, and that filename was sent to the server, and then the file was opened (for reading). You would have to have the
input before you had the output. So freaking lets...huh thats a good question...which is it? So within php, do we have to read
before we write, or write before we read? Lets say we use one file, and that file doesn't exist, and we don't write to that
file, and we read it. This wouldn't work because the file wouldn't yet exist. So that would be a 0. We would have to write to
the file, and then we could read it, and that would be a 1. So we write first, then read. I/O, not O/I. If we're not right we
can always fix it. Plus, if you used a simple scenario with a website with write logic, you would write before you read, at
least so your data was up-to-date when you read it. So:

Write	Read
0		0
0		1
1		0
1		1

So freaking ok, umm...so this correctly lines up our data, left to right, and from there we should be able to make some sense
of what is going on here. Freaking umm...hmm...ok so we would start off with read priveleges, which makes sense, because then
we don't, like, "skip over" write priveleges to get to read priveleges, which would not be good! Freak yea dude...freaking get
some. So freaking ok, umm...so there's like nothing to do but plow this thing. Freaking ok, umm...

Freaking a dude...ok so the problem is I have no real idea what to do to get this thing down, so...umm...I figure like, umm...
I'm thinking maybe I build my website and work it down like that, just I really don't know if that will do it or...I need to
get stuff done while I'm doing this, is why I figure maybe that's a good way to go with this thing. Freaking umm, hmm...so like
the thing is we have a bonified 1 and 0, we just have to USE them. So like ok, I figure like everything is fundamentally made
out of these things, so we SHOULD like be able to just press it down until the juice comes out of it, just it's like juicing
orange juice out of cinderblocks. Hah. :) Freaking ok, umm, so if I WERE to do this:

Cinder
	root/index.php
		read GET/POST
			log in user, if any
				on success commit any...(1, see below)
				otherwise, load read-only page
		check priveleges
			anon or user(?)
				anon
					load read-only site
				user
					load site with admin controls
						edit
						add
						delete
		load GET/POST variables



(index.php)
Read GET/POST
	user priveleges
	create data
	update data
	delete data
	read data
On priveleges
prepend HTML
	for example: "<!DOCTYPE html><html><body>"
Loop and read conditional HTML/JS/etc.
	So what we want to do at this point is loop through PHP data and create accompanying HTML/JS with that data
	So we would loop through the data, then we would prepend some html on the data, then put the data itself, then append html
	So what we would end up with would be, for example:
		"<div>" . (the individual php data) . "</div>"
append HTML
	for example: "</body></html>"
Output this string to browser


So ok, now the thing is, what exactly do we do when we log in a user, with credentials from GET/POST?


index.php
	attempt to log in user with credentials from GET/POST
		check given credentials against a database or other record of valid user credentials
			requires comparison operators and all associated stuff
				...
			requires database/file/etc. for storing valid user credentials
				database connector
				file handler
				etc.

So freaking ok, in order to "do" anything we need the required stuff, so aside from an empty php file, what we would have is:
the operation we wish to do and the requirements for doing so. So ok, umm...ok so what we're trying to achieve is AT LEAST akin
to figuring out how to process a logical procession without something like the "if" construct. So freaking umm...ok so one way
we could do that, at least kinda, is to loop once on true and do something, so do whatever the code is that is associated with
the success of an if statement:

<?php

//initialization
function doFunc() {
	// do something
}

// how we would write this with a simple "if" statement
if ($logical_operators)
	doFunc();

// how we could write this without a simple "if" statement
for ($i = (int)(bool)$logical_operators; $i > 0; $i--) {
	doFunc();
}

?>

So freaking ok, umm...huh...so ok, with no "if" statement, there's no way to shoot off a function that would happen if the
condition were false, which is fine because we still have one (the function that shoots off if the condition is true), so
freaking ok, umm...now can we distill our solution even more? What if we reduce it to a simple assignment? We're like not
meeting the criteria of the problem: we have to shoot off a function based on whether something is true or not. So freaking ok,
umm...what if we regularly express against a ternary operator?:

<?php

true ? true : false;

$regexp = "/.*?.*:.*/";

?>

Ok the thing is, the code that fires if the condition of the ternary operator is true is string. We can interpret this string
as true or false (1 or 0). So freaking ok, this reduces our search to one of two things (1 or 0; whether the condition of the
ternary operator is true or not), then one of two things again (whether the true statement of the ternary operator is true or
not), then one of two things one more time (whether the false statement of the ternary operator is true or not). So ok shortly
this reduces our search to the condition of the ternary operator. That would determine whether the true or false statement of
the ternary operator fires, so I mean...ok so lets say we want the true statement of the ternary operator to fire, so we reduce
our search to that, and then what is that? That returns a value, whatever the value of the statement is, so if we regularly
express what that statement is we SHOULD come up with something useful:

<?php

$regex = "/\(?.*\)?/";

?>

Oh freaking kay, so lets say we had a regular expression of something, anything, so like..."an":

<?php

$regex = "/an/";

?>

So freaking ok, umm...matches. Now, what does that MEAN? What this means is that we can reduce all regular expression to...
umm...freaking umm...so ok what this means is all regular expression comes to a point, so what that point is is...something
like the "." operator, because that would match any character. So freaking ok, umm...:

<?php

$regex = "/an/";
$haystack = "A an another an.";
$matches = [];

preg_match($regex, $haystack, $matches);

echo "<pre>";
print_r($matches);
echo "</pre>";

?>

output:
Array
(
    [0] => an
)

So freaking ok, umm...so when we're regularly expressing, or specifically when we're using preg_match, we match the thing
itself, so "an", so freaking...so we match the first "an", and thats it. So freaking ok, umm...so freaking consider: what if we
match any 1 or 0 in any string? Lets say that string has both...? So ok, umm...what we are searching for is a 0 or a 1. So
freaking ok, umm...so we search some string for a 0 or a 1 and...thats it? Freaking umm...

So like ok what we do is freaking...umm...hmm...so ok what we're doing is trying to search through some code for one of two
things (true/false, 0/1, etc.). So freaking ok, umm...lets say we're searching through code for two things...ok so what we're
doing, specifically, is searching through the condition of a ternary operator with regular expression to come up with
SOMETHING...so specifically something that is true, or 1, and not false, or 0. So freaking ok, umm...what we do is...we
freaking...so we figure what we want is "1", because we know that from past experience, so freaking ok, umm...what do we
achieve by doing this? So we figure if we can pin-point a 1, as opposed to a 0, we can find all the "holes" in our code that we
need to fill in to make this thing work. So, freaking, umm...so ok we define whether something is 1 or 0 with code, so we're
searching through code to find these values. So freaking ok, umm...so we're searching through string with regular expression
because thats what we have, is string. So we freaking search through this string (code), and...

So where we're at is the point at which we have two things: true or false (1 or 0). So freaking ok, umm...what we do is...ok so
one line of code is less than two, which is 1 (and not 0), which is what we want. So freaking ok, umm...so if we reduce this to
a single line of code, we have to account for what this single line of code IS. So we have to regularly express through it to
figure this out. So umm...ok the thing is you have nothing at this point, in terms of code, actual functioning php code, so if
you reduce it to a single line you're WAY better off than if you go shooting off at some cockameemeed angle. So freaking ok,
umm...so even if you regularly express a line of php code, this will probably be subjective, and even if it IS objective, where
does that get us? Ok so the regular expression for all php...ok so the regular expression for all php is, at least, "/.*/". So
freaking ok, umm...now what? What if we have an empty php file? Then the regular expression...then it's not a regular
expression: regular expression is a two-way deal. Ok, umm...so freaking umm, so freaking umm dude...lots of umm...

So ok, I figure it's not a good idea to use a two-way circuit to figure this out: we have to figure out what is true AND what
is false, then we have to seperate what is true AND what is false to get down to what is true, instead of just going for the
whole banana all at once. So freaking ok, umm...

Ok, so, when we load a php file we have to "read" the file before we do any "writing". What I mean by this is we have to READ
the php itself before any writing occurs: we have to parse the php file up until the point that any writing occurs. At least.
So I still don't know whether read or write comes first, but that is something to consider. So consider:

<?php

$fh = fopen("somefile.txt", "w");
...

?>

Before we assign $fh, we can't write, so we have to "read" the php up until the "w" to write. On the same note we have to
"write" the php before we "write" to "somefile.txt", by reading the php and then writing to "somefile.txt". So umm, we have to
"read" our "writing" to "write" to "somefile.txt" in the above example. So when we're running a php script we're "reading", so
does that not mean read comes before write? Does that not mean read, read OR write? If we never wrote the above script
"somefile.txt" would never be written to. Therefore no writing would necessarily occur. Pardon me, if we never READ the above
script "somefile.txt" would never be written to. So it's read before write. Therefore READ (Read, Edit, Add, Delete).

Ok, so read (O (0)) before write (I (1)). Well ok the thing is, this doesn't make sense. We have to write before we read,
because we don't necessarily have anything to read! So write before read. This is at least what this is, and if it makes sense
now, it makes sense then. So write before read.

Ok.

Freaking umm...no idea why that is what that is, but 1 comes before 0. So we just charge it, and we get there. So freaking ok,
what we do is...just start coding? I mean this makes sense, we just go for it and it all happens. It all HAPPENS.

So freaking ok, when we write, what do we do, and when we read, what do we do? So ok, when we write, we either edit, add, or
delete data. So this could be editing, adding, or deleting files, mariadb rows, or for that matter, anything. So ok, how do we
approach this? We have an "interface" between index.php and something like mariadb, or the filesystem, that handles all of the
"writing" of the data. So what this would do is abstract some basic stuff: edit, add, and delete. So what we would do is
something like have a layer of php functions ("edit", "add", and "delete") that would "interface" with mariadb/the
filesystem/etc. So freaking what we would have so far then is:

index.php
	write
		interface with mariadb/filesystem/etc.
			edit
			add
			delete

So ok, as you can see there's nothing to it. The rest of it is all grunt work: you'd have to custom design the interfacing, but
then thats it! After that it would all be automated. So lets design our Cinder website, for example:

Cinder (index.php)
	write
		interface with mariadb
			edit
			add
			delete
	read
		About
		Portfolio
		Contact

...so freaking ok, this might be easier to just type, so freaking ok, what we would do is create an interface between index.php
and mariadb/the filesystem/etc. that would, at least, automatically create all of the tables in the database, so you would need
a way to specify the table structure of the database/etc. Also, what if you decide to use the filesystem, instead? Then you
have to...why not just hand-code these things? It's like faster to do so. Or what? Huh...I mean ok even if you nitpick the
thing apart to the point of total automation, it'll take longer to do that than to do something like use a qi...this is already
taking a lot of time. It's taking a long time to get from point a to point b. What if we have to completely redo this thing?
What will we do if we have to start all over again? Ok so by the time I've typed this too much time has gone by, I could have
been attacked. So freaking what that is is...freaking ok...any amount of thought, anything, is too much. So freaking what that
is, at least, is whatever is the result of that cascading logic.

So freaking ok, today I'm going to like build this thing. So freaking ok, what we have is:

Cinder (index.php)
...

Or should this be index.html? Is there a way to serve up several html documents with a single html document, WITHOUT js? No,
there isn't. So we short-circuit to index.php, at least this time, and in general it's a good idea because it puts everything
in a single place:

index.php
	webpage
		accessed with GET variables
	webpage
		...

As opposed to:

index.html
	webpage
		accessed with links
	webpage
		...

Also the data is...ok so just make everything come to a point and your good, both ways.

So ok, where were we:

Cinder ("index.php")
	write
		read
			Home
				rich-text (?)
			Portfolio
				clients
					client
						name
						description
						projects
							project
								name
								description
								screenshots
									screenshot
										thumb
										full
			Contact
				static webpage (text) (?)

So freaking ok, umm, thats pretty much it. Now, what you CAN do is generalize everything UP TO A POINT. Beyond that point
you'll have to specify everything, but at least up to that point everything WILL BE DONE. So freaking ok, umm...so everything
is string, it's all one consistent thing, the sky is the limit, smoke one dude.

So freaking ok, umm...ok, so what we have is a recursive array of strings, so freaking umm...umm ok, so what we have is...
freaking an index.php file, then we write, then we read, ok umm...I'm just reading the damn thing. So ok what we do is...well
ok this makes so much sense, so lets run through the list and pseudo-code everything:

Cinder ("index.php")
	write
		create tables and stuff
			mock-up tables...or should we use the filesystem? The filesystem is more consistent...ok what if we code this thing
				and see what we get?
				...

Ok lets start coding. Ok so we have an all-string "interface", so...ok what we do is...code a thing that codes a thing? Then we
code write/read (I/O (1/0)), and like thats it? So freaking am I wasting my time and should I just be coding or what? It would
be WAY better if we had this stuff all clearly laid out. Freaking umm...so interesting dude...so all throughout we would have
a recursive array of strings...so...ok so what we would HAVE is:

array
	array
		Cinder
			index.php
				write
					read
						Home
							rich-text
						Portfolio
							clients
								...
						Contact
							static html (text)
	string
	...

So freaking umm...so at least what one of these string elements is is php. So we parse them with php. So freaking ok, umm...wow
this is like going to be way more involved than I thought. So freaking ok, we have to shoot off a whole array...so freaking ok,
umm...we "shoot off the folder", so we go to a folder on a website and it goes to the "index.php" page (hopefully), then...ok
what if it DOESN'T do that? We have to somehow point to something like the "index.php" file. So from that point on it's up to
the client. Or is it? Within php that's what that is. So freaking ok, umm...then, at least, what that file does is...:

client points browser to website
website loads webpage ("index.php")
index.php
	writes
	reads
...

So ok, generally what would happen on the Cinder website is:

Cinder ("index.php")
	write
		read
			Home
				rich-text
			Portfolio
				clients
					...
			Contact
				static html (text)

So the index.php file would load, then it would...then from there we would have to load any other php files and stuff like that
to do it's thing, so like ok, lets say from there we wanted to go to the portfolio page: so ok, umm...we would like load the
portfolio page from within the index page, so freaking umm...ok so like lets say we load the index.php file, because we know
for sure we do this, so we load it, and it loads the home page of the site. So what it does is...loads the page externally from
within the index file. So the index file is the master file of the website.

So ok what we would do when we loaded the home page is...we would like include the "home.php" file into the index.php file
and...then we would load the home page into the index page...so freaking umm, like we would have a header in the index.php...
huh yea how would we do that? So ok the maximum of this would be we load another php file into the index.php file, because we
can, and because that's as big as it gets. At least. So freaking ok, umm...so we're in php, in index.php, then we...umm...so we
load index.php, then from there we load everything else, so like "home.php", "portfolio.php", any text files, etc. So ok,
umm...like ok we would...so like in cascading logic we would: load index.php, then we would load something that says what we
would load next, so for this example it would be "Home", so what we would do is...load an ordered list of...so we would read
the arrays, and not the strings, of the array (the main array), then we would load the index.php files of those, so what we
would do is...what our array would look like at this point is:

index.php
0 (Home)
1 (Portfolio)
2 (Contact)

And what we would do is...so we load index.php to get inside of php, so now we're still inside of php, so then umm...then we
would load the first folder it finds, and we would do that by loading the index.php file from that folder, then from that
index.php file we would otherwise redirect to the main folder (NOT the index.php file, just in case we have something like an
"index.html" file; we're riding on apache!), so ok what we would do is...write an index.php file that pointed to the main
folder with GET variables that pointed to the section of the site, so freaking ok, now we're moving around throughout the
different webpages of the site. Now, what we would do is freaking...umm...so ok the index.php file would write, then read, so
freaking umm...ok so what our array would look like so far is:

array
	index.php (string)
	0 (array) (Home)
		index.php (string)
	1 (array) (Portfolio)
		index.php (string)
	2 (array) (Contact)
		index.php (string)

So ok, what we would do is load the array, then we would automatically load the first string in the array (the index.php file,
by default apache standards), so freaking ok, umm...so ok, if we wanted a site with a few sections on it, umm...so freaking ok,
we would load the site, the index.php file (otherwise the first element of the array) would load, then...ok so what if the home
page is the first element of the array? Is there a point to...in this case yes there is: there is like a header and a footer
html element common amongst all of the pages, so the above is accurate. So ok, what happens, line by line, is:

Cinder(.com) is loaded
the index.php file is loaded
the header is loaded
this loads the webpages fifo
the "Home" folder is loaded (the Home/index.php file is loaded)
the innards of the Home page are loaded (and output)
the index.php file loads its footer

So freaking thats it! That's all there is to it. From there it's all just details about this and that, so I mean you might as
well just start coding?

Ok, so now how do we structure these things?

The first element of the array is responsible for everything, so...now ok it doesn't have to be like this, just the way we are
applying this requires that we use an "index.php" file as the center of everything, so thats what that is. So freaking ok, the
index.php file loads:

load
write
	priveleges
		success
			commit all writes (edit, add, delete, etc.)
				the actions of writing would (could) be delineated by an array
					fifo
		failure
read
...

Ok so fundamentally what would be happening is we would load a series of php files that would...so within php, we would load a
series of php files that would run everything. So freaking ok, umm...the thing is we have like a single php file, thus, so it's
like better to just clump EVERYTHING into a single php file! Freaking umm...so like we just pile everything into a single
folder, lol. So ok the thing is at least what this thing would be is an array, a SINGLE array, but an array. So I mean ok, umm,
at MOST what it would be is a single, tiny, point. So freaking ok umm...so no array, no changes, no nothing. Sheeit! So
freaking ok, thats what that is though dude. Freaking beautiful. So ok, umm...so now we code the maximus? Umm...well, I mean, I
have like nothing better to do. Freaking ok, umm...so ok then we have this big, clunky thing...is that really what we want?
What if it breaks? It would be better if we didn't do that. IF there's a way to not do that. I would kind of not prefer it, but
that IS what that IS. Through and through.

So freaking ok, now what? Play some WoW, sit around and do nothing? Go for a walk? Freaking a dude, so we have to like shoot
the thing off or something. So ok shooting it off would be like coding a website about it: time-consuming and clunky. Bigger
than the smallest, so incorrect. Freaking yea that's what that is dude.

So how does one approach this kind of thing from that point on, then? Umm...there's a way to do it dude! Keep coding! So
freaking ok, onward:

So what we would have is a freaking index.php file that would be guiding everything along, so what that is is...freaking...damn
I want a cigarette, lol. So ok this index.php file would load, then basically what would happen is all of the writing of the
file, so it would check priveleges, then if priveleged, write to the filesystem (or database, this is a point of abstraction).
It would write strings to the storage, so like simple text files or something like that. So ok, the thing at this point is we
couldn't have a single type of file, or could we? Umm...they're all fundamentally files so there's no difference, just like
they are all fundamentally strings, so we could use a mix of mariadb/filesystem etc. So freaking ok, umm...so we would write to
the storage: we take the GET/POST variables and...filter them, then...basically we store them to their accompanying
folders/etc. So freaking ok, we store the strings somehow. So ok, as this would be a layer of abstraction, there would be like
no "common thread" here. How do we do this while maintaining the structure of these things, at this point? For example, we know
that we want "Home" to be a simple rich-text page, just, how do we "do" this with php? So ok we would have something like:

Ok so like what would be going on here is we would have a huge (potentially HUGE) array of strings that were parsed by php that
would create certain functionality in php, so like umm...so ok now what all websites have in common is the tiniest point (we
call this, at least, "Qi"), so we have qi to start with. So we take qi, then we go ok, we code everything from that point on.
So technically speaking we code EVERYTHING from that point on. There's no other way about this. No two things have any more in
common than qi. So freaking ok, umm...lol that leaves us with very little to work with. :) Technically speaking I think it
would be nothing. So freaking ok, we have qi, then we may or may not have a second thing. If we do, we can proceed...we can do
this with qi. So because there IS a point in common we can generalize the whole process. It will go down, you just have to keep
working it and working it until it's completely pliant. So freaking ok, in a massive jumble, what we would have is:

Ok the thing is at this point we have the compatibility to do things like have projects within clients and clients within
projects. So lets say we have a project, Cinder, and then we have a client, then we have some projects, then we don't have
anymore clients. Or do we? Shouldn't we maintain the order of everything (clients from clients, etc.)? Umm yea at least. So
freaking ok, what we have is...so freaking ok, umm...hmm...so ok what is the semantic structure of this thing?:

Or ok what is this thing, fundamentally?:

It's an array, a recursive array of strings. So freaking that's it. So freaking ok, umm...ok so we have an array of strings,
then we have stuff going on like interpreting these strings with php, or storing them to mariadb/the filesystem/etc. So
freaking then we have a layer of code...thats what that is dude...so you would have the array itself, then you would have a
layer of code. So that layer of code could determine whether to, for instance, interpret that array with php, store that array
to mariadb/the filesystem/some other storage, etc. So freaking ok, umm...so then we have the array. That's it, we just have an
array. So freaking ok, I guess we should code this array? Should it be XML or what? Huh...beautiful...so ok we effectively have
data and interpretation, so this is consistent with the rest of our model. So freaking then everything is string, which this
is, then umm...then we code an interpreter, so...ok so what we would "have" is an array, so then our "layer" would do stuff
"with" this array. So freaking ok, like...:

What would happen is we would have an array, then we would have stuff like storage mechanisms and stuff for this array. So for
instance there would be no single...ok so we have an array within php, so that is fundamentally what that is. Is this correct?
Ok so like what we do is write...like all this is is writing a php file with an array in it, populated with your data. That is
like dead on. So you have to write the index.php file with this inside of it, it's no big deal! Furthermore, if the data is on
the server, it's not any more demanding on anything...there's no difference. Freaking ok, when we GET THERE there's gonna be no
freaking difference, so there's no difference now! So ok lets say we have this array hard-coded into the index.php file...then
what? Then we just read/write it at will. So like thats what that is then. At least. So freaking ok, umm...so lets say we have
a simple I/O process, the I writes to the array (add, edit, and delete), and the O print_r's the array. So freaking ok, this is
a VERY simple way of interpreting this data. So freaking ok, umm...so storing this (anywhere but in php) becomes secondary. So
freaking ok, that is at LEAST what that is because it's inside PHP, and we're inside PHP, so in fact that is what that is! So
ok somehow we would get our array into php, because we're talking about "inside of php", so thats what that is. So load it from
an XML file, a database, whatever, just get it inside of php. Then we go a step further, in terms of purity, and go ok we
directly load it in php, so we hard-code it into the index.php file, and that is about as pure as it gets. But as long as it's
inside the index.php file, somehow, it's all good. So ok, that accounts for the actual array itself, so like we would write a
php string that did this. So freaking thats a thing dude! Then from there...ok so what we would do is...ok so we have to write,
then read, so we write our database: freaking ok, we have a...

Ok so we just pick a storage method, then we write to that storage, then we read. The thing is we don't have to have any
output, in fact we don't have any, before we write. So this can be done (and therefore is done) first, and reading follows. So
freaking ok, umm...so we write the storage component:

filesystem
	index.php
		0
			index.php
			Home.txt
		1
			index.php
			Portfolio.txt
		2
			index.php
			Contact.txt

Ok not yet. So what remains? So we have index.php, we have our storage component, then we have to code the UI for editing the
site, and we have to code the site itself, aside from the dynamic components. So freaking ok, umm...we code a mechanism for
logging into the admin area of the site, or the write privelege (which would open up the admin view of the site), then we form
the output and send it to the browser. So freaking ok, umm...freaking...ok so the page loads, which also loads the storage
mechanism, then we write, then we read. So what we have is:

index.php
storage
write
read

Mmk...umm...so index.php would be one thing, subject to change...ok so from index we would write to our storage mechanism. So
what this would be is inputting to the site, so editing the site. So freaking ok, umm...what this would be is inputting to the
site, so like anything we can take in from a form. Or any form of input. So what this would be is...freaking...so this could be
anything, because we could code a UI for this with js, so it could literally be anything. A point-and-click interface that does
anything, so I mean it's completely objective. So ok, umm...anything. So freaking ok, umm...what this would amount to is
string...because that's what we're using. :) So freaking ok, umm...so some string, so a non-empty, or empty, string. Any
string. Ok so that is what that is. Then why is it string? It's string because files are made of string, even this file, so
WITHIN this file (hypothetically WITHIN php). So freaking ok that's at least what that is. Why string though? To a point, why
string? Does it have to be anything in particular? So it's a recursive array of strings, so it would be (at least) an array
because we want to handle multiples, then it would be string because...we can write any value with string. We can do that with
anything though, so because files are made of string (and php code is string). So freaking if nothing but by convention that's
why we do that. So freaking ok, umm...we have to pin it though, why string? For now it's good, again we can always change it if
we need to.

So freaking ok, umm...ok it would be string because we would represent classes/numbers/etc. with string, just like we do in php
and in fact, as we do in php, since that would BE php code. So freaking string in, string out. Even if we're wrong we're right,
because we can always change this.

So we, at least, assume we're right about using string. Then, we code our input. So the way we do this is it is one thing, so
then it fits exactly, EXACTLY, in there. So freaking thats what that is. So freaking we:

index.php
input
output

So ok what we have then is an array, and we load...:

index.php
	storage
		indexes
			input
				add
				edit
				delete
			output

So freaking thats what that is, quick n' dirty. So freaking shall we code or what?:

index.php
storage
indexes
input
add
edit
delete
output

So freaking thats what THAT is, NOW shall we code? Freaking a dude...thats what that IS! So freaking ok, umm, what exactly
would we need for storage? We want to store strings, so thats the input, then we want to retrieve the strings, so thats the
output. So freaking ok, umm, so thats one thing a piece, so thats what that is, so freaking umm...the rest would be like an
extension of input, so like what we could do is just go ok store this string, so if it's an empty string we delete the file,
and if it's something else we save that. Yea makes sense. So freaking ok, umm...so freaking ok, for instance, when dealing with
multiples, if we don't have one of them, we don't store empty files for that element. So we would use the same mechanism for
storing single things: if there's nothing there we don't store anything. Whatever that amounts to. So what that would mean for,
say, "Home" of "Cinder" is...we just wouldn't store anything. It would be the exact same mechanism that we use for multiples,
so one or two, so when you get there it'll work and everything.

So freaking ok, umm...thats what that is. Now, what if we laid out the whole...is there a point to doing this? Freaking a dude,
this is pretty bad. So you lay out an entire site, then you flesh it out, and you're done. Making a lot of sense. So freaking
ok dude, umm...what else? Smoke one dude.

Ok now we need to work these elements out until they are perfect, and I mean perfect. So freaking ok, index.php would be rather
maleable, since it runs the entire site: this will be like custom programmed for every site. So freaking we'll skip over this
for now, so storage: storage receives input to store and outputs that input to the browser. So freaking ok, umm...so we have
multiple things, why not just one thing? It has to be one thing. It is one array, just that array stores multiple things. This
isn't good. What this means is we have to generalize unique things, which like is turning multiple things into one thing. So
freaking this is like counter-productive. We should just have one thing and that's it. So freaking how could we do this? Hand-
code every, single, thing? I think I'm about done for the day. We're good dude call it. Peace out.

So freaking ok, umm...how do we do this dude? How does everything come down to "1", and what does that mean? Can we get where
we want to go because everything comes down to "1"? That means it all comes down to the same thing, so doesn't that mean what
we want it to mean? That we can do anything with this thing? So freaking umm...I mean...if it all comes down to the same thing,
then we just need to figure out how we got there, then...then we freaking...what if we generally outline what we would do with
a 0 and a 1? What if we take the week off? Lets take the week off...naa. So freaking ok, so like even if we know how something
breaks down, we still have to apply that knowledge...thats why you don't do that. That's why you get the whole thing up in one
fell swoop. So freaking ok, umm...how can we get it up quickly, though? So freaking ok, umm...so keep building this bad boy or
what? Freaking umm...how do we generate meaningful data? Honestly we haven't hardly tried yet, so I mean that's what THAT is.
So freaking ok, umm...ok so in a straight line, something is either 1, where it's already down, or 0, where it has to "go
down". If it has to go down, we just compare it with its destination and take whichever wins. So freaking ok, umm, therefore
"1", just what does that tell us? So freaking ok, thats HOW we do that, now HOW do we apply this knowledge? So ok, now we
immediately jump to where we want to go, which is generating 0's and 1's, meaningfully, out of thin air. So ok, generating one
of these wouldn't rely so much on the breakdown of one of these as it would on peripheral factors: barometric pressures,
basically. If we know how to translate those to binary...ok what if you take a batometric pressure, which is binary...you would
need binary explaining what like oxygen and hydrogen were. So freaking ok, umm...so basically you can tell whether something is
0 or 1 in php, just not outside of php. Yea that's basically it. So freaking ok, umm...huh...so freaking thats what that is, so
freaking...hmm...so like what's the plan? How do we get there? Umm...I guess we just study it and that's it. I mean is this the
best way to do this, however? Good question. So like it would be better if we...you know, being particular, why can't we tell
how to do this/what this is/etc. from knowing how data breaks down? It seems like we should be able to tell, therefore. So
freaking ok, what we have is relativistic terms by which 0 breaks down to 1. Now, these are slightly absolute, so I mean, like
basically you SHOULD be able to work with them to get the whole thing down...umm...so freaking how do we apply the data we DO
have to this to get what we want? So ok even if we use this to "generate" binary, we don't have any absolute anchor with which
to generate that data; we don't have an absolute pattern to generate data with. So I mean that, simply, is what that is. So,
now what?

So freaking we come up with something to do this with...why couldn't you use the breakdown of data to do this? It seems like
the answer is somewhere in there. If you know that a 0 is a 1 because 0 or 1 you get a 1, then you know how both of those are
the same thing, now, if you apply this knowledge to what you're looking for, what do you come up with? So ok I know that if I
go in tiny little circles I have 0 and/or 1, then 1, or 0 and 1. So we alternate, 0, 1, 0, 1, and so on. Which number we start
on, I don't know! 0, we start on 0. If we're wrong we can fix it. So let's assume we start on 0, since it comes before 1. So
freaking ok, umm...ok so now we start, rock n' roll dude. So freaking ok, umm...so like basically just start, because what is
going to happen is you're going to get so far with like a 0 and a 1, then you'll have a good idea of how you need to elaborate
from that point on, so like for example: you build your system for Cinder, and it gets so big and broad, then, it basically
stops, but I mean basically what will happen is it won't stop. You'll just keep going until you get there, so I mean you might
as well build until you get there. HOWEVER, you can also sit here and conjecture as to what that is, so pick your poison dude.
Freaking ok, umm...so ok dude what you do is like build the whole thing, the WHOLE tomato, so it's all consistent, then I mean
just keep laying that thing down until you get there. You will freaking get there! There will come a point where you're like ok
so generally thats what that is! So freaking ok, umm, how do we shred this thing dude. Freaking umm, what we do is...so ok
there's just about fundamentally two things, so fundamentally there's one thing, even strictly one thing ("1"), and so what we
do is just start building until we get there. So freaking ok, umm, this makes sense. The thing is this makes sense. So freaking
ok that's generally how we do that then, so ok, the thing also is that that is the rock-bottom of the thing. That's why like we
can't fly and shit like that, it bottoms out in like freaking objective indifference, where there's no difference, but like
strictly speaking, where there is a single particle of indifference, and that's how everything is made and everything, now
general indifference, where everything would be the product of indifference or some function of indifference or something like
that. So freaking ok, this means we have to get from the point where there's no difference, to a strict point, to where there's
no difference in general. So like if there were no difference, in general...so like strictly speaking there's no difference, so
when it comes down to strict comparisons, like whether flight is the same as walking, there's a difference, then we compare 0
to 1, and we get 1 and finally there's no difference, but UP UNTIL THAT POINT, THERE IS ONE. So freaking that's what that is,
in freaking string and all. So freaking ok, umm, what if we build this bad boy...ok so lets say there's no difference, so we
code some stuff and there's no difference: we code something that relies on comparison...why, when, would we use comparison to
do something in code? Freaking we wouldn't! That's like not what a process is. So ok I mean the thing is we like haven't even
thought about what we're trying to accomplish IS. We know that we want it, we know what it IS, just we don't know how to MAKE
it. So freaking ok, umm, you know by the time you can explain that you're probably done with the thing.

So now I have to wonder: is this going to actually "fit"? Is it going to suffice as my master system, and so on and so forth?
Freaking umm...

Ok so generally speaking where are we at here with this, what are we doing? Freaking umm, there's no difference, and that's
definitely where we want to be, and we're sitting here, thinking about stuff to come up with...so ok it would be more ideal if
we were to "unveil" the ultimate power as opposed to grinding away at a "build-up" that were the power. It would be better if
that power were a point, one and the same point, than if it were a "build-up" of data, basically like a calcification. It's
more consistent that way and stuff like that. So freaking that's at least what we want. So freaking ok, umm...fricking...so
like ok, what we're doing is we're starting with indifference, then we're trying to see what we're TRYING to do in the context
of indifference, so freaking ok, umm...ok so the thing is that things don't necessarily form a nice ball that you can work
with. Sometimes they are scattered and unorderly and you have to deal with it. So freaking you could have one thing, then the
second thing could be way out of whack from the first thing, following no real pattern. So freaking ok, umm, this still doesn't
make any sense, because if you knew how things were 1 in general, you would know how a 0 was, say, a 1, and thus how to do what
you're trying to do.

If you knew how things were one, in general, you would know how both a 1 and a 0 were 1, and thus you would be able to do what
you are trying to do (turn one thing into two things). So freaking that's what we do, because that way we both know what 1 is
and what 0 is, so it's two for one.

So freaking ok, where were we.

index.php
storage
indexes
input
add
edit
delete
output

So freaking ok, first we hit index.php, then we do our storage. So ok first, what do we have to consider about index.php? So
the reason we use "index.php", and not something else, is because it's the default filename that apache fires in a directory.
So freaking what that means is that our site shoots off when the browser is navigated to a website. THATS IT. Other than that,
there's no reason to do this. So freaking ok that's what that is. Enough said.

Now, how do we handle our storage? First, we would have to write our storage, in general (create tables/rows/etc.) BEFORE we
read it, so how would we do this?

First off, the thing would be a whole, seperate layer of code, because there are multiple storage mechanisms we could use for
our storage. So freaking we could use the filesystem, we could use mariadb, we could use anything. So this is an entirely
seperate thing from the core of it. Freaking, ultimately we have a single array of data, so what this would be is the thing
that loads...ok so what we would do is have a core, which would read, edit, add, and delete from and to the storage. So
freaking ok, we don't have to be right about this...:

index.php
	storage
		core
			read
			edit
			add
			delete

So freaking ok, now why would the storage come before the core? So ok classically the core would come before the storage, and
freaking...umm...so ok fundamentally we would have input and output, where input edited our "string", and output outputted that
string. So freaking all we would have is read and edit, output and input. Now, we have multiple strings, so freaking...if we
consider empty string to be "deleted" (we, in fact, delete the empty element from storage) we can continue this model all-
throughout the structure. Thus we would have:

index.php
	storage
		input
		output

This is highly consistent with our 0/1 model as well. So freaking ok, umm...er rather view. So freaking ok, lets do that,
because that is (at least) consistent with string "length", which is a number represented how many characters the string has.
It will hold. Ok, so we have:

index.php
storage
indexes
input
output

Or, overall:

input
	we manually write the index.php file
	we commit any input to the storage
		we reference the element by index numbers
		we then edit the element
		we then store the changes
output
	we read data from the storage (via index.php)
		we do this by referencing a single element via indexes

So freaking ok, what we do is: write and read the index.php file and storage. Two things. Therefore we have:

index.php
	storage
		input
		output

Or, simply:

index.php
storage
input
output

So freaking ok, this is way fundamental, very good. Now, work it down to one thing. So ok, with either index.php or storage, we
have input and output. Thus we have a "superclass" that does input and output. So what this would do is simply input and
output, so we input, then we directly send whatever was input through the output (when the output is called). So ok, lets say
we input some string, "Hello world", then we have like a callback for the input which is fired from within the input (when the
input is called) which COULD send the input to the storage class, then the storage class has it's own input and output, and
receives the input, then stores it by translating index numbers to whatever its internal organization is. On output the output
calls storage and the storage returns the data corresponding to the given index numbers, that data is output to the browser and
the cycle is complete. So freaking ok, we need like, input and output functions, which have a "callback" storage mechanism
"object" or something like that, and that is what that is. So freaking ok, umm...so thats what that is. Now, squeeze the
freaking juice out of it dude, it's like a perfect orange, ready to juice. So freaking ok, umm...yea freaking thats what THAT
is. So freaking ok, how do we make this bad boy? Ok lets try this:

input
	manually write the index.php file
		storage
			input
				$indexes (array) - array indexes
				$input (string)
output
...

Ok so freaking there are some things to consider here. When we read the site, how do we keep the data current? Do we have a
thing that constantly checks with the server to see if the data is accurate? Do we load the data and hold on to it until
something happens? Both. We would do both. Sometimes, if only SOMETIMES, we would constantly check the server to see if the
data was up-to-date. Sometimes this wouldn't be necessary, though. What is the nature of the data, in these regards? Freaking
umm, so with the Cinder site, it wouldn't really be a big deal...what we would want is for the data to be stored on the server,
then output to the browser. There's like no interaction beyond that point, aside from me updating the server. So freaking ok,
when the...what if you can't do that? What if you have to update everything every time you update the data on the server? Then
freaking what you have to do is do that. If you CAN, however, update data on-the-fly, you should. That's what that is. So
freaking ok, what we have here is...ok what about this: whenever the data is updated, whatever is on the screen is out-of-date.
However, it IS what WAS there BEFORE the updates took place, so in that way it's accurate. So generally what you do is use a
cascading model to do this: update the server, and if you can't, just leave the data on the browser as is, and if you can,
update the browser. So generally speaking it would take MORE bandwidth (it would start to add up rather quickly, when you have
to transmit the whole data to compare it with the server)...ok so what you could do is store times when data was updated, then
compare with the browser, then go with whichever is more current (instead of comparing the whole data over and over again), so
freaking ok, umm...this would like force "cache-clearing", in a way, because of the nature of it...so I mean that is something
we would want to do, so what else? Freaking ok, so if the data is up to date we leave it, and if it isn't we summon up the data
from the server, so what we do is...ok so what we would do is get kinda microscopic with our input and output and go ok, we
wouldn't, for instance, have an output function accept arguments, because those are input, so effectively what we would have is
the output hidden, as private, in an object, and then the input would fire the output off appropriately. This way the output
could not be tampered with, so freaking...ok so then we simply filter the input (one thing, input, therefore) and we're good.
So freaking umm...freaking start coding? We need to get some freaking shit done dude! We need to produce! Ok, so freaking ok,
so we have input and output, so like we would have Cinder, which would be the center of it all, and it has an input and an
output, and what that is is an input for writing code and stuff like that, then an output that would like test all that code/
pack it for publishing/etc. So freaking ok, umm...this is freaking NUTS dude. This is going to take so much freaking work it's
not even funny, but if you do it right, if you do it well, it will work. So freaking do it right dude. Don't even do it well,
do it right. So freaking ok, umm...what else...ok so we have:

Cinder
	index.php
		input
			convert empty strings to unset elements
			otherwise store elements
		output

Ok, so we're just about at the point where: we would have our master system, Cinder, and that would have projects and stuff
underneath it, so what we would have is an index.php file for Cinder, in the sandbox, etc., that would drive all of this along,
and what we would do is code everything from in there, so it's all one big, consistent piece, so yea this makes sense:

Cinder
	index.php
		storage
			filesystem? - way more flexible than mariadb - look into this
			input
				convert empty strings to unset elements
				otherwise store elements
			output

So freaking this is making sense. Everything would be string, effectively, so I mean this works. It totally works. Lets do it.

Ok dude, so what will it take to build this bad boy? So we have Cinder, and what that is is a simple input/output system...even
better than that, it's a simple string, it's one big string, so we can just keep on typing here and beyond. So freaking ok,
now what should we do? Lets write this thing out in pseudo:

index.php (Cinder)
	storage
		input
			write client information to filesystem/etc.
				filesystem is more consistent?
					test this
		output

...

Ok, so we need to test whether the filesystem is more consistent than, say, mariadb for storage. So ok, hypothetically if we
use mariadb to store data we have to use a mixture of rows and files to store everything. This isn't it because there are two
things going on: rows and files. What we want is one or the other, so rows or files, and therefore we would have to use the
filesystem, because then there are just files. So we use the filesystem:

index.php (Cinder)
	storage
		input
			write client information to filesystem
				name
				description
				...
		output

So can we handle ANY elements, at any point in time? Like can we add another element to an array, at any point in time? Or do
we have to stick to templates and that sort of thing? Both. So freaking ok, we press on:

index.php (Cinder)
	storage
		input
			write client information to filesystem
				name
				description
				files
					input
					output
						index.php
						etc.
		output
...

Ok so what if our system includes everything, not just Cinder and it's clients? This would be 1. So freaking ok, umm...so it's
wide-open, and indifferent, then it's a recursive array of strings, then it's projects, Cinder, clients, more projects...ok so
what is that? We'll have to work on this as we go or something, I don't know how we're going to get all of this done. Freaking
ok, umm...so...hah...if one thing is the other and the other is one thing, a filesystem is the wide-open blue sky and the blue
sky is a filesystem. So freaking ok, umm...there's no difference. So ok, we code like this. So what we do is make everything
extensible, so long as it isn't finished, so freaking ok, umm...so we have like a hypothetical input and output, and before
that there is no difference, so we have indifference, then we have input/output, then freaking ok, umm...so ok if we have two
we have to program individual things that have complete sets of innards and all that, which is a lot more work than if there is
just one thing going on, so primarily we don't do that. Now, how do we freaking do this dude. Freaking a dude, umm...ok what if
we do this: we...nah we don't want to do that, because then we have to search twice to freaking...ok freaking scratch that, so
ok umm...

Freak yea dude. What do we freaking do here dude? Freaking freak. Freaking freaking a. Freaking freaking freaking freaking
freaking...ok dude. Freaking a, umm...so ok if we know how everything breaks down can't we just build an extrapolator? What
else do we need to do it? Freaking umm...so ok we know that whatever it is, it's a 1 or it's a 0, just we have to know HOW to
meaningfully generate these 1's and 0's. So it helps to know how everything breaks down in php, just like it helps to hear the
birds singing outside everyday. At least. So freaking ok, umm...we freaking...ok so we know that things tend to be 1, because
any number between 1 and 0, if positive, is positive. It's positive just like 1 is positive, so that's what that is. So
freaking ok how do we define the rest of the behavior of 0's and 1's? Or, furthermore, how do we define the behavior of 1? Ok
so we come up with a microscopic view of a 1. So, for example, with our CMS-like thing we're building above, writing comes
before reading, simply because if it doesn't, our data isn't up-to-date when we read. The whole body of cascading logic from
that point on is what defines the behavior of 1, and in fact what we are looking for. So what we do is just keep developing the
thing until we get there.

So ok here's what I think we should do: I think we should develop a "version" of this thing that simply writes and reads an
array (via session or something like that), and then develop it from there. That's like the purest version of the thing I can
think of. So freaking ok, should we jump in and do it, or sit here and think about it some more?

So ok what we do is go ok, our data is accessed via input and output functions that edit that data or read it to the screen. So
freaking ok, those functions then call accompanying functions within the storage mechanism that subjectively deal with that
data. So freaking ok, the storage works. That's all there is to it and it works. So freaking then we write and read from our
site and the cycle is complete.

Now, what if we want templated aspects to our site? Like what if we want screenshots...and we want every screenshot to have a
thumbnail and a full version of the image? Then we only want thumbnails displayed on the screen, and full-sized image to be
displayed when a thumbnail is clicked? Then how do we tailor our data? Figuring this out will GREATLY speed you along towards
where you want to go, because if you can do this you can literally handle multiples without freaking flinching.

So ok, the thing is our data is all string up to this point, so what we want to do is keep it that way, mmk? So freaking ok,
umm...so what we freaking do is...umm...:

Cinder
	index.php
		storage
			template
				multiples
					single
						input
						output

Ok so what if we just make an all out system for dealing with an array. Freaking ok, so what we would have is something that is
independent of filetype/that sort of thing, so freaking...freaking a dude...thats what that is. We have to freaking account for
all string when we do this, since it's all string, so freaking you have to account for every single existing mime type that a
(string) file could have. So freaking ok, what we do is go ok, we have a string input/output, and the same general structure,
and we just get it in there, then we filter everything from that point on, and freaking that's what that is. So:

index.php (Cinder)
	storage
		indexes
			string
				input
				output

So freaking that's what that is. Freaking a dude. Beautiful. So freaking ok, the string goes in and out of there, so that's
good, so this will account for any part of the array? All the recursion, everything works up to this point? Hypothetically it
does. Freaking ok, umm...smoke one dude. So ok, umm...

So ok, what we have here is the storage is basically a point with an array attached to it: we know that we want to simply store
some string, just we could use the filesystem, mariadb, etc. to do this, so there is a point of storing string, then there is
an array of possible storage mechanisms we could use to do this. The same thing happens with each file type (when storing
files). So what is the root of all of this? It would be something like php, wouldn't it? Since that's what we're inside of?
Freaking a dude that's what that is. Freaking umm...huh, so we have a point of string, which is native to php, then we have an
array of possibilities after that point. So ok, lets say this array has a 0 and a 1 in it, in that order, I suppose. How do we
freaking deal with it? Freaking a dude. Umm...So freaking ok, umm...one way of dealing with this is to say use the filesystem
BECAUSE it's a better fit than mariadb, etc. However, the fact that we account for layers of code should deal with this
accordingly. So freaking ok, umm...we can always fix it dude. Freaking a dude...umm...

Ok how about this, how does the fact that 1 is positive and 0 is negative get you further along in figuring this out? It
somewhat describes how the data all translates on the way down. Fucking a dude...

Ok so we would use the filesystem because it is more consistent than mariadb. So freaking ok, from there the whole thing is one
solid thing (subject to change). So then, lets say we encounter an image file (a jpeg). How do we deal with this? So like what
we would do is just link to the file from the browser, whatever the file was. Now, so like what that means is there's a way to
tell what these files are built into the browser. So freaking ok...umm...freaking call it or what? Umm...naa don't call it, but
I mean how do we do this? So freaking hard dude. Ok call it man.

Oh freaking kay dude, freaking I was thinking and if we map everything out, if we build everything, even pretty much, on a
website, we know generally, GENERALLY, how a website works. So how any website works, or what the absolute website is. So
freaking ok, umm...:

index.php
storage
input
output

So basically thats what there is to a website. So freaking ok, now what if we map all this out in pseudo:

index.php
	fire up storage
		input
			!storage?
				install storage
					filesystem
						check permissions on root folder
							on success
								"installed"
								write a file saying it's installed
							on failure
								"You do not have..."
								install storage
					mariadb
						take in mariadb credentials
						create tables
		output
...

So freaking ok, at this point you have to consider...both dude, do both.

index.php
	fire up storage
		input
			!storage?
				!storage->installed?
					install storage
						filesystem
							specify a folder to save input to
								checkbox to create folder if not exists
									
									check permissions on root folder
										on success
											"installed"
											write a file saying it's installed (for line 5)
										on failure
											"You do not have permissions on the root folder..."
											install storage
						mariadb
							take in mariadb credentials
							create tables
							...
		output
...

Ok so this isn't how this would go. How this would go is:

index.php
	check storage requirements
		check storage
			check for input
				filter and store input
	output

So freaking ok, umm...how do we do this? Freaking ok, umm...we freaking...ok so generally thats how we do it, so I mean...
freaking ok, umm...

So should we (finally) lay down some code? Umm...freaking...is this going to get big enough? How do we make it freaking huge. I
mean BIG. Ok so just keep marching along dude, you're totally getting there.

Ok so like effectively what we have is an array that we're writing to and reading from, so we just translate...yea I mean it's
all in place, code it?

One last final check...so freaking like yea thats about it. Umm should we start coding? Ok so a couple guidelines about
coding: make sure you stretch the thing TAUT at every single point in the code, so freaking we end up with no unnecessary
whitespace, no excess in variable names, etc. So freaking ok, umm, we need to refine our thing a little bit. We need to like
make, or otherwise get our hands on, our whitespace stripper, our code-refinery, so that our output comes out streamlined and
all. So freaking ok, umm...ok dude, you're like not gonna like this but you need to code all this stuff. You been to be
completely on top of things inside and out, so you need both: code formatted by beautifiers/etc. found on the web and code
formatted by your own hands. So freaking ok dude, freaking a. What else do we need to do? Ok so here's a run-down of everything
we need to do to keep this thing afloat:

Central hub of all coding (and preferably everything!)
Whitespace stripper/code refiner
...

Ok here's a thought: what if you come up with a code refinery that refines logic? Like it would go ok, instead of checking two,
check 1? And that sort of thing? You could speed up your production like this and then pick up speed toward your destination.
Freaking a dude. I'ma go get a cappucino. No I'm not. Arg! The internal BATTLE! So freaking ok, umm...so freaking ok what if
you aren't so pro that you've figured out to use a qi? That you've figured out to BE a qi? Freaking a dude...umm...huh...yea
that's like what that is. If the trend...yea thats what that is. Freaking a. Umm...ok so there IS a way to do this, whatever
"this" is. So freaking we can be a qi, and use a qi across the board, and still get away with coding this thing and so on and
so forth. So freaking ok, umm...now, what if we come up with our macro-system at this point in time? Something that does a
bunch of stuff based on very little stuff? So like for example we use an "if" wrapper, a function wrapper, so freaking
everything is consistent...or like what if we used two-bit sequences...or one-bit sequences, to represent all data, then we
macro-program these until we get what we want? So basically we use macro's to shoot along...freaking a dude there's like not
going to be any easy way of doing this. I mean freaking even when you get all this stuff stripped back you still have to code
for different browsers and everything. It's never-ending. Freaking a. Ok so like what if you write like a programming language
built on php that programs php...or something. What if you use a system that codes statements, so like you would have a
function that would "write an if statement", and then when you export the file (all the code) it writes everything with slim
variable names/no unnecessary whitespace/etc.? Freaking umm...get some freaking smokes or what? Naa...ok yea get some smokes.

Ok freaking a...so freaking we're gonna code this whole thing...this stuff SHOULD be done at some point, make SURE it isn't
already done.

Freaking ok, looks like you might have to build this bad-boy. You are doing this anyways (you're doing BOTH). So freaking ok,
umm, what you do is make a whole layer of code that "codes" the output, so everything is freaking form-fit and butt-tight.
Freaking I mean to a point! Yea dude...freaking ok, it should only take ONE THING to do this...ONE FREAKING THING. So like what
you have is...a function or something that handles a fork, or like a switch, and then codes everything based on that switch. So
like basically there would be one conditional statement, one loop, etc. Then, AND ONLY THEN, can you correctly do this. So
freaking ok dude, what else? That's in the box dude, you can totally start coding. Umm...huh...yea dude...freak yea. Ok, then
what? Let's keep this going. So freaking then we build a...then we build a mechanism for every little thing, so we need one for
backend, as well as frontend, inside, as well as outside. So freaking ok, umm...so what if we have a single opening and closing
element, so like curly braces, or something, angle brackets, that do EVERYTHING. We could then account for everything, every...
hmm...what if we regulate code itself? So like we go ok, we have an element of code, then some whitespace, then another element
of code? Then we have like angle brackets or something for nesting? Umm...all you would need is angle brackets, but you would
need one LESS of them if you also used whitespace, so I mean...

Ok dude, here we freaking go. So freaking ok, lets say you have...smoke one dude this is gonna take a little bit. Ok dude, so
freaking lets say we have a single thing, "switch", to account for all comparison. Now, how will we compare things inside of a
loop? So we have a comparitor, then we have an array of freaking values...then we loop through the values...so freaking ok,
umm...so we loop through values, umm...ok so we need the ability to loop through arrays, or rather an array, then we need the
ability to draw comparisons, then...so we need the ability to draw comparisons BEFORE we need the ability to loop, then what
else do we need? So ok, what we generally do in a computer program is: ok so we want both; we want to be able to loop before...
which one logically comes first? Comparison. Without comparison we have an infinite loop. Then we have the ability to loop
through multiples, and therefore this thing should work. That's it. One thing, looping. So what if we try it out? Freaking ok,
umm...the other half the time you will be hand-coding everything. ! Freaking a dude. That's what that IS. Freaking ok, umm...
ok so what is the tit of all of this? So we have comparison, then what? Then we have something to compare, so something that is
of a type, so a "variable", or rather a value (of a variable). So freaking ok, umm...then we need two things to compare, or two
things the value of a variable can equal, so freaking ok, what about before variables? Then we have variable assignment, so
basically then we have values, and other than that we have variable names. So freaking ok, what about before THAT? Ok so
freaking wait a minute, we can have just plain values (function returns) without variables. So we have values, then what? A
comparison requires at least one value, so that's the end of that. So freaking ok, before values we have like the formation of
values, which would be functions, or any other means of forming a value (mathematical addition, etc.). Imagine you stuff
everything inside of an instance of a class, you then do EVERYTHING at the point at which you initialize that instance. So
freaking that's what that is: either one. So merely as a matter of fact does the order of these things matter. Freaking a dude,
that's so what that is. So I mean you could totally honcho it and it won't even just work, it's the same exact thing. The same
thing to a STRICT POINT! Freak yea dude. So ok, now what? So yea I mean that's what string is. Freaking that's what string IS.
Freak yea dude! So freaking ok, if you sit there with a qi...there's no difference dude! To a strict point!

So freaking ok, the whole thing is made of string, even when we introduce the filesystem. So freaking ok, umm...so yea the
whole thing is string, now the problem is we don't have enough data to fill everything in. It needs to get bigger, therefore!
So freaking ok, umm...ok so from there, the output is all string. So freaking ok, umm...it freaking works. That's like all that
need be said is it works. So freaking ok, umm...so freaking ok, umm...we like freaking...so freaking when we get there, when we
FINALLY get to the point that we're outputting markup, its all string, so all of the html/css/js is string. So freaking ok,
like what this means is there is meaning and melody to this string, so what we do is break it all down until we bring it to a
point, then we work all of our code down until it's flush. So freaking ok, umm...so lets say:

index.php
	storage
		input
			files
			GET/POST variables
			etc.
		output
			html
				strings output inside of tags
				therefore like everything is a "tag"
				if it's not
					we need to be able to deal with this at will
						so for instance, the doctype declaration:
							we'll need a tag that doesn't have a closing tag, that is valid
								DOMDocument?
								there is some way to do this, because our system is compatible with it, whatever it is

So freaking ok, umm, so we have string, inside and out, so there is rhyme and rhythm to everything. Freaking a. So like ok,
when we get there (or right now!), we compose our string of logical stuff like tags and stuff, and it all narrows down to
something. So freaking ok, umm...as long as it fits inside the threshold, it's all good. So just freaking get it in there,
dude.

Ok, so should we start building? Should we map this bad boy out a little bit? See how this is all gonna work? Yea lets do that:

index.php
	fires up storage
		store any input
			reference by indexes?
				so you'd have to reference data by...should just work? Like ok we'd have to reference all of the data by like
					a "root" folder where we started storing all of our data. The thing about this is shouldn't we just build
					the thing and let it materialize? What if we try it out and see what we get? It should flow rather
					smoothly. Ok, let's do it.
					...

So freaking ok, lets map this thing out. So we have like an index.php file that loads everything, and what we do is...fire
everything up from there, so what we do is...use generalized storage to interface with a certain storage mechanism, and then
input/output from that generalized storage mechanism. So freaking ok, we send it some input, it stores it where we tell it to
(by indexes or otherwise) with the input we give it (some string). So freaking ok, umm...smoke one dude. So freaking ok, umm,
what this is is...we freaking...ok just hammer it all out dude.

Freaking ok dude, if you code this thing, it's a freaking beast. Are you sure you're right, before you even start? Umm...I mean
hypothetically it all works...what is our output? Something like:

<!DOCTYPE html><html><body>Hello world</body></html>

So freaking ok, now every bit of html will be defined, in complete detail. So freaking ok, umm...now how can we code this thing
in such a way that: it's not so freaking confusing it's not even funny. Hah. I mean ok, umm...freaking...umm...what the hell,
dude. Freaking a. So like freaking there's nothing to do but code, like. Like freaking there's nothing to do but code. Oh
freaking kay dude, why not just use wordpress? We could build a plug-in for it that does all this stuff. Freaking a? Ok so our
output would be linked to css by attribute or tagname, so freaking...

Ok, so we would have some html as output (to the browser), so html in all its glory. So freaking ok, umm...should we build or
should we sit here and talk about it? Less talk, more rock. Ok so freaking it would, at this point in time, be good to note
that what we have is an array, not string. So freaking ok, what we want is string, I know this. So freaking ok, umm...if we DID
use an array it would work, just if we use string it would be more consistent (the input is string, I know this from past
experience). So freaking ok, do we use array or string? What if we code this thing in pseudo and see what we get? Like every
little detail, and see what kinds of patterns and stuff come out? What kind of patterns are there?

We have a function that returns 1/0 depending on whether the thing is installed or not, so freaking ok, umm...I THINK that's
the first step. So let's lay this thing out in pseudo and see what we get:

installed?
	
	install
		create tables
...

Ok so the thing is, it doesn't matter HOW we do this, the question is just whether we do it or not. So freaking ok, if we DON'T
do it, we sit here with a qi and hope for the best? Freaking ok, a qi works, but what exactly does this mean? It works, it goes
down, just like everything else, just what does that mean? What is working? Does "working" mean it will carry us, successfully,
to heaven in the afterlife? Does "working" mean it will work before then, that it's working now, and will get us to our
destination long before then? So ok, on the way down, everything goes all the way down. It's only at a step before things reach
the bottom that values have to add up, and in the end they all go down! Freaking they all go down dude, that's what that is. So
freaking the qi goes down, the two goes down, everything goes down, EVERYTHING, so the rhyme and the reason go down, so the qi
goes down and the going to heaven goes down, so that's what that is. So that is the current-working model, now what we need to
do is prove it, and that is what that is. So basically we're being, and not being, a pussy at the same time. Shouldn't we just
not be a pussy? Freaking umm...ok what tells you, from your past experience/etc., that this DOESN'T work? Freaking nothing
dude. There was never a thing that directly said that something didn't work, and in fact they do work, so freaking bite it and
commit and call it a day. Don't stress over it dude. Freaking ok, there's a way to put all of this together without being a
pussy, so freaking do that dude.

Mmk, so there's, even strictly, no difference, at the end of the day. So freaking ok, there's strictly no difference, so go for
it! Freaking ok, umm...so if there's strictly no difference, the nigga and the priest go down! They go down, and they go down
equally. So freaking ok, umm...first of all we're down, and we're already down. Second...ok dude just freaking start, and don't
stop, and work all this shit down. Then, when you get there, look back on the fact that there was strictly no difference and
figure out what it's worth to you to run with that instead of the latter. So if there's strictly no difference the path in is
just as good as the path out, so freaking there's no difference! What I'm saying is that if there really is no difference, even
strictly, then even if you're wrong, you didn't make some serious, critical error; something ELSE went wrong! What about
working within the box? What is acceptable to you in terms of indifference? Freaking umm...you know from past experience that
there is no difference, to a point. You went down there and back up again on that logic. So freaking ok, what else do we need
to go from there to where we are trying to go? If there is strictly no difference, what is the difference between that and
anything, some free solution to the problem? And furthermore, to bring things home, even if it DOESN'T work, there's no
difference, so freaking umm...so there's no difference, so things work ANYWAYS! Or whatever you call indifference in that
context. And even then wouldn't we, at least, call that indifference? So, ultimately, at least in php, what we call that, when
it's all said and done, is "1", and strictly speaking there is no difference, so who cares? So ok, have you considered that you
relatively found your way all the way to the bottom? Freaking what that means dude is you KNOW that you can make your way down.
So what if all of this is short-circuited by THAT? Freaking ok how do you know that you can use a qi to go to heaven in the
afterlife, relatively speaking there is strictly no difference. So freaking there is no difference between going to heaven and
not going to heaven, so what is THAT? My point is that the current-working reality may outweigh the future. Does it? What is
the cascading logic of that? So ok, EVEN if you figure THAT out you defy your qi by doing so. There is strictly no difference,
struggling is one thing you can do, therefore. Not struggling is also a thing you can do. What is the cascading logic THEREIN?
Have you ever thought about THAT?

Freaking ok so we can struggle or not. So struggling is not a good thing, or is it? See, now we make a longer round about
things because we fear the consequences of being indifferent, when there is, strictly, no difference, and even when you know
that this strict indifference works for the better! To what end? Either way, we know that we take the route of strict
indifference. Beyond that, we have to figure out whether to hang on for dear life and ascend to heaven or go with the flow and
go to hell. Freaking a dude, ying and yang. So freaking ok, lets weigh the pro's and con's of each of these. If we hang in
there and ATTEMPT to go to heaven, there is still strictly no difference. If we don't, there is also still strictly no
difference. Therefore we hang in there and attempt to go to heaven. If it doesn't work, we're better off than passively
accepting our place in hell. That is that.

Furthermore, you SHOULD be able to, relatively speaking, prove that you can go to heaven. So if there's no difference, we have
the question of whether we can go to heaven or not and the act of, at least, attempting to go to heaven. With both there is no
difference, even with going to hell there is, strictly speaking, no difference. Therefore you can go to heaven. Your attempt
succeeds. So freaking ok, that's what that is. Now, how do we ascend to heaven BEFORE we die? We work all of this out and get
there, dude. Freaking a.

Ok, so how do we do this? What is the cascading logic of this that leads to success? No matter what, there is a line of logic
that leads to success, because even if we hit rock-bottom there is logic that persists, all the way back to the top. So
freaking ok, what we do is...come up with a broad logic for doing this. Finer logic is harder to apply, because...it's faster,
though. Isn't it? It's more efficient if it is, or is based on, a qi.

Freaking, ok...so the reason we would use string is php code itself is string, so we would use AT LEAST string. So freaking ok,
we have a string, and we have I/O with that string, so freaking ok, very simple mechanism. Now, umm...so that gets us in the
door as far as php is concerned. So freaking ok, then...then we code a php file, and what that does is...ok so at least what
that does is loop through multiples. So what do we need to loop? We need a condition by which to loop (so our loop ends), and
then we need stuff to loop through. That is AT LEAST what it takes to run a php file. So freaking ok, umm...:

php
	loop
		while condition

So freaking ok, umm...so when we loop through the data, we do stuff with each element, so we have a callback. So freaking ok,
umm...so that's AT LEAST what that is. So freaking ok, umm...so what we would do is:

php
	loop through projects
		find Cinder
			loop through clients
				find client
					loop through projects
						find
...

Ok so the loop would be, at LEAST, one-dimensional. So this is good, because it freaking means that everything is
one-dimensional. Freaking ok, umm...so freaking ok, umm...so we have a pattern of looping through an array (looping until we're
through the array, so that's the condition of the loop) and finding something, then calling a callback on that array element.
So freaking ok, this is AT LEAST what this is. So freaking ok, umm...ok so we have a function that returns a value, then what?
Then we go ok, that return value is 0 or 1. Then what? Then we have consistent returns, unilaterally, then we have a system! We
have a freaking working system dude! Freaking ok, then what? Then we go ok, so if it's 0, then we compare 1 to 0 and we get 1,
so then it's 1, and it all is down! Freaking ok, umm...so ok, then we have a value, then what do we do with that value, or in
general what do we do? So then we either assign that value or not, or output it or something, or it is lost inside php. So if
we don't "output" that value it is lost in php. Yea that is simply what that is, input or output. So freaking ok, umm...so if
we don't output that value that's a 0, because...0 output is 0 output, whereas 1 output is 1 output. So freaking ok, then if we
don't input, that's a 0, and if we do, that's a 1. So freaking that's for the same reason, because 0 input is 0 input, and 1
input is 1 input. So freaking ok, then what? Then the thing like freaking works so that is what that is. So ok, with no input,
there is no point to using php. However, the thing is we want BOTH. Or do we want one or the other? So ok input without output
is 0, because the two are part of one system, and output without input is 0, so freaking...ok so the average of the bits of
input with no output and output with no input is 0.5, which is a positive number, like 1, therefore 1. No output and no input
has an average bit of 0, and therefore is 0. So freaking that's what that is. This model, by the way, matches that of "or",
with 3/4's of the results being 1, and 1/4 of the results being 0. Freaking a. So freaking ok, now what? Should we just code
this bad boy and watch it all unfold? Umm...freaking ok dude, if you consistently return int (0 or 1), freaking ok, then
everything will be RIGID. It will freaking work! Makes sense, right?

Oh freaking kay, umm...so how do we freaking do this dude? Umm...we like...freaking ok dude, if this all comes down to one
thing you have a freaking automatable process. Which is totally what you're going for. Freak yea dude! Ok how do you freaking
do it dude? Hmm...ok dude, start coding! You can start coding: once you know what to do you can start coding. You just code
along and it all adds up because you have consistent returns; everything else just falls into place. Get to it! Ok so freaking
what we're going to do is go there's no difference, because we are already having problems with a return of 0 or 1, where the
__construct function of a class cannot have a return! So freaking that's what that is. Same thing though. So freaking ok, umm,
doesn't this mean that if there's more than one thing the thing DOESN'T work? Like freaking ok, umm...so freaking if there's a
difference the thing doesn't work. That's simply what that is. You have it by the tit, now start sucking? Umm...doesn't this
mean that if we use anything other than a qi, it won't work? Ok so if there's no difference, and everything is the same thing,
there's no difference, just like there's no difference and there is strictly a qi. So freaking ok, umm...there IS a way to do
this. Potentially there is a way to do this. Then there's no difference and that potential becomes impotential (just like
impotential becomes potential), therefore there is a way to do this. So freaking get cracking dude.

Ok dude, so what if we build a system that is code that builds stuff, so like builds (compliant) code, etc? Freaking what we do
is code this thing...yea from there we could interface the thing with anything. This is definitely what we want, this is at
least what we want. So we code this thing, what this thing does is...ok so we would have to like specify some data, like let's
say for instance...ok how do we get data in there? Freaking umm...what else do we need to build, while we're at it? So we
freaking...compare input with output, so compare input user credentials with stored user credentials...ok so both would be
input, credentials given by a web-form or something would be input, just like web credentials stored in mariadb or something
like that would be input. So ok doesn't matter, anyways: so freaking we check "username && password" against everything in the
database to see if anything matches, so freaking we specify a table structure, or something like that, like a data structure,
then we specify that we want to compare the input with what we have stored in the database, so freaking...ok so like what do we
have so far? We have, at least, a user-authentication mechanism. Now, what don't we have, if that is what we have? We don't
have like protected data...so at least what we would have is some protected data, so lets say an array of data, or just an
array, so freaking ok...so we have a protected array, so freaking ok, so at least what we have is an array, then. So freaking
in that array, we would use something like at least associative keys...so like our array would look like:

array
	users
		0
			username
				Cinder
			password
				****
	pages
		0
			name
				About
...

So freaking ok, this works...it may be a little shanty but it DOES work. So freaking what we have is a simple array of data,
and what we do is loop through that data and do stuff...so what we do is...yea this should work dude. Freaking ok, so at least
what we have going on is we have an array, then we have a view. This view takes the data from this array...so like basically
you could just print_r this array. Extensively, you would have, at least, some code that would do stuff with this array, or
rather with elements of this array, so freaking we have a system where index.php fires off, then it alternates to the array,
then it alternates to another php script, then it alternates to the array again. So it has a pattern and everything, ok, this
is good. Then what? So then like we basically go ok, now how do we extend this array, in all ways? Umm ok, so this would be an
associative array, at least, so freaking umm...so at some point we define the key of an element, ...ok if we use objects to do
this, along with arrays, we can go ok we have an object (an instance of a class), then within that object we have our data
array, then as elements of that array we have other objects...ok so what we would have is a freaking array that we output to
the screen, so basically an array and print_r. Yea, freaking that's what that is. So freaking ok, umm...so that is AT LEAST
what that is, so freaking what is the rest of it? Ok so then we have like type restrictions on those arrays, so freaking...ok
so that array IS an array, so thats it, it can have any values as elements/etc. So freaking what we do is map out an array in
code...so ok the beauty of this is you have an input and an output: you could input plain php code, and your output is
"print_r(array);". So freaking ok, umm...ok so like we would have a master table, that would outline elements of the array.
These would be ordered, and they would "link" to other tables that represented the data of a given element. So each element of
this array is effectively an array, and so on. So freaking ok, umm...so then ok those "other tables" that these things would
point to would have at least a column linking it to another table (if it's an array), or a value. So freaking ok, umm...so like
it would be more potent to use a single table that had a reference to another row or a value. So yea that's at least what that
is. Ok so it's an array, so that's what that is. Freaking a. Freaking ok, make sure you're right dude. So we would have:

array
	array
		any value
		any value
	array
		any value
		any value

Ok so ultimately AT LEAST what this is is a value. So it doesn't necessarily have to be an array, it can be any value. So what
does that mean? So inside php, what a value is is...a value. A value is a value, there are more than one ways a value can be
used (for instance, it could be concatenated or assigned), so that's AT LEAST what that is. So freaking ok, umm...so we have a
value, so that's pretty damned fundamental. Then what? Then this value is equal to "1", and that is it! That's the end of it.
So freaking ok, umm...is that the end of it? What if we have no value? No echo, no return, no assignment, no comparison. No
comparison! We've reached the promised land! If there's no comparison there's no logical processing, there's no freaking...so
ok, what we have is a value! So ok, then we operate on that value based on it's type, so umm...now ok, umm...yea what are the
different types?

"boolean"
"integer"
"double" (for historical reasons "double" is returned in case of a float, and not simply "float")
"string"
"array"
"object"
"resource"
"resource (closed)" as of PHP 7.2.0
"NULL"
"unknown type"

So freaking ok, if we have a boolean...so like basically we print_r an array. Then we just go ok, we have input/output for our
value, so freaking...ok, umm...so what if we just print_r our value? So yea we can just unilaterally print_r our value. So
freaking ok, thats what THAT is. So like the input could be straight php and the output is:

<?php

echo "<pre>";
print_r($value);
echo "</pre>";

?>

So freaking ok, it's rigid. So freaking ok, then what? Then we build this bad boy, from the ground up. So freaking ok, umm...so
then if we build a CMS or something like that...so we store our data as our value via input and output our value. That's it!
That's the end of it. So freaking ok, then what?

So we freaking...we tailor an array and that is our CMS...now, how do we do this gracefully? Ok, so we make the thing so what
is happening is a value is being input/output, so freaking...then we tailor this value (must be unique amongst siblings, etc.),
and so on and so forth, so...what we do is make this all string, then translate to a GUI. So freaking ok, what we do is...then
we have...so then our data is just sitting there, then we want to do stuff like compare the data with itself, for instance to
make sure all usernames are unique, so what we do is...so lets say we had:

array
	users
		0
			username
				Cinder
			password
				****
		1
			username
				Test
			password
				****
	pages
		0
			name
				About
...

Now lets say we wanted to check to make sure username's were unique, at some point. So what we would do is go:

unique(array["users"]["username"]);

or something like that. Now what this would do is...what it's doing that's like second to fundamental is comparing two values.
So freaking ok, then what we do is compare for equality, and if they aren't equal they aren't equal, and if they are they are.
So freaking ok, umm...so like that SHOULD be what fundamental comparison is. Equality. Ok, if we're right if we proceed from
this point it should work. There's no difference. :)

So then what unique does is:
	search through $input
	look through $hay
	return 1 on success, 0 on failure

Ok, umm...huh...so freaking that's what that is. Huh...ok so like we loop through our data and...freaking umm...ok what's next?
So we loop through our data...so umm...freaking...why one value? Because that's not two values. Freaking umm...why does it
matter if it's one or two values? Two doesn't work. Two creates a problem where we can't microscopically control things. For
instance, if we had a function that accepted two arguments, we would have to create a mechanism for setting the arguments
individually, because in syntax we would have to access the function twice to...if you have two arguments you have to change
the syntax twice to change one argument of the function...it takes less syntax to use one. Freaking a. So freaking ok, umm...so
we have one value, for that same reason, then what? So ok then...then if we use an array we potentially have multiple values,
so we account for this potential. So what we do is...we create some peripheral...so fundamentally what we do is I/O for each of
the array elements, just like we did for the single value. So freaking ok, umm...then we filter input...so lets say we filter
usernames to make sure they're unique...so freaking ok...umm...so ok I'm pretty sure all you can ask of a column is that it is
unique...if you compare two values...so freaking that's what that is, is you can compare two values...freaking a dude...so
freaking what you do is...umm...drawing a serious blank...so ok a unique would draw a false when compared to all of the other
values, so it (at least) has to draw something unilaterally...or does it? 

So freaking we have to figure this out dude. Yea that's what that is: cascading logic. So freaking ok, why would you ever need
to compare two of these values? Freaking ok, umm...so ok fundamentally you would have two of these values and you could compare
them, so that is what that is. Fundamentally you would have two of these values and you could do anything you wanted with them.
So freaking that's what THAT is. So yea, if nothing but ulitmately, that's what that is, that is the extent to which you will
use these values. The same goes with having more than one value: ultimately you could have the need to use more than one array,
or in general more than one value. So the best you can do is reduce to one and go from there, because that is the point at
which the generalities of these things apply. So freaking ok, umm...we use one because of the aforementioned...so freaking ok,
umm...so what is...what is the extent of which we compare two of these array elements? So they either would or wouldn't be of
the same column, so freaking umm...if they ARE...ok so they are from the same COLUMN, so freaking umm...from that point on all
there is is for them to be different values. I think. Ok so like moreso the thing becomes...so freaking we could have two of a
kind in an array, so like two rows of a table, so with the same columns/etc., so freaking...or we could have two completely
different values. Why would we...ok so how do we put those together? Or something. So freaking ok, umm...every single thing.
Every, one, single, thing. So freaking ok, lets say we have a single value, this value is potentially an array, which can have
more than one value. So if it is, we treat it in a special way. If it isn't we don't. So what we do is: umm...like ok so rough
what we would do is "filter" the value, so apply regular expressions to string, allow only values so big or so small in terms
of numbers, etc. So we deal with an "individual value". Then, if it's an array, we treat each element of that array (that isn't
an array) the same way, filtering values. So freaking ok, then...ok so when we filter the value we do things like check for
uniqueness. That's what that is. So like we could have a battery of regular expressions the string has to pass through, or
comparisons a value has to succeed, to do what we're trying to do. So ok there is still like the inescapable fact that a value
is either true or false...1 or 0. Ok so the thing is, that value is ultimately 1. So there's no wrong way of doing this. All
that is important is that you do it. That you DO it. So freaking ok dude...

Ok, so we have a value, which is of a type, and if that type is not array...basically we have a value that can be logically
handled. So freaking ok, umm...ok so freaking what if you didn't arbitrarily assign 0? We can arbitrarily assign 1, because it
can be so much as assumed, but 0 we can't. So freaking umm...how would we assign 0? Freaking a dude...so ok you compare two
values...we CAN compare two values...so like that's what that is. We can...umm...so ok like we can set the value of our
variable, so freaking umm...that value can be the result of any...thing...so like ok our input would be string, php code
itself, and our output would be...output...so our output could be anything, our input has to be string? Yea it at least has to
be string. Freaking a. It could be anything. Freaking a. Ok so that's what that is, that there is like no difference between
one and the other. So freaking ok, umm...how could we assign a single 0, without being arbitrary? If it's value is <=0 (a
non-positive number)...that's at LEAST how we do that. Same with a string with 0 length. Like the same thing with an array of 0
length...and freaking with an object with a "count" of 0. And like an empty or closed resource. And null. And false. And
freaking like that's what that is, so what about it? What are you trying to figure out with that information? Freaking a dude.

Ok dude, just build it. When it starts getting bigger it will become apparent what to do; the broader it gets, the less
fundamental it gets, and the more obvious it becomes what path to fundamentally take.

So ok, lets say we had an array:

<?php

$array = [
	0,
	1
];

?>

So freaking ok, now, we can do anything with the values. The question is, why would we? Why wouldn't we take a single value at
a time? The answer is, of course, we would. We would only use one value at a time. It takes less syntax, at least, to do so. So
freaking ok, what do we do with this value? We output it. So freaking also the thing becomes that with two values you have to
account for everything you could do with those values; it isn't enough to generalize THAT. And anyways you wouldn't want two
values. So freaking ok, umm...so ok what is like the regular expression of a value? What if we restricted the value of
something by regular expression? Then the restriction is one thing. So ok what if you had a battery of regular expression,
where like you had a series of values that the value either could or could not be equal to, and...so that satisfies a two-way
circuit for setting the value. Freaking a. Yea that's what that is, freaking what else? So freaking ok, umm...then we have a
hit or miss situation for setting the value, so...then we have to code the regular expression. Freaking a. Freaking a freaking
a freaking a. Umm...ok so we would filter these individual values, then what? Then we still have to specify how to filter them.
Freaking ok, umm...so like we would specify some code, some php code, that IS the filter itself. So freaking ok, umm...freaking
ok, umm...

Freak yea dude, I have no freaking idea how to do this. Freaking umm...freaking a dude...so ok like you would have...some
whitespace? Umm...whitespace? Whitespace what? What would be whitespace? Freaking so your regular expression would start with
cutting out whitespace or something. Something about whitespace. So like the main difference in string is between whitespace
and all else. So freaking ok, umm, how did you figure THAT out? However you figured that out, you just repeat the same process
for every character in an encoding and BAM, extrapolator? So if you can determine how to non-arbitrarily assign a single 0 you
have this thing figured out? There's strictly no difference so you already have it figured out, and have since before the dawn
of time? Freaking a. So like in the english language whitespace is...why is whitespace absolutely whitespace? Or how do you
otherwise do this? Freaking a dude...so ok you're like totally overthinking it. If you just build it, it will all come out. So
freaking ok, you filter input, this is entirely non-arbitrary. Therefore yes you program filters and stuff like that. So
freaking ok, aside from that you're like freaking done. That's all there is to it. It's an array and that's it. So freaking ok,
how do we do this? Aside from filters, I mean is that really it? Just filters and that's it? Yea, like, that's it. And they can
define their own damn filters, dammit. Freaking a. So freaking a ok how could you automate filter production? So ok you assign
filters to a value...so then you...ok so like you have an array-maker. One way of looking at it. Or just basically you have
your code-generator that generates wordpress plug-in's and all that.

Freaking a. So ok if we define what one thing is with regards to a single value, then what? So relatively speaking certain
values are true and certain values are false in php. So that's what that is. Now what? Now you have a 1 and a 0. So why does it
matter how they got there? It doesn't. All that matters is that they are there. So now you have to figure one thing out: 0. If
you can figure that out, you can have it. You can freaking have your extrapolator. So absolutely, what makes something a 0?
Freaking umm, the lack of value. Having 0 of a type of thing. 2. Freaking anything but 1. Does it matter what makes something a
0? It both does and doesn't. So whichever one you want. So freaking ok, it doesn't matter, so then what? So then when do we
assign 0 as a value? Everything has the value of 1. Not everything has the value of 0. So freaking find the outstanding...find
the outstanding values and go from there? Yea what if you do that. What makes a value 0, on top of being 1? If it's erroneous?
Ok so if we just keep building it should just come out, right? So like freaking ok, so we have filters for these values, then
what? Freaking a. I have no freaking idea, but I think I'm done for the day. Peace. Yea I'm out, peace.

Ok dude...freaking umm...ok so what if we have two things and they are both the same thing? Freaking umm...there's no freaking
difference, either way is the same thing. If we go one step further, and we have two things that both reference the same thing,
the thing is one and the same either way. Freaking THAT'S what that is!

So freaking a dude, otherwise, into the peripheral we go! How do we do this dude? If these things are all one and the same
thing, we have, strictly speaking, one thing. So freaking I emphasize one thing. I hereby declare stricture about the treatment
of two things as one. All is one.

So freaking ok, umm...freaking...so there is no freaking difference, so what is the whole gamut when there is no difference?
Umm...hmm...so there's no difference, so there would be a sort of micro-granularity about things; we should just be able to
BUILD and have everything come out functioning. So freaking umm...hmm...ok so the maximum for a webite would be:

input
filter
store
output
...

Freaking ok, so we would receive input, then we would do output. So input is the receiving of any information that is to be
stored or otherwise displayed on the site? What if, for whatever reason, we receive some input that we display on the output
and that is it? We don't store it or anything? It still gets into php, at which point it becomes hazardous, so we have to treat
it as such: it needs to be filtered, at least, and so on and so forth. So ok we filter the input, and at that point it should
be pure (it is, hypothetically, pure). So then we store that data on the server, or somewhere, so freaking ok, umm...and like
that is it for input. Output is where we would tailor the data and stuff...so freaking ok, then on output, we tailor the data
(pre- and append html), and that is it. So freaking ok, umm...:

input
	filter
	store
output
	tailor

So freaking thats BASICALLY what is happening on any website in the universe, a rough sketch. So ok, what happens when we
filter data? Or I mean is this enough to proceed from this point? So freaking ok, umm...so we filter our input, so what this is
is...any filtration of input? So like filtering stuff that could be eval'ed out of input, that kind of thing. So what we would
do is:

...

Ok so freaking like to be specific, our input would be independent, our output would not. So freaking what we do is...our input
does it's thing, then our output is:

input
output
	filter
	store
	tailor

To be like razor-precise about it. So freaking ok, umm...freaking...huh...yea what delineates freaking "filter", "store" and
"tailor"? Why these as opposed to anything? Ok so freaking our input would be php itself, then our code...ok so input would be
a blank php file, output would be a non-blank php file, 0 and 1. Why would input be 0 and output be 1? Freaking umm...so
freaking what we would do is filter our input, so freaking...ok so we filter our input, freaking we don't filter our output, so
freaking because if we did, we would...ok so LIKE what I mean is we filter our input: we filter "input" from users to make sure
they don't do anything wrong or malicious or anything like that with the site. So freaking ok, umm...ok so the filter is at
least equal to the filter given on output, so freaking...freaking umm...so ok the filtration mechanism could be anything: we
both want it that way because we could receive any input, and because we don't want to limit our output. So freaking ok, umm,
ok so reading is input, writing is output. So freaking...or is it? It doesn't even matter, dude. Freaking a. So writing is
output, because we are OUTPUTTING information, like we are writing with our hand. Reading is input, because we are TAKING IN
information, like we are reading a book. So freaking ok, umm...so we would output first (write), and input second (read):

output
input
	filter
	store
	tailor
...

So freaking does this make sense? We freaking read, which is input, which is data itself, so reading, whereas writing, which
is output, is writing data, which is not data itself but the creation of data; going from 0 to 1. So freaking ok, umm...so lets
say we have output and we have input, then for each we have the same thing over again. So our output would be...ok so it
wouldn't matter, it doesn't even matter. By the time that time comes you just flip the labels and it's all good. So freaking
ok, umm...freaking, so you have some output, something comes out of the thing...so like you send some data to mysql, or you
send some data to the browser. Something goes in, and you receive something: data from html inputs or something stored in the
$_GET/$_POST/etc. variables in php. So freaking ok, that's what that is. So freaking ok, what we do is...generally speaking we
only do output, we don't "do" input, someone, or something, else does "input" (in fact our input is the output of something
ELSE, so it isn't us). So freaking ok, that's what that is. So freaking when it comes down to it, everything is input, because
everything is "1", so freaking ok, the "other" thing that is sending us it's output, or that output, inside of us, inside of
me, is what everything is, along with the output (MY output). So freaking that's what that is. Freaking a. So freaking ok, what
we do is code everything, so we have our input, $_GET/$_POST/$_FILES/etc., and we work with that input. Therefore:

input
	$_GET
	$_POST
	$_FILES
output
	...

So freaking ok, umm...hmm...so like ok we have a...ok so we receive input, so (at least) $_GET and $_POST. Now, we COULD also
have $_FILES, so I mean...and for that matter we could have any input? What if we have to read from an input stream? Freaking
a. Umm...:

input
	filter
		$_GET
		$_POST
		$_FILES
output
...

So freaking ok, umm...freaking umm...so freaking we COULD process input AFTER we do output...like if it were a game or
something and we didn't want to display the new data until the page was reloaded...ok if they are each one thing, we just
invoke a function or something like that and whip it up...so freaking...that way we can do either in any order, or, for
instance, one and not the other. Is this what this is, though? Freaking umm...:

input (object)
	filter
		$_GET
		$_POST
		$_FILES
		etc.
output (object)
...

So freaking ok, umm...so yea what if we write an input and output class? Then we objectify the input and output? Freaking umm,
hmm...ok so php receives "input" from the user, then we "output" php code that does stuff with this "input", which php receives
as "input" and "outputs" some other stuff, "based on" that "input". So freaking that's what "input" and "output" is, and I
quoteth. :) So freaking ok, now, what we do is create an input and output class, input before output, and freaking go from
there. So ok, we create two classes, "One" and "Zero", and freaking...receive, filter, and store input with "One" and output
formatted output with "Zero". So freaking ok, umm...so ok we output php code, then that php code receives some input from html
forms, then we freaking...output again, taking that input and doing stuff with it, so it's freaking all output. It's all one
thing. Freaking there's no segmenting it into two things: the two could go in either order, which doesn't work! Freaking a. So
ok then, what is the one order that these go in? 0 before 1. Left before right. Umm...left is up and right is down? Up is 1 and
down is 0? We're all mixed up. We need to create order along these lines. So freaking ok, umm...so freaking ok, if we have
input before output, if we process the output of php before WE output to php (which is therefore input of php), umm...so ok our
input is the output of php, what we read with our eyes, what goes into our eyes. Our output is the php code we create. The php
code we create is the input of php. So the output of php is input of our php code, and the output of our php code is the input
of php. So freaking that's what that is, is...so freaking the output has to come before the input, so freaking...so we filter
the "output" of php, then we code the output of php (with the input of php). Make sense? Therefore we have:

output
	filter
		$_GET
		$_POST
		$_FILES
		etc.
input
	formmatted html

Freaking umm...hmm...so freaking ok, what we do is...start coding? Ok so even if we get the input/output wrong, it would be a
matter of replacing the names, because the two would be split into two, so they would be completely interchangeable. So
freaking don't worry about what one is and what the other is. Freaking ok, umm...:

<?php

class Output {
	
	public function filter() {
		
		
		
	}
	
}

?>

Ok so on any website, you're SURE you're right about this? Freaking on any website, what we do is: filter and store input, then
output formatted output. Freaking a. Freaking freaking a. If you're not right about this dude you are DOWN. Freaking ok, so it
is at least consistent...ok, so now reduce these things to one thing:

php's output
	filter
		filter one thing at a time, so freaking:
			apply a filter (a regular expression?)
			have a failure message
		store
			store one thing at a time...
			$_GET
			$_POST
			$_FILES
			etc.
php's input
	formatted html
...

Freaking ok, umm...so we filter php's output, so freaking umm...:

filter eval stuff
filter usernames by regular expression
	with failure message, explaining what went wrong ("usernames must have...")
...

So freaking ok, what if you come up with a general process for everything? So for every freaking thing? So like you could have
a two-way circuit, true and false, and whenever something is true there is a message (unilateral), and whenever something is
false there is a message. Then, these proceed one by one, and the program runs. Then, so we have a function that runs a
"statement", that runs a statement of code...ok so how do we break everything up into the smallest bits and peices? Freaking
umm...hmm...so like we freaking have...some code...so basically we would have errors: errors when there are syntax errors,
errors when there are otherwise errors. Freaking ok, then what? So we generally run php and we're all good, errors are all
taken care of and everything, so freaking...umm...so ok like what we have to do is program a main system for doing everything.
So we go back to the point of: what comes first, input or output? So freaking ok, umm...the output of php is the "php
environment", or the running php. So freaking that includes the $_GET and $_POST variables. So freaking ok, umm...what if we
code the thing and make sure to keep it all broken up into single pieces? Freaking a. Yea that would work, just like anything.
So freaking ok, umm...freaking a dude, there's like absolutely no easy way to do this. So freaking ok, umm...so ok whether we
call it input or output, php's output comes before php's input: the running php environment comes before our php code. The
GET/POST variables exist before we do anything with them, that is what that is. So freaking ok, output comes before input, 0
comes before 1. Yea, that's what that is. So freaking does it matter? Does it even matter anyways? It doesn't do you any good
when things don't work when there are more than one thing. Freaking a. Ok so what we do is generalize filtration, storage, and
output. So freaking in general, what is a filter? In general, what is something? So in general, something is a filter, storage,
or output. So freaking ok, umm...what is something when it is a filter? So freaking ok, umm...so like...umm...freaking someone
is such a slob dude. Freaking slob. Not even freaking bad, just freaking slob.

So freaking ok, umm...in general, what is a filter? So what if we filtered something based on whether it was unique or not?
What if we filtered something to make sure there wasn't more than two of them? So freaking if there isn't a slot for the
input...so freaking ok, umm, what that is is anything goes, at that point we would just have some php code and that's that. So
freaking ok, umm, are you SURE that's what that is? Like, what that would be is a regular expression that the subject had to
match to pass, and what we would do is otherwise load these regular expressions, each accompanied by a failure message. So
freaking ok, umm...so that's what THAT is. Freaking umm...freaking a...so yea like that's what that is...so freaking a filter
is...freaking storage...umm...

Ok so freaking the user input would be inside php's output, it would be OUTPUT by php, it would be output by php into current
working memory for access while php runs. So freaking ok, what that means is...if we don't code anything in php, freaking there
is NO php code, freaking there's an empty file, or just php doesn't "do" anything. There's no difference. Freaking nothing. If
there is 0, we have pure php. And within that pure php we have the GET and POST variables. THAT, my friend, is what that is. So
if we program a php script of 0 length, that is a 0, so freaking that is what that is, is at that point the freaking output of
php exists, whether that is a 1 or not. So freaking that is what that is. Freaking ok, it SHOULD hold. Or, I mean, the logic is
consistent anyways. So freaking ok, this means: we should be able to concentrate all filtration and storage in the first half
of the script, and all output in the second half of the script. So freaking ok, umm...so that is what that is. Call it for the
day? Freaking a dude...

Freaking a, I'm freaking back, freaking a. So freaking a, freaking a. Freaking a. Freaking a. Freak. So ok the way this would
work is...there would be like a freaking thing that would take in data, so freaking ok, umm...so like EXACTLY what would happen
when we ran a website?:

index.php
	process input
		filter data
			filter eval statements
				store data
	process output
...

So freaking I mean is this going to work dude? What if it doesn't? There's no difference. You might as well go for it. Freaking
if it doesn't work you are so fucked. Fucked. Fucking ok dude, how do we do this? Freaking ok there's no difference, so we just
go for it? I mean yea, that's naturally how that flows. There's no difference, so we might as well go for it, or we just go for
it. Freaking ok dude, is this logical? Indifference is logical. There is no difference in, and there is no difference out. So
in a circular there is no difference. We asset the indifference, and then the indifference comes around the bend. Freaking ok,
figure this shit out dude. So freaking if there's no difference, what keeps us from going to hell when we commit? Freaking
umm...so freaking ok, umm...so there is no difference, now within that indifference, what if you do something...conditional?
Like what if you do something then that is...conditional. You do something, one of two things, ...do you just do the one that
is true? And freaking bite the bullet? Or do you take some other...ok there's no difference, so we're that far in, so from that
point on...does there just have to be utter indifference? You already know this dude, you know that either way it comes down to
"1". So freaking ok, what is it to take one of two paths then? There's no difference, so it doesn't matter whether you go to
heaven or to hell. So is there a way to go to heaven, instead of hell, then? Is it merely a matter of commital? Umm...
freaking...so freaking ok, umm...what is a freaking...ok so there's no difference, then there are two paths. There is still no
difference. So freaking ok, umm...there's no difference. So what you definitely do is just hang in there and go where you go
dude. So freaking ok, if there are two paths, there is one path: indifference. So there are no two paths then, there is only
one path. Indifference. And that is what that is. So if there are two paths we take the one path? If there are two paths, and
one of those paths is the one path...both of those paths are one path then. So you take the one path, either way, and that is
what that is. So you may go to heaven, you may go to hell, there is no way to control it? So freaking ok, which path is the
greater path, that which leads to heaven or that which leads to hell? Whichever you "choose" as the greater is the path that is
the one path that both paths are. Dude find your freaking way through there dude. Freaking which is the greater path, the path
to heaven or the path to hell? There is no difference. So which one would you RATHER go to? Heaven or hell? Ok heaven is BETTER
than hell. So heaven is BIGGER than hell, or GREATER than hell. So freaking that is what that one path is, is it leads to
heaven.

Ok so how do you know that heaven is BIGGER than hell? One way of answering this question is by reflecting on life. We are
alive. We are not dead. It could be worse, we could be dead. That would be worse than being alive? Is that worse than being
alive? Good question. Does one want to be alive or dead? It seems that death is much easier to acquire. But is it the better or
the worse? There's no difference. There is fundamentally no difference between any two things.

The answer to your question is that of an answer to a trick question: the question is a trick question because there is no
difference, so there are no two paths, and therefore the answer is indifference.

So freaking thats what that is dude...huh...weow. So freaking chill out, do whatever you want dude, you're totally going to
heaven. You totally found your way in there.

So thats what that is dude, utter, indifference. Freaking good deal dude, call it a night.

So ok dude, so you filter input, store it, and output. Freaking when you filter input, what you do is...:

filter
	run input through a battery of filters
		"Filter" class?
			$filters array with "Filter"'s?
				each has a
					regular expression the input must match
					a failure message if the input doesn't match the regular expression
store
	"Storage" class instance(?)
		store file paths in mariadb?
			if filenames are patterned, what if an anomolous file exists?
				so (at least)
					store file paths in mariadb (or some other database)
					store files themselves in the filesystem
						this would include
							text
							rich-text
							any other files (images, videos, etc.)
output
	format data with 
		prepended html
		loop through php data
			prepended html
			php data itself
			appended html
		appended html
	output data (string)

So freaking ok, what we (sort of) have is:

One
Zero
Filters
Value
Cinder

?...ok so freaking for every value, you need to filter that value with a battery of filters. Then, if there are any errors, you
need to properly trigger errors (display error, die, etc.). So freaking ok, then we have values, then we have...Cinder...which
filters input (filters input "values"), stores that input/etc., and outputs formatted string to the browser. So freaking ok,
umm...so how does the above short-circuit? One is constant, basically, because all it has is a constant with the value of 1.
Zero can indicate whether the whole tree is zero or not, and that is about it. Filters...so freaking then we would have values,
ok so like would we have Zeros? Or just Zero? Because zero is up the chain of heirarchy one from one. Freaking umm...ok so at
that point everything would be interlaced, so you have to figure out exactly, EXACTLY, the order everything goes in at that
point. Freaking a. Umm...

So ok, I was thinking and if the freaking thing has filtered values, it's basically good. So what we do is...yea this makes
sense, because everything revolves around values. So freaking ok, umm...freaking...so at LEAST that is what that is, so then we
have storage, which stores these values, so freaking the filtration is handled by php...why not fall back on mariadb's unique
filtration? Why not include that, and everything else along those lines, as filtration? Yea I mean that makes sense...so how do
we integrate the two? Umm...so like we would have a database of stuff that mariadb can handle in terms of filtration, then we
would have a database of stuff that php can handle in terms of filtration. What is the simple answer to this, though? PHP is AT
LEAST the filtration mechanism, overall. So freaking ok, umm...how do we code this without freaking "reinventing the wheel"?
Umm...well, huh...we need to generalize everything, so like Value has a get and set, and Filters has gets and sets, so like
what we need to do is bottleneck the whole process at some point. So freaking ok, umm...:

One
	public const One = 1;
Zero
	public const Zero = 0;
	public $isZero:boolean = false;
Filters
Value
...

So ok already what we would need to do is filter $isZero in the Zero class. So freaking ok, umm...so what we do is like code a
freaking super-structure...so like freaking what we would do is...code a freaking...this is badass dude lol :)...so like we
would code some kind of value class that would hold a single value, and this value would be filtered. Then we would code...so
what we have so far is:

One
	public const One = 1;
Zero
	public const Zero = 0;
	public isZero:boolean = false;
Value
	filtered $value

Then, every value we use is a filtered value. Pure, filtered values. So then we just have to filter everything correctly and
we're good...at least. So freaking ok, umm...lets code this so far.

So freaking ok, I've been coding this thing, and so far so good, just I think it's gonna take some tom-kinkery before this
thing is fully functional and all that. It works, just it's got some weirdness to it: if you add multiple filters to a value
(or multiple values) it has to reference itself from within itself. Not the most elegant thing, but I mean it works? Anyways
I'll be working on this all week so something should definitely surface as far as this kind of stuff in concerned. I think I
MIGHT call it a night, but really I only have about half an hour to go, so I might just stick it out until I get there. Maybe
just call it early just to end it for the night, I can make up for the time tomorrow...I'ma call it. Night! :)

Ok dude, freaking a. Now what? Freaking code this bad boy? Ok so lets make another run through some pseudo, what exactly
happens when this thing runs?:

index.php
	check GET/POST variables for what to do
		empty?
			check credentials
				input
					filter
					store
				GET/POST empty?
					output
						run the page with default settings
						run the page with the given settings

...

ok so we run index.php
check SESSION(?) for user credentials?
	user logged-in?
		user logged-in
		destroy user SESSION data
before we check credentials we process GET/POST data (we have to log-in a user before we check credentials, in cascading logic)
	check for user credentials?
		log in
		
before we check credentials we log the user in if credentials supplied
we then check credentials (priveleges)
...

Ok so what if...we have a user logged in...ok so freaking like what we would want is a system based on one thing, so that when
the thing shoots off it goes ok, there is ONE thing down there, so everything that happens up until that point is one, so like
freaking ok, everything happens in a cone, so freaking at the top there is an array of data, at the bottom there is a single
value...so like we would have a "Value" class with a value, and that value would (probably) be an array, and then the elements
of that array would be other values, or other "Value"'s, so freaking...then...ok so this WORKS, just its kinda funky. The thing
is...would you just want to hard-wire an array? Naa don't do that, that's not that fundamental; make it a freaking value dude.
Make it that way and get that shit done. Then, freaking ok, so you have a value, then you assign that value, so freaking ok,
like freaking what you would do is...at some point assign that value as an array, so you would have to handle types gracefully,
then you freaking go ok, so you...like basically what you want is an array with a filter on each element of the array. So
freaking ok, umm...now what we do is make every single thing a single thing, so we have to figure out what a single thing is.
A single value is a single thing, then a single character is a single thing, so freaking like a single character of string is a
single thing, when it comes to the php code itself. So freaking what we have to do is code everything all the way down to that
point for this thing to come up right. But, does it really make sense at this point? Freaking umm...so freaking ok, umm...so
like we make a structure for dealing with arrays. We make a structure for dealing with one or more values, or, technically
speaking (since we can represent more than one value with an array), a single value. So freaking ok, umm...so at some point we
assign these values...so freaking ok, umm...so we have a single value, then we code all the peripheral...:

value
	filters
		regular expression
		error message
		anything else
	storage
	formatting

So ok, what we have is a thing that has like the capacity to extend as far out in the distance as it wants to, so freaking...
like this doesn't make sense. At some point the thing has to cave in on itself and become a single thing instead of a bunch of
freaking potential. So freaking ok...so freaking one thing, infinite potential. That's likely what that is. Freaking a. So
freaking ok, there's no point to like...ok so how do we code one of these things? Freaking umm...so like we go...so ok if we
were to code a thing that was completely extensible, we like have a thing that is one and has infinite potential. So freaking
ok, what THAT is is...freaking...hmm...so ok...at some point there would BE a value, or there would be no freaking...like there
would be AT LEAST a value. So freaking ok, umm...so there would be a thing that writes, and a thing that reads, and these would
be a part of one thing, and freaking these would be completely extensible, so at that point what you would have is...as long as
everything is all broken up into single things, this should just naturally follow? I mean ok, umm...it like freaking works
anyways. The only reason to break things up into single things is for outward compatibility. For inward compatibility, there is
no freaking limit. So freaking ok, umm...so we would want things to be inwardly, and not outwardly, compatible. So freaking ok,
how do we make one of these things? Like ok how could you make it write, then extend that behavior? So you freaking make it
write, then you take that and go...just DO whats more fundamental to the thing, so like write a value, then write...so like you
have a freaking value. That's totally what that is. You have, simply put, a value, then you have a bunch of OTHER stuff that is
dependent on that value, so all of that freaking sways in the wind, the value does not move. This is because this value is
where you drew the line in terms of things being one thing? Umm yea I think thats it. Freaking a. Wow dude. That's mighty
freaking fundamental.

So freaking ok, off the top, how do we build this thing? So freaking we have a value, then everything revolves around that
value. Now, short-circuit it. Do we have a value? We have a "1". Freaking a. So freaking we have to relate all of that to a
"1", so that's what that is. So freaking ok, how do we do this? So what would generally happen is we would have a "1", then we
(might) have a "0", and what we would want to do is not have a value of "0", so like what you have in terms of this like
freaking works, if you don't set $isZero to true, or 1 rather, and therefore set it to 0, you have a functioning system. So
like freaking we would have...:

<?php

class One {
	
	public const One = 1;
	
}
class Zero extends One {
	
	public const Zero = 0;
	
}
class Int extends Zero {
	
	private $value = One;
	
	public function __construct($value) {
		
		$this->setValue($value);
		
	}
	public function setValue($value) {
		
		$this->value = (int)(bool)$value;
		
	}
	public function getValue() {
		
		return $this->value;
		
	}
	
}

?>

...so freaking ok, then we have a freaking working system with a "1" and "0" constant, and a variable that stores a current
setting ("1" or "0"). So freaking ok, umm...try and run this thing. So here is the "working" code:

<?php

class One {
	
	public const ONE = 1;
	
}
class Zero extends One {
	
	public const ZERO = 0;
	
}
class CInt extends Zero {
	
	private $value;
	
	public function __construct($value = 1) {
		
		$this->setValue($value);
		
	}
	public function setValue($value) {
		
		$this->value = (int)(bool)$value ? self::ONE : self::ZERO;
		
	}
	public function getValue() {
		
		return $this->value;
		
	}
	
}

?>

So freaking ok, umm...from this point we further extend this behavior, so freaking what we do is...freaking...dangit...so like
our value should be "1"...everything else should dance around that point. So freaking ok, umm...yea dude that's what that is...
THAT'S what that is, is freaking you make the thing entirely consistent, define your value as "1", and then build everything,
thus, around that. Lets do it:

<?php

class Value {
	
	public const VALUE = 1;
	
}

?>

Untested. Freaking a. Now freaking ok, umm...so freaking what is a "value", other than that? Not a constant! So freaking ok,
that's what that is. So then freaking we have a variable...fundamentally what we would have to do is define a "0", so lets
define that as a constant:

<?php

class Value {
	
	public const VALUE = 1;
	
}
class Zero {
	
	public const ZERO = 0;
	private $isZero = ZERO;
	
	public function __construct($value = 0) {
		
		$this->isZero = $this->setIsZero($value);
		
	}
	public function setIsZero($value = 0) {
		
		$this->isZero = $value ? self::ONE : self::ZERO;
		
	}
	public function getIsZero() {
		
		return $this->isZero;
		
	}
	
}

?>

So freaking that accounts for a two-way circuit. So now we would want to...so ok do we have a "VALUE" or do we have a "ONE"?
ONE:

<?php

class One {
	
	public const ONE = 1;
	
}
class Zero {
	
	public const ZERO = 0;
	private $isZero = ZERO;
	
	public function __construct($value = 0) {
		
		$this->isZero = $this->setIsZero($value);
		
	}
	public function setIsZero($value = 0) {
		
		$this->isZero = $value ? self::ONE : self::ZERO;
		
	}
	public function getIsZero() {
		
		return $this->isZero;
		
	}
	
}

?>

So freaking ok, emm...so then we have like variables, so we would need a "variable" class and "set" and "get" methods...:

<?php

class One {
	
	public const ONE = 1;
	
}
class Zero extends One {
	
	public const ZERO = 0;
	
}
class Value extends Zero {
	
	public $value;
	
}
class Input extends Value {
	
	public function input($value = self::ONE) {
		
		$this->value = $value;
		
	}
	
}
class Output extends Input {
	
	public function output() {
		
		return $this->value;
		
	}
	
}

?>

So freaking then we have variables...or a variable, rather...so ok, then...so one thing at a time...so freaking ok, umm...so
THAT is like highly fundamental. So freaking ok, umm...then what? Ok so then we freaking...extend this further with some other
stuff, so like freaking umm...so like ok what if we break our pseudo down to this point? Freaking a...:

filter
	filter individual values
		filter straight php values or string(s)?
			straight php values means you have to code individual filters
				for example, if you wanted to filter an array you would have to code to filter multiple values instead of one
			string you filter with regular expression
			either way you have to code multiples
		so what we do is...
			output
				write filters (individually, by hand, if necessary. The worst of it.)
				generate filters
			input
store
input
...

So ok so far what I have is:

<?php

class One {
	
	public const ONE = 1;
	
}
class Zero extends One {
	
	public const ZERO = 0;
	
}
class Value extends Zero {
	
	private $value;
	
	public function input($value = self::ONE) {
		
		$this->value = $value;
		
	}
	public function output() {
		
		return $this->value;
		
	}
	
}

?>

The only thing is, at this point, you would filter input at the point you used the "input" method of the "Value" class. So
freaking like before you had "Value" you would have "Filter"...and then what you would do is...like...write some functions for
filtering the value of input, so freaking...another way of filtering is to create classes for values, so those values have to
be internally processed by those classes BEFORE they are output. So freaking what we end up with is a way complex thing...ok
what if...what if...what if you filter by type? Umm...huh...so like you filter an array, filtering every element, individually,
and the whole array is filtered, and like it's a recursive process where you filter...so like what each of these array elements
would be is an instance of a class, and that class would have like a value and filters, and then would filter the data
accordingly, so freaking...ok in plain english:

one
zero
filter
value

...would you have one and zero? Why would you have one and zero? You really don't have a reason why, at least not for Zero. One
is what it is whether you like it or not, so there's no point to having this, really. So what you have is:

filter
value
output

So freaking ok, we filter values...how do we do this? What if the value is a resource, do we filter it? Does it mean...like it
means we have to translate everything to string, then filter that string via regular expressions. Now ideally this goes all the
way down, so like we would have a way of defining arrays and stuff with pure string, which makes sense. That way...huh...so
like what we have to do is bottleneck a value. So freaking ok, umm...how do we get a resource in there? Once we do, how do we
translate a "resource" to a "string"? Do we need to do this? Well, yes, because we need to translate everything to string. So
freaking EVERYTHING. So ok, umm...this may be a lot harder than you think! So pretty much things translate to string pretty
readily, so like...ok so like if a resource is some abstract entity, somehow we have to translate that to string, so at least
for now it works to just go ok, if you're going to use a resource its YOUR JOB to ensure that it is represented accurately,
within this system, as string. So any special characters, etc. need to be translated correctly, ON YOUR OWN TERMS. Now, this
gets us so far, but we still need to "permeate" the boundary between abstract and string. So freaking ok, umm...what is a
resource? So freaking ok, umm...resources are like the one spot where it's kinda hard to translate to string...so freaking ok,
umm...so if we translate the php code to string, we directly have the php code, then it's like ok at that point that is where
we have to bottleneck everything, because if we have resources (or some other "special" entity) we have to somehow account for
the string that represents this entity. So freaking what that means is this "special entity" can be anything, so freaking it
could be a mysqli object, a file handler, anything, and we have to deal with that "special entity" with some sort of string, so
what that is is AT LEAST php code. So freaking ok, umm...so we back it up one to the point that we have pure php, and
freaking...thats string! That's one thing! Or what? Int? Umm...so ok the only point where the thing is one thing...dangit...
freaking ok so what does it mean if the thing is one thing? That it's all in one namespace? Fuck dude this is going to freaking
be so hard and take so much time. Eat some damn cereal dude.

Ok dude, ate some damn cereal. So freaking ok, umm...so like do we build this thing up and see what we get? What we need to do
is like build it up to the point that it pokes it's head out, and then build the rest of it. So freaking ok, like, no light
escapes the fact that this thing is "1"? Do we have a value, what do we have? So ok in general there would be like functions
and stuff running and those are each one thing, so freaking I figure that we are "like" doing stuff with values, or a single
value, and that's what code is, otherwise there's no point. Like if we have no input, is there a point to having code? There's
no variability, no variable to pass to a function. So freaking ok, umm...so consider this: what if you HAVE to pass a variable
to a function? Then you MUST have a variable, and thus some sort of value. So freaking ok a php script is...ok so a function is
"PHP code", I quoteth from the PHP documentation, so freaking if we just plain have some "PHP code" then what? Then we have the
same thing, at least, as a function, where we can pass...ok so we can have input and output in php. So freaking input is
variables from some kind of input (user input, for example), so freaking ok umm...thus there becomes the purpose to coding. So
freaking ok, umm...freaking umm...ok so what is something, in php? It's a value. It's at least a value. Then beyond that it's
a specific value. Then, when we finally get there, it's 1 ("1"). So freaking umm...ok, we like, freaking...so ok, if anything,
we have to pass functions "values". Values. So freaking ok, that means at LEAST what something is in PHP is a value. So ok,
from there, proceed. So that means that something in php is a value. And then that value is 1. So freaking ok, proceed from
that point. So freaking ok, we have a value, now what if that value is a resource? Umm...so like there's no reliable way to
represent a resource as a string: if that resource is a filehandle, to a readable file, if we were to represent...you know what
like this isn't the way to do this, the way to do this is pure php, because that's what the string, ultimately, is. So freaking
ok, umm...so then the only reason to do this is to generate php. So freaking in these terms, what do we do? Or is this even the
question to ask?

Ok so big and fat break it on down dude. So if you don't have a value, you don't have anything to do in php...even if you call
a function in php, like phpInfo, that returns a string, that is a value. So freaking that's AT LEAST what that is. So freaking
ok, umm...so how do you go from there to 1? So ok what if you define at LEAST what 1 is? So it's at least true. Now what does
this mean in terms of coding this thing? Or how do you go about this? Freaking umm...so like...you freaking...like you freaking
go ok, whatever it is, it bottlenecks, so we define a bottleneck, then another, until we finally reach the main bottleneck,
then we just translate everything. So freaking it bottlenecks at 1. That's what that freaking is dude. The rest of it is
completely, horribly, relative. So do you freaking want to code this thing or what? That bottleneck isn't before 1. That's for
freaking SURE!

Oh freaking kay...so I mean just translate everything from that point on! Ok, umm...hmm...so freaking what does this thing do?
It does freaking everything. That's AT LEAST what it does. So freaking a. So I mean what is the freaking point of coding this
thing? Like ok, what if you code a structure that can fundamentally handle anything, successively? Like a perfect freaking
system. So ok, umm...how the hell would you do this? Well, everything would do something just like the thing that came before
it. So freaking ok, umm...should we just code the thing? Freaking umm...huh...so like ok if we code our system for handling
websites, how does this thing integrate into that? Umm...freaking...ok so like what comes to mind is we would have a recursive
array of files, and we would store the array structure/file paths to mariadb, then we would draw this up...so what if you
sketch this up and develop it? So like we would have a value that was the contents of a file, then we could filter...how would
you store...huh...ok so at the point at which we have sensitive data like usernames/passwords and files, we have string, so at
that point we can program these things accordingly...so freaking umm...like freaking a dude...ok so now it's all string, now
touch it down to the core of the thing. So freaking what we would have to do is translate 1 to string. So freaking umm...ok so
if everything is string...then everything is a file...umm...huh...so like we go ok, we have string, then we...so like we have
string in, now we just need string out, so freaking we...create an output that output's some string. Then just develop the two
sides? Ok so everything would be string, and everything would be inside of php. So freaking then, AFTER that, we do stuff like
store data to mariadb/files/etc. So freaking ok, umm...then we can filter that string with regular expressions, BEFORE we do
stuff like store it, and so on. So freaking ok, umm...so like ok if we have a string, "1", and we translate to an integer, we
end up with 1, our core value. So that defines the process by which we do THAT. Exactly THAT. Hmm...

Ok so what if...so like what we have is a recursive system, I think it works, because we're inside a php "file", and everything
would be made of files. So freaking we can run php files. All string too, good as far as a console or anything is concerned.
Ok, so from this point how do we proceed? I mean yea, it's all string, which is good, and works just fine, just it's still
relative. The thing is relatively string, it could be freaking anything? Numbers, anything? Well like it couldn't be numbers,
easily, because numbers don't translate to code so well. String does. String is. So we have string...do we have any sort of
structure or anything for this string, or is it a blank php file? :) It would be a blank php file, because it would (still) be
extensible, in that we could code it (inside of here, and we're still inside of php, hypothetically). So freaking that is what
that is. Beautiful. That is beautiful, dude. I mean it. It fits right in there.

So freaking ok, umm...now code it? Umm...so if you code INSIDE of this, you end up with like escaped string. Then you like
unescape the string and...run it? It's string, it doesn't necessarily parse as php. Is that what you would want? For it to
parse as php? Umm...it would be unparsed string. So we don't want it parsed as php. We want, and have, just the straight
string. So freaking ok, umm...huh...so then we code the thing. So freaking either we dig deep, or we don't. If we do, we strike
the mark, if we don't, we don't. So freaking dig deep dude. How can you make string go all the way from there to the other end
of the deal? Huh...freaking umm...damn. Yea what is that anyways?

So like what that is is...

Fuck what that is. Who cares what that is. Fucking what this is is a big ol' headgame. Freaking grr...so like we have some
string, so then we just do stringular stuff with it, so like filter it with regular expressions, etc., and what we come up with
is a functioning system...ok, so freaking...umm...like ok, umm...what we do is freaking...ok so we touch it down dude, one,
tiny little thing, the smallest thing, and we're DONE. The MOMENT something touches down we're done dude, it's all just a
relative mess from there, to be sorted out and put to an end, AT LEAST. So freaking ok, umm...so we have some string, then
what? Then we have like, freaking...just freaking touch that thing to the ground dude. One little touch.

Ok, so what this is, or would be, is...a bunch of string to and from mariadb, files, etc, that would be handled by php such
that: the string is filtered to perfection, fed into and out of the appropriate inputs/outputs, and that is about it. So
freaking ok, what we would do is...feed...freaking ok, we would take some php, and come up with some string and stuff...so lets
say we're going to mock-up our mariadb tables and stuff:

Cinder
	Users
		User
			Username
				Cinder
			Password
				****
	Pages
		Page
			Name
				About
			Table
				Content
					"Cinder is..."
		Page
			Name
				Portfolio
			Table
				Clients
					Client
						Name
							ECJKD
						Description
							"Eric Carr needed a..."
						Screenshots
							Screenshot
								thumb
								full
		Page
			Name
				Contact
			Table
				Content
					(Contact form raw html(?))

So freaking ok...everything is relatively stable until we hit the point at which we need to define the tables of a given
plug-in. Freaking so...freaking a here we go...I'm down though. Ok dude, freaking a...

So freaking we build a plug-in, and we have to create a "wrapper" for that process, so as to generalize everything (as much as
possible). So freaking ok, umm...so freaking like what we do is...create table definitions...ok the way these work, inside and
out, is that they are arrays. So freaking what we do is define an array structure, so add a filter to an array, and go from
there. So freaking what THAT is is...we create an array that maps out the "array structure":

Webpages
	Webpage
		Name
		Structure
			Column
			Structure
				Column
				Column
				...

So freaking what we do is...come up with a way of coding these things, and press them out like freaking pop-rocks. We don't
have to interpret XML or anything to do this: it can all be straight php, and we're inside of php (technically speaking), so
it's all good. So freaking ok, what this is is...ok! So I think I know how this would work. We're inside of php, so we COULD
include other php scripts that further detail the structure of these things, so we COULD, bottom line, just hand-code them.
Beyond that, what we do is...so we define...ok so we could ALSO have files, and any other strings, so freaking then what do we
do? Like then we have to freaking look at this like we're inside of a black hole or something. So freaking if what we have is
string, basically only string functions apply to what we're doing. So regular expressions, string splicing...like basically
what we would have is splicing. So freaking ok, make some coffee dude, lets go.

Ok so like we would have a string, so we would have a stringular value, or a value with a type of "string", and...or rather we
have a...yea no thats right, we would have a string value, so we could assign that value to something or whatever, at least
temporarily, and...basically splice that string. The only thing is you have to store the value somewhere to splice it. But, if
you do store the value, you still have the value, so you CAN do this, at least! So ok we have a string value, now, we could
pass this value directly to a splicing function and splice it, at which point we could make the string bigger or smaller in any
way, shape or form. So freaking ok, umm...so what we're looking for precedes PHP, even the interpretation of a file itself. We
have pure string. So freaking basically we have the value and splice. Then we can do anything with the string, ANYTHING. So
freaking ok, from there where do we go?:

string
splice

So freaking ok, umm...then the rest of it is all peripheral. Which fits beautifully with our model in which everything is "1"
and the rest would be peripheral. So freaking ok, we have the string itself, so we store it somewhere, slap on a splice
function, and call it a day. Or what? So freaking ok, what we do is...ok dude if you're freaking right, this is going to work!
Fuck yes dude, that totally wasn't hard at all. Completely reasonable. IF you're right. So freaking ok, we code some string...:

<?php

class String {
	
	public $value;
	
	public function splice($offset = 0, $length = null, $replacement = 0) {
		
		$value = $this->value;
		$value = substr($this->value, , $offset);
		$value .= $replacement;
		$value .= substr($this->value, $offset);
		$this->value = $value;
		
	}
	
}

?>

So freaking thats what that is. Freak yea dude. From there you just code everything, so like inside Cinder you code...like you
have an extension, "Fractal", which is your thing for coding plug-in's on the fly, then you code Cinder with this thing, and it
presses out some php, and you fire off that php and all is well. So freaking ok, hmm...now, can you "see" beyond...can you
"see" beyond that point? Do you even WANT to do this, or are you just doing this? Freaking I want to do this, I'm just
freaking...ok, so freaking...so fricking a dude, umm...so ok how this goes is: you would have a system of string, and that
string would primarily be the running php (we're, still, in php), and we would have some strings we would want to store on the
server, and the code that would do that would be written in here, in php, and would be string. So the whole thing is string,
inside and out! Freak yea dude! Way to go dude! Freaking ok man, now what? So ok, as you can see above, then we would have
something like a String class that would define a string with a splice method. So freaking ok, umm...what we do is...so ok
primarily this string would be php code, not that that matters, primarily, because we simply "have" the string, but at some
point that string COULD be interpreted by php, so as to run it as php code. So freaking ok, umm...

So freaking a, we would have some string...now what we would do with that string would be...well would be like, ok so lets say
we were going to interpret that string as php, we would have, basically, a function for doing that. So lets say we were going
to store that string on mariadb or something, we would have functions for doing that. So what we have to do is generalize these
things, so like, umm...so what is the maximum that we would do with this thing? So like, lets say, for example, we want to
make our code generator plug-in maker thing. So we code Cinder (with string), then we code Fractal (with string), and that
generates code, so ok...yea this code would be string, then freaking...so ok specifically, we would have string at the point at
which we were sending/receiving something from mariadb, so freaking ok, or even the filesystem, so freaking ok, it's all
string! Yea well it's all string before that point, before we even code a single thing. So, specifically, an empty php file is
all string. Ok! So freaking ok, umm...dude PLEASE let this work dude PLEASE! Freaking a I'm excited! :D Yay! Freak yea dude, so
then ok, we just code this thing, then we break down the general bits and pieces of it and freaking flesh out the final thing,
then build it! Freak yea dude! Freaking a! Holy freaking shit if this is it dude I am freaking STOKED! Thoroughly stoked!

Freaking a! Ok dude, how do you build this thing? How do you get from point a to point b, freaking keep working on that shit
and working on that shit dude, until you freaking GET THERE! Dude if you get there you fucking GET THERE!

Ok dude, so at least what this would be is a freaking php script that would generate mariadb and such for certain definitions.
These definitions would define tables in mariadb, as well as filters and error messages for those tables. So like we would
define filters for columns in mariadb, as well as error messages (if those filters aren't met), and that's what that freaking
is dude. So freaking ok, umm...so what if we extend the definition of this thing to the point that it includes webpages and
websites, and beyond, so freaking it's one all-inclusive system? Frick yea dude! So fricking ok, so if we were to hand-code one
of these things we would code the mariadb tables, then we would code a layer of filtration for columns of those tables, then
like thats it! So freaking filtration and storage. So fucking ok, umm...fuck yea dude! Fuck this better work, fucking this
needs to work so freaking hard! SO freaking hard! Ok dude, freaking a, so what we do is...so we have some PHP that generates,
some php? Umm...like all it needs to do is get data into mariadb, filtered, and then get that data back out. So freaking ok,
umm...how do the filters work? So like freaking ok, the filters would be like, they could be mariadb's built-in unique filter,
then they could be regular expressions for each column. So like freaking ok, umm...so what we have so far, in pseudo, is:

filter
	filter data based on regular expressions
		where are these regular expressions stored?
			they could be stored in mariadb
			they could be hard-coded into php
				if we build standalone plug-in's with this thing for things like WordPress...
					so they are at least hard-coded into php
						then, they are at least stored in mariadb
							then, they are like hard-coded into php
								so freaking they can be generalized in php to begin with, I think!
									it's all string, one way or the other, so we can do this
		on failure, output onFailure message
			where are these messages stored?
store
output
...

So basically, just build the damn thing. Like ok, so you have a thing that builds these things...this thing would be like
Cinder, then freaking it would be an extension of Cinder or something like that, and what it would do is build these things...
either standalone or otherwise, so freaking...umm...ok so freaking this thing would be all over the place, so like what it
would have is the capacity to have tables associated with rows, so a single row could have tables listed underneath it (and
only it!). So freaking ok, then we start getting into the zone of having seperated data, where the data is seperate from each
other, so freaking...so like ok, this freaking data, lets say this data is "01", now the 0 will NEVER be a part of the 1. We
know this because if this data is constant, there are two characters, "0" and "1". So freaking ok, umm...what this means is we
can take this data and put it in like a cone and deal with it with like conic functions and stuff like that, so freaking what
that is is...so like at the point at which this becomes so freaking complex...what if we wanted to associate the two of them
with one another? We would have to relate the rows. So freaking what that is is...like freaking code itself. Relating two rows
is freaking some hard-coded code: you'd have to retrieve the rows, then you'd have to relate the data. And, in the end, what
would this be? Two seperate rows. Freaking a. Like freaking ok, umm...so if you didn't change the data you would still have the
two rows, just you would have some glue (code) holding them together. So freaking ok, like this makes no sense, because if you
freaking did this with all of your data you'd have a freaking big, gluey mess. But, some people might be down, and it IS a
thing, so lets freaking account for it! So what you have, then, is association of rows to columns and to rows. So then we have
tabular data, which is two-dimensional, so then we have tables, and freaking thats that. So thats what that is is you can
relate rows to columns, and you can relate rows to rows. When would you relate a row to a row, though? Let's say you were
comparing two rows, to see if they had the same value of a column. Yea that's what that is, that's when you would do that. So
you WOULD do that. So freaking ok, umm...hmm...freak dude I'm freaking exhausted...that was freaking hard to figure out. Freak
should we take a freaking break? Or just keep pounding it. Try to smoke one, dude. So freaking ok, umm...how do we freaking do
this dude, freaking two and half hours to go...theres plenty of time to work on this dude. So freaking get into the thick of
it, don't be shy about it. So freaking ok, umm...so you freaking build a thing that builds stuff, this IS slightly what you
want, so freaking ok, then this thing builds, or basically builds, webpages for you. So freaking ok, umm...what this does is
generalize multiples, so like that's what we want, is generalized data in terms of multiples of the same thing. So freaking ok,
umm...so like should we just build the thing or what? The thing is, there is still room for improvement. What we need to do is
figure out exactly what this thing can and can't do, and go from there. So like, ok, what we would do is go ok, we have a
website, of multiple websites, and that has webpages, and those webpages potentially have multiples, so like for instance my
portfolio page has multiple clients listed on it. So freaking ok, umm...so what that is is we have a system where we define
websites, so beyond that point we would have any data, any multiples. So freaking ok, like freaking what is that? So freaking
what that is is...a name and a freaking array? Huh...:

Cinder
	websites
		website
			name
				Cinder
			webpages
				webpage
					name
						About
				webpage
					name
						Portfolio
				webpage
					name
						Contact
		website
			name
				ECJKD
			webpages
				...

Where freaking ANY array element can be any data, so like we have to account for some stuff at this point: like basically what
we would have is an array element as an instance of a certain class, so like...ok what if we used cascading logic for each
array element? So like that element itself and any element within it is subject to certain logic/filtration? Does this freaking
make sense? At some point it doesn't. So freaking ok, umm...so like what we would have is an array: is this what we want? Do we
definitely want what an array IS, or no? It wouldn't really make sense to do otherwise, because...umm...freaking a dude. So
freaking what do we do then? So like the whole thing is string: use string? If it were code it would fit rather abruptly: all
of a sudden it's in there. So freaking ok, umm...so like what one of these would be is an element with a battery of filters.
Umm...it would just be an element because it would have to be able to be anything, another array, an array element, anything.
So freaking ok, what if we map one of these out, just to see what kind of stuff we would need, like in terms of an array?:

Cinder
	websites
		website
			webpages
				webpage
...

Ok so a webpage would be a single row because it all has to come down to a single thing, to one, which is also outlined in this
document. So freaking ok, umm...so each of these elements would be like a freaking instance of a class, and that class would
have like a name and some filtration and some children. It would have an ID number as well, or like array indexes that uniquely
identified it. So freaking ok, then it's name could be anything, independent of its array indexes, and freaking...so we would,
at least, use a unique ID number for each of these, in a mariadb table, and then a parent ID, and then an order ID, and then a
freaking name, and then filters...and like thats it. So freaking ok, umm...now, what if we made this thing fully-extensible, so
like if we wanted to add a description or remove the name or something, we could do so? Freaking umm...huh...yea we can do
that. So freaking ok, so this thing is...so like freaking ok, umm...so like what we do is freaking...so like thats what that
is, when it comes down to it we can code it, so then the question becomes, what's next? What comes after that? So freaking what
we do is...freaking extend this thing...so freaking ok, umm...now how do we make this thing so freaking big that it's not even
funny? That its NOT EVEN FUNNY? Umm...hmm...we have to like figure out what that is and how to do that and everything. We
basically didn't go anywhere and we're getting all fired up like we did. :) Freaking ok, umm...so like that gets us to the
point where we're not like doing anything repetitive, at all, on a website. So freaking ok, umm...now lets say we wanted to go
deeper into something at some point, like user-priveleges. How can we do this in such a way that we can generate this data? So
that we can just generate the code, instead of coding it by hand? So like in order for this to work, it must follow that data
is conic: it never intermingles with other data, or "moves" horizontally or vertically, or along the z axis, so on and so
forth. Freaking umm...so what this means is there is a way to do that. There is a pattern that fits a conic model, therefore.
So freaking ok, umm...I think I might be done for the night.

So freaking ok dude, lets get to work. So freaking ok, if I define an array and then define elements of that array that point
back to that array, I end up in an infinite loop, defining that array. This doesn't work, because if I want to advance past
that point, I can't! Frick yea dude! All data is freaking static!

So freaking a dude...freaking how do we build this thing? HOW do we do it? Freaking umm...so like freaking ok, we...just build
it dude! Freaking ok man! So we have an array, we fucking HAVE one, and this array represents all of our freaking data, all of
it. Now, what we do is freaking...so we CODE this array with php, which is string, so freaking ok, now if we can make this
thing BIG enough, it will freaking work. I mean freaking hells yes dude. How do you make this thing BIG? Fucking B I G? Umm...
so freaking ok, umm...so like what we do is build it, while we're trying to make it bigger, and see what we get. That way all
engines are firing on all cylinders and everything. So freaking ok, umm...so we have an array, and like ideally that array is
just an array, where we can assign any data to it/etc. So like we could assign resources, objects, anything. So freaking the
way we do this is all of this is code, php code, so we just code it in php. So freaking ok, umm...so we code an array, then
what? Whats the next step? I mean if we code this thing, that's great and all, just it isn't the bitter end of it. What is the
bitter end of it? Freaking umm...like freaking ok, umm...I really have no idea! So like we just build this thing and it
freaking...ok so this data would be tabular, so totally displayable on a 2d view, so like ok, how would it be? So freaking ok,
like we would like build this array in php, so it would be an array in php. So then, how do we save this data? JSON encode and
store in a file? Freaking umm...yea thats totally what that is. Freaking a.

So freaking ok, so lets code this bad boy? Freak yea dude! Freaking a I'm amped! Ok dude! Build it! Ok dude, what if you
freaking build a thing that is basically an array that has php as the value of each element? Then we run the code, and that's
what that element is? Freak yea dude. Freaking ok, what if it's just string? Or like basically just string, since all of the
communication/etc. is string? Umm...so it would be string. So freaking ok, how do we "run code" then? Like how do we interpret
these things in such a way...so like we have an array of php strings, at least, and we run these with php. So freaking ok, umm,
like that would be the core of the thing? At least? That way we have a way of "accessing" elements, so like then we have a way
of carrying on once we reach an element, without hard-coding that sort of thing. I mean otherwise you could just have a
function for eval'ing some string with php, so like at will you just invoke the eval...so we would eval, to start, then we
would simply have string, so freaking ok, then we have elements that run code, and then freaking...freak yea dude! Holy shit
that fucking works! Then we just store each of the array elements as files, store the filenames in the database, and freaking
we're good! So ok, what if we just stored...what if we just stored the code as files? Either way dude. It'll all come out when
you get there, you're better off using a database along with the filesystem because, as already mentioned, that way it works
either way.

So freaking ok, so now we run some code...and that code can do anything. It can reference the freaking...ok so you have Cinder,
which is the center of everything. Cinder loads an array, whose elements are php files. Those files are...what if we process
the array by mime-type? Then, if we encounter a php script...yea I mean that's kinda what that is, the only reason php is
emphasized is we're INSIDE php, I mean that's basically it, except for my sweet-tooth for php. So freaking ok, shall we build
this thing? Freaking a dude...so freaking ok, umm...so we freaking run this array with this thing, then what? So freaking ok,
umm, start building? Umm...ok dude, freaking...what is freaking going on here is...so we have an array of all of our data. Now,
we need to ACCESS this array, somehow. So freaking ok, we create the array:

Cinder
	website
		http://cinderproject.000webhostapp.com
	clients
		ECJKD
			website
				http://www.ericcarrjkd.com
		Couchboys
			...
	friends
		David Helble
		Angela Rai
		...
...

So freaking ok, we have our array, now, what we do is...freaking...do something with this data? So like then what do we do? So
ok we have our data, so we will have a website that will have multiples, and what we want to do is automate the process of
handling these multiples. So what we do is...we create a system for handling these multiples, where everything is hard-wired.
So like we would have, lets take the Cinder website for example, the portfolio section, which will have multiple clients, rock-
bottom. So freaking ok, we store our client data, and then we reference that array with index.php. So freaking ok, everything
is freaking hard-wired, top to bottom, so you just build it. Ok, can we map this thing out in plain english before we build it?
Yes, we can. We both can and cannot do that, so as a matter of fact we can do that. So freaking ok, umm...so then we have an
array of data, in general, so freaking ok, umm, how do we...so like we could...ok so like lets say on our portfolio we build
it, then at some point we decide we want to change it/expand it, so in the case of expanding it, what we'd have to do is alter
like the fundamental fabric of it, like we would have to account for more...huh...well yea I mean it's a freaking complex, like
a complex itself, so no wonder it's a little complicated.

So freaking ok, lets say we have our Cinder website:

website
	Cinder
		...

Ok so like the first thing that comes to mind is what if...like ok, umm...so like freaking umm...so freaking ok this thing is
all string, so then what? So then we have some code (we're inside php), and we go from there. So freaking ok, umm...so like we
would freaking...umm...so ok we code this thing, now what all does this thing do? So freaking ok, umm...huh, there would be
like no intermingling of the things...freaking a...so freaking ok, what we have is an array...so freaking ok, what we do is...
make the most of an array? That's like that that is. So freaking ok, umm, try again...so freaking ok there would be like a
freaking array, then there would be some array elements, now what does each of these array elements need to DO? So like ok, we
would have, lets say, some string, as one of these array elements. Now, if that's all there is, there's like no freaking...so
ok at this point if that array element isn't some code there's no way to go on from there. We have an array, and like that's
it, it doesn't do anything or anything. So freaking ok, we (at least) code this thing to interpret non-array elements as php
code, so that the thing can crawl along. So ok, then we need to code some stuff...then we code another freaking file, and what
this file does is...so like this file could be a webpage, and our array is an array of webpages, so freaking ok, what we do
is...so like then we could have...so we would have something like, for the Cinder website:

index.php
	about.php
	portfolio.php
	contact.php

And then each of these files runs independently, and freaking we have a website! So freaking index.php would do something like
shoot off one of the other webpages, and what those would do is...so like what those do is index.php loads the first webpage in
the array, so "about.php", into it, so it has like the same header/nav/footer/etc. unilaterally, then freaking...and it works!
And it just plain fucking works dude! Ok, now is that the bitter end of it? Umm...so like freaking we would have...so that's,
at least, a website! Fuck yea dude! So freaking what that is is...an index.php file...huh...so ok what we would have is an
array INSIDE of index.php, so like an array of about.php/portfolio.php/contact.php, and...:

index.php fires
	about.php fires (first in line)
	portfolio.php
	contact.php

So like ok this works, so keep rolling with it...ok so lets say we have...huh...ok so we have "webpages", now what? Now we need
like a single webpage. So what one of these would be made of is tabular data, such that...ok so like what a website would be is
an array, or rather tables in mariadb, displayed as tabular data on the screen (the view). So freaking ok, umm...so under
"portfolio.php" we would have...yea just keep going dude, so you have a webpage, then you have portfolio.php as your example,
because it utilizes multiples.

So freaking ok, what this would do is, basically, simply load all the data from the database and output to the screen with a
tabular view. That's it! So freaking ok, IF we have a website made of mariadb tables, we simply display this tabular data on
the screen, and that is (at least) a website!

Ok! So freaking now, how do we account for...ok so like if we made the php framework for doing this we're basically just
phpmyadmin. Hah. That's what that is. :) Freaking ok, so then how do we link all of these tables together to form, effectively,
one table? Umm we could...so like we could have a master table that links to other tables, and then from there the whole thing
is effectively one table. The only thing here is...this is freaking so badass dude...my master system, you have, like, achieved
the master system dude. Good job. Keep up the good work!

So freaking ok, then we freaking...so then we need to like describe the links between data, so like we would, for example, need
to map the links between screenshots and clients. So freaking ok, we have a "Screenshots ID" column in mariadb, and this links
to screenshots in the "Screenshots" table in mariadb by unique ID number. So freaking...then we link the data together, now how
do we generalize this process so that every time we do something like this this is the case? We go ok, we freaking...link them
by a unique identifier, then like that's it? So freaking ok, like what we would do is...ok so what WOULDN'T happen is freaking
lets say we had some data, "A", and then we had some child data of that data, "B", B would never interact with A, A would only
interact with B, otherwise we would have an infinite loop. Therefore, what we do is define nested data, AND THAT IS THE BITTER
END OF IT! Freak yea dude! Ok, so we build a webpage generator, so freaking ok, now, is there a way we can extend this to,
like, it's ultimate form? Freaking umm...freaking a dude, umm...or does that make any sense? Ummmmm...huh...freaking...umm...so
like what this is is...so then we have an array, and that array is defineable by some code, or somesuch input, so freaking ok,
then that generates webpages, so like ok, umm...so you freaking generate a webpage, then like...then freaking...you do
something. Ok so I mean you have a freaking code-generator, then what? Well like the thing is that thing is full-bodied. That's
as far as it goes, so like then what we need to do is automate the entire process, so the thing is just fucking fully reeling,
all on it's own.

Ok man, so lets run this thing down once and see what we get: we start off, at index.php (or whatever php file). So freaking
ok, then we...load...so then we load a thing that builds webpages, and what this does is...good lord is that the freaking end
of it? Lol I think so dude! Freaking a. So freaking ok, so freaking ok, umm...so like start building it? Freaking umm...so yea
that's what that is, is a freaking webpage generator. So then what about a website generator, along the same lines, and then
an anything generator? Umm...freaking...umm...so like we need a way to generate more stuff! More freaking stuff dude, this
isn't good enough. So like ok, what we do is define these arrays, so like with php code or something, then...then that's it? I
mean ok dude, like freaking this thing would be iron- freaking hard. So freaking ok, umm, let's start coding? Ok so then we
have a thing that handles individual webpages, what about websites? Umm...yea that would be good, it would be good to cover
EVERYTHING. So freaking ok, we have a way of creating a recursive array, so freaking then we just store all our data in there,
each website, every website, each and every webpage, each and every thing. No etc. So freaking ok, so what we do is define a
way of defining tables...why tabular data? Is it purer to use a straight array? If it were a straight array it would be
completely native to php...so like that's at least what that is. So freaking ok, umm...so like that's what that is, is a
freaking array...so freaking ok, umm...so that's what that is, so freaking umm...that's like the end of it. So freaking should
we build this bad boy?

Ok, umm, before we build, is there ANYTHING else that we want? Straight up freaking a generator, something that generates
ANYTHING. And I mean freaking twinkies! Ok, how do we build a straight twinkie generator? Umm...freaking a...

So ok dude, it should be said at this point in time that a qi works. Freaking it goes down, unadulterated and everything,
completely constant. So freaking what that means is...like ok we have a qi, then we have some other data, or like, we have a
qi, and freaking umm...then we have...I mean basically it goes down, and like that's it. So either that goes down or this goes
down, so freaking THAT is what that is. Now freaking observe dude, and watch it go down. :)

Ok man, I think it is about time to get to work and actually put your nose to the grinder, unless you have anything else...ok
so lets run a website through here and see what we get:

Cinder
	website
		About
			simple html page (rich text?) describing Cinder
		Portfolio
			clients
				client
					name
						ECJKD
					description
						ECJKD needed a new website...
					screenshots
						screenshot
							thumb
							full
		Contact
			simple html page with a form for contacting Cinder
				this will need to be coded! You'll have to actually submit the form, once it's all filled out!

So freaking ok, like we have a mix of code and other stuff, so freaking what that is is everything all over the place, so
freaking then we have an array, and in that array we have Cinder, so like ok, how would we do that? An associative array? We
don't want that because we want the thing to be flexible, so we would have...an array of freaking...umm...so we have an
array...or not. We have a value.

So ok lets SAY we have an array, and then in that array at some point we have Cinder...so like how do we do this? We go ok, we
have a straight array, then we have Cinder, then we have like a mariadb table called Clients, and under each client we have a
website, or projects that we did for that client...so there are a couple of things here: we can have projects or we can have
clients, so what we need to do is define the structure of each array element. This is string, and (at least) php code. So
freaking ok, then each array element, and in fact the value itself, can be anything. So freaking ok, umm...so like we would
define the Cinder array, and what that would have is elements that are either projects or clients (or whatever), and like that
would be string, and then (probably) php code. So freaking ok, then we have a master array (that can store anything, so stuff
beyond Cinder, and so on and so forth) and that stores this stuff as well, and so can store elements that are at least what the
Cinder elements are. So at least what these are is string, and then probably php code. So freaking a, now what is all of that?
So everything is still string, at least, to account for php code, etc., so like ok, umm...so we're inside php, still, so that
is at least what that is. So other than that, so like we would code this array inside of php, and that is what that is. So
freaking ok, other than that...so each element of this array would, at least, be some php code, and like at most be some
string. So then the array elements run, and freaking that is what that is. So freaking ok, umm...so we have some code, then we
have this array, then umm...so freaking a dude, what this is is...so we have some code, and that code is inside of an array,
and we run this code, and that code...runs like within index.php, extending it's behavior and stuff like that, and freaking
umm...so like what this is is a huge array...:

Cinder (index.php)
	clients (clients.php)
	projects (projects.php)
...

Ok so like what we COULD do at this point is generalize an element of this array to the point that it is...well...string? What
we have is string, so what one of these would be is string, whether it's php code or not, so freaking that's what that is. So
then this string is...stored in a file somewhere? With permissions and stuff? Umm...huh, it's all string dude, so just come up
with what you want and press that shit in there. So freaking ok, umm...I want a system of freaking...basically I want a value,
here, inside of PHP, and like that's it. So then I want to store EVERYTHING in this array, so I mean EVERYTHING, personal
phone numbers, etc., literally EVERYTHING. So then everything would be string, then we go ok, so lets say we model this array
up a little bit:

Cinder
	clients
		client
			website
			...
	projects
	etc.
...

So like ok, at least what this would be is each element would either be string or another array. So like what if we described
this with one string? Umm huh, yea we could do that. Lets try and do it with a mix and if it doesn't work we'll use a string.
So freaking ok, at some point we would have to translate this thing to string, to be consistent, so freaking that is what THAT
is. So freaking ok, umm...

Oh freaking kay dude, umm...so like what do we do here...code the damn thing already? Not yet, lets map it all out and
EVERYTHING before we get started. So freaking ok, there's a freaking array, and this array is code and other stuff, so like we
run the code...ok off the top, what is this array? It's all string. Well, it's not ALL string, because it's recursive, so it's
potentially other arrays also. So freaking ok, umm...so if we encounter an array, we loop through that array, if we encounter a
string, we parse that string? We have string. Then, we potentially have some php code, at which point yes we would parse that
code. So freaking ok, umm...so ok, basically, that string is potentially php code, so we potentially parse that string. So that
is what that array is, inside of here (inside of php). So freaking ok, umm...so on a website how is this array handled? By some
php. So thats, at least, how we do it at this point, or rather, HOW we do it at this point! So that is what that is, is we have
some php code and that is what our array and everything is. Some string, and like that is what that is. So NOW code the thing?
Nope. Lets freaking finish banging it all out until everything is solid, then we'll code it. So freaking ok, so we have some
code, so like potentially we don't even have an array in there, potentially we have an empty php file. Fits flush.

So freaking ok, we're inside php...then what? So we freaking code this bad boy. Now, how do we code it? Or what? So potentially
we have some code, so this thing could be ANYTHING, so freaking umm...so we code an array, and like all that is dude is some
freaking string, like a bunch of string. So freaking ok, umm...over it. Out for the day. Maybe I'll be back later, maybe I
won't. ;)

Ok, so I'm back, so what this is is...we have an array which is the same thing as what our webpage generator generates. So
freaking ok, what that is is we have a table whose rows have children which are other tables, and so on and so forth. Now, the
thing is, there is "glue" gluing these together, and that "glue" is php. So freaking we have some php code, so it freaking
works. Now, all we have to do is refine it to a point, and let it rip. So freaking ok, what we have is...so we have an array
with some code (for filtering it and stuff, but what we have is at LEAST, or freaking like at MOST, php code). So freaking ok,
now, can we do away with the code or something? Like, what would the array be without the code? There would be no filtration,
etc. So like ok, the thing is, the code generates the array, so if we want to refine the array we refine the code. So freaking
ok, now, what do we do here? We have to like refine this thing until it's pressing out pure bliss. So the thing is we want to
shoot for string, at least, so the whole thing is made out of string. This will ensure that the thing is completely, 100%,
consistent, as well.

Freaking ok, so like what we do is...so we would have a table in mariadb, then we would have some filters and stuff on that
table. Now, the thing is, all of the data in this table would be string before it left php, and once it returned. So we use
string-based functions/etc. to do this. So freaking ok, I'm totally thinking regular expressions. With regular expressions, we
can control everything about a string, so I mean isn't this the way to go? Umm yea that's what that is, and if it's not, we can
fix it in the future.

So ok, we have a table, now we just need to attach it to another table, so freaking what this is is...some code! It's the same
thing dude, it's code. It's the same thing because the code generates the array, and if nothing else we're inside of PHP! So
freaking a dude, NOW it's time to code it? Dude it freaking works! Freak yea! Freak yea it does!

Ok, so what we do now is look this thing over...is this what we want? Or rather, is this going to work? Freaking umm...so like
ok, umm...so now if we translate everything to an array we have it in the bag. At this point it's one thing: an array. Then,
it's one thing: some string. Whichever, it's one thing. So freaking it is "1"! :)

Ok this is good. Now, I can tell you from past experience it will work if it is "1", but I mean you might as well run it
through a battery or something and see to it that it works and everything. So ok, we're still inside php, so like that settles
it, it's php and we start coding. Now, are you freaking SURE you're right? You're SURE? Yea man, I mean if it works and there's
no difference, I'm down.

Ok, then lets start coding the thing.

So freaking ok, what this is...is...dude once this is done, you can freaking press out all of the html based on this data. Like
freaking almost all of your stuff will be hard-wired. If not all of it! Freaking a dude, this is badASS. Ok man, freaking a,
code this bad boy dude.

So freaking ok, what this thing is is a php script that...codes arrays. So freaking ok, now, hmm...what is the utter bottom of
it? Some code. So freaking ok, umm...so we have some freaking code, now, umm...like freaking ok, what is this code? So this
code, at least, defines the array. It defines the array itself, as well as any children of that array. So freaking ok, now, how
do we stretch it thin until it covers the entirety of the thing? So like basically if we mock one of these things up we should
have a pretty good idea of what it is we need to do:

Cinder
	About
	Portfolio
	Contact
...

So like freaking ok, we would have an array, so a table of webpages (About, Portfolio and Contact), then each of those would be
a table, so freaking umm...so what if we only have one of something, does it mean we shouldn't use a table to do it? How will
we store the data? One or more dude, keep riding it. Freaking ok, so we have some tabular data, now we just output that data to
the screen, formatted with html. So freaking ok, umm...so like ok now the thing is we can have websites in clients, and we can
have websites, so how do we handle this kind of data? Two seperate tables. Is there a way to handle this kind of thing in such
a way that is fully-recursive and all? Umm...freaking umm, that's string dude. So freaking ok, umm...so like what if we had
classes that classified elements, and then these classes have a function that the thing calls to get the gears turning and
stuff? Umm...freaking umm...so like there is some way to do it, you just need to come up with what you WANT! Like ok so you
want this thing to be as flexible as possible, so like just some code? Just some php code? Or what? So you hypothesize that an
array of data can rule the world, you figure that if you run strings in that array as php code, one by one, you have it all
figured out. Well, you're right! You do have it all figured out. So what else do you want? Is that it? Should we keep this open
ended at this point, and therefore, beyond? Both. We do both. Freaking ok, so on the high end, an array works, and that is a
route we take. On the other hand, we keep our horizons wide-open, no nothing.

So freaking as far as things being wide-open is concerned, we're good, we're good to go.

As far as our array is concerned, freaking ok, umm...hmm...so like what this is is...we have an array, and that array is
tabular data, and we display that tabular data on the screen; 2d, tabular data. So freaking ok, what else is there to it? So we
have input/output on everything, hypothetically everything, so on this tabular data, as well, and what we do is filter it on
input to keep stuff we don't want out of there, and...we do this with regular expressions, and then we have filtered string. So
that's it, it's ready to go from that point. One thing filtration. So freaking ok, what we do is...we come up with an array
structure definition, and define the mariadb tables, as well as any regular expression filters we want to use on the columns of
those tables, as well as error messages in case those filters fail. So freaking ok, umm...that's like it! We create the table
definitions, we filter the input, and that's it! Freaking a dude. So ok is there ANY way to stretch it any thinner than this?
Like what if like we want to install radio buttons on these things or something? Umm...is there a point to using a straight
array over something like this? What if we want to "code" these things? Like what if we want something weird, like say we have
a situation where there can only be two of something in a database, how would we "code" that into the thing? So like ok, we
come up with a way...hooks or something. Or just straight hack the thing? The thing itself? :) Umm...huh...I'ma go eat dinner,
I'll be right back.

Ok, so freaking umm...ok what we would do is...ok so how is this going to work when we could have ANYTHING going on? We could
have freaking like any number of filters, any kind of data. What is the solution to THAT? Freaking umm...it's string, dude!
Freaking umm...so under filters we have a thing where you can link to a file instead of using a regular expression...then that
accounts for filters on individual columns...so like ok, if you selected a row based on something, based on something, based on
the value of some column of some other row, you would end up with a row. You still have a tabular view. Even if you select a
column of a row, you still end up with tabular data. Then, filters only apply to columns. So we have a thing where you can use
a file (a php file) as a filter instead of a regular expression. Does this make sense? So we want to make sure...ok this
doesn't make sense, in that we would use regular expressions to filter columns, and then offset the load further up the chain
(so we would code some php that would create the filters, and feed them to the thing. The thing is, however, that we would be
doing both, so it bottlenecks at the point at which we use some php to generate the filters. Therefore that is the filtration
mechanism.). So freaking ok, umm...then we define the array structure, and what that is is...basically the same thing that we
already have. So freaking ok, what would be different, however, is...so like by one we're in pure php. We would freaking have a
thing that would generate the array structure, but this would be second to php, and different in that it is some code (as
opposed to a blank php file, for example), and therefore we have pure php code. Or so we think. :) So freaking a, ok, umm...so
like what we would have is...some php...then we would have an array. So ok, we would have, to be pure about it, some string,
and then we would have an array. So freaking ok, this array...would be...so like ok if we have the array structure and the
filtration, we have, like, the data IN. So freaking ok, umm, we need to be sure this array works! I mean if it does dude more
power to you and freaking let it rip. So freaking ok, umm...so freaking ok, we would have a column, or we would have no
table! So freaking then we filter the input, and we're done. That is the input end of it. That's it dude! You would have the
array structure definition, along with the filtration, and that's it! No more! So freaking ok, then we would...output that
data, and that is all out, at least thus far. So freaking ok, NOW build it? So ok, umm...are you freaking SURE that's it? I
mean you can freaking travel through the time-space continuum with this thing? As is?

So freaking ok, we would either have a column or not, at which point we would either have a table or not, at which point we
would either have an array structure definition or not. So freaking ok, that's what that is. Now, filtration: umm...I wonder,
could you just code this thing by hand and get away with it faster than generating these things? No. Generalizing the process
results in something that is faster. It makes one out of two. So freaking ok, umm...then we write filters for these things. So
freaking ok, as opposed to just hit or miss, what if we had several levels that could be defined, so like you could issue a
warning under certain conditions, and so on and so forth? Umm...just keep working it all out dude. Freaking you'll be like
blow, there it is, and that will be the end of it. So freaking ok, umm...freaking I'm about cooked man. Call it? Let's get up
early tomorrow and get it done. Freaking this working till like 10pm shit doesn't cut it. I think I'll keep working for a while
though. Umm...so like ok all you have to do, at least at this point, is get the data in there. Just get it fucking in there
dude. So freaking like ok, we have a column, so we just stick the data in there. Other than that, we filter it, so how do we
filter it? Ok so freaking umm...so like we have a filter...why not a regular expression? Yea we couldn't do that, because we
have to...actually maybe we could. Naa we couldn't, because we need to take a step back from regular expression so we can
relate the data to the database and stuff like that, programmatic stuff. So freaking ok, we define...so like ok we could...yea
there's like no point. But...is there a way to do that? There's a way to freaking do that dude. Freaking so you draw up...you
know what, just call it php. We can fix it if we're wrong, and we'll find out if we're wrong down the line. So freaking ok, we
have an array structure definition, so then we freaking...ok umm...yea like it works dude, but I mean CAN we freaking refine it
anymore? Umm...freaking umm...damn dude...so ok, you DEFINITELY can't check to see if something HASN'T been done twice in a
database WITHOUT some php, so freaking thats what that is. If you wish to filter the string this way, this is the path you
must take. However, what is there to be glum about? It's working!

So freaking ok, umm...so then we define an array structure, so umm...and then it's in there, and it's done, and it's time for
output. So freaking ok, umm...huh...so like does this define working code, or do we (still) need to code it by hand? Umm...a
plethora of questions! So freaking ok, umm...so like do we define a table, or what? An array? A value? One column of one row is
one thing. So from freaking there just go for it. So freaking ok, umm...what do we do here? We like freaking...so freaking ok,
there is a way to do this dude, it's all freaking string! Just freaking comb through that shit till you get it all silky and
untangled and all that.

Ok man, so like freaking we have an array...so what we're going for it an "array generator" for building websites. So freaking
ok, so you generate an array...what would the syntax for this look like, so far? Or what? Like ok, umm...we freaking...have it
by the balls dude, now freaking twist and whop it's head off! Freaking ok, so umm...so like ok, once we have the tables built,
we build a front-end that correctly defines the look and feel of the input. As far as the back-end is concerned...

Ok this is what this is: we have an array, with filters, on our back-end. On our front-end we (potentially) have everything
lined up, so like the freaking radio buttons, the inputs, everything all laid out, correctly mapped to the back-end. So it
doesn't matter if the front- lines up with the back-end, they are completely independent of one another. So freaking ok, what
we do is go ok, so we can define a number of possibilities for a column (effectively a "radio" button), so doesn't that solve
THAT problem? So ok what we would do is define a regular expression that filtered anything but these values from the thing, and
anyways we wouldn't need to do this because we would filter it with the front-end. So freaking ok, umm...but we would ALSO want
to filter these on the back-end, so back to what I was saying. Basically we would have a regular expression that would do this,
but I mean just to be sure...ok so like yea that's what that is. Now, what else do we need to account for? That accounts for
multiple values for a single column of a row, then what? Then we need to freaking...this is going to work dude, you're not,
you're NOT, doing this for no reason. Everything from something, not nothing from something. So freaking ok, umm, so yea I mean
it is all string, so this totally works, we just have to work all of this out. So freaking ok, umm...so like freaking what we
do is...keep hacking at it dude! That's what this is. So freaking ok, umm...so like...so we have a row, is that what we want?
Or do we just want an array element? Or what? Lets just say we want rows and leave it at that until we get there. So freaking
ok, umm...

Ok so what if you had a recursive array and it's elements were (at least) objects of classes that extended each other and at
least one core class? So like we would have like an "Element" class that would (otherwise) define an array element, and it
would have a "value", and then we would extend that class, and extend that class, and so on, as necessary, to create structure
within the array? You would have like an output function or something defined for each one of these that would be called when
the array called the object, and thus we could filter, and otherwise control, everything going on in the array. This would
work, just it would be better if we hammered out all of the details until we ended up with a more generalized structure, where
each element were treated the same, by a battery of functions or something like that. So like freaking what this is is...ok so
like you would kind of have to use objects to do this, because if you wanted to, say, have websites, and then websites under
clients, you would need individual classes to do this, it bottlenecks at that point, so that is AT LEAST what that is.

So that knocks it out of mariadb...and back into php. Freaking hells yea dude, now that is like freaking IT, besides the
filesystem, I think, so just freaking...well its IN php, so thats, petitely, what that is. So freaking ok, umm...yea dude, keep
the dream alive, lol. :) So like ok what one of these things (elements) would have is something that could set it's value, and
something that can filter it's value. So like the filters would be...code...so freaking ok, like what we have is:

Element
	Value
	Filter
		Filter (itself)
		onFailure error code (for defining magnitudes of errors)
		onFailure message
	Set
	Get
...

And like that's all I can think of for now, so freaking...so generally speaking you could set the value with filtration, and
get the value. And I mean that's like all that thing does. So freaking ok, this is AT LEAST what one of these would be. So,
then, then what? Then like freaking umm...call it for the night? Yea I'm out for the night, peace out.

Oh freaking kay dude, back to it!

So freaking ok, this thing is all string, inside and out. So freaking ok, umm...so freaking umm...there's like a thing with a
filter, and that's what that is, and freaking...umm...ummm...so freaking ok, umm...so like there's a freaking thing...there's a
freaking array, and then...then like that's it. Like is that it or? So like there's an array, and it's a table, so there's a
table, and freaking ok, what we do is generate all the peripheral of this table, so all the in's, out's, etc. So freaking ok,
umm...hmm...so like there's a freaking...thing...there's a freaking array, not a freaking thing. And there's no freaking. Hah
j/k. :) So freaking ok, umm...so freaking ok, there would be a set of general functions an element would use...is there a point
to extending...yea there's a point. So freaking ok, umm...ok dude, so we have a freaking array. Now, we have to be able to
access (I/O) it's elements. So freaking how do we do this? Freaking access is one thing...the array is one thing, an element is
one thing, umm...so freaking ok, umm...like if we run this thing at this point, what do we get? Umm...huh...good point. Yea
what do we get anyways, if we run this thing? So like we would have the input, where we would define the array structure and
stuff, then we would have...ok so if we had a table with one column, would we have an array or a table? An array! The same
thing? An array dude, one column per row means one element per element...then there's no point to having another array as the
element. So freaking ok, umm...so we would have an array, or effectively an array, ok so then what? Ok lets mock this thing up
until we get to some ambiguous point:

Cinder (array)
	value (mixed)
		0
			instance of "Website"
				name
		1
			client
		2
			client
...

Ok so like what we have is a freaking system where the structure, the order of the data, all that stuff, like has to be the
data itself...or does it? Does it AT LEAST have to be that?:

Cinder (array)
	value (mixed)
		0
			instance of "Website" (object)
				$name
		1
			instance of "Client" (object)
				$name
					"ECJKD"
				$description
					"ECJKD is a..."
				$notes
					0
						"..."
		2
			instance of "Client" (object)
				...
...

Ok so like now what comes to mind is that if we need/want to extend the structure of the thing we have to rewrite the WHOLE
thing all over again. So freaking does this make sense? Consider the syntax for accessing an array?

So freaking ok, what if we write the thing to read a straight array, and follow certain conventions: a straight array is looped
through (to no end), and an associative array, or any associative elements, are displayed with their name and their value? Umm
that satisfies a condition of doing this...so we'd have:

$Cinder (array)
	0
		"type"
			"website"
		"value"
			[
				"name"
					"Cinder"
				"url"
					"http://cinderproject.000webhostapp.com"
				"structure"
					[
						(structural definition here, or something, maybe a link to the site on the sandbox, etc.)
					]
			]
	1
	2
...

So freaking ok, then we have to interpret the data, but AT LEAST the interpretation is seperate from the data, but I mean this
is no different from not using associative arrays! So you'll still have to loop through these things and define the structure
of each of these things, so that's AT LEAST what that is!

Ok! So that's what that is, so we'll have our data itself, the rows in the tables, and we'll take that and interpret it with
an interpreter, so then what are the two extremes at that point? So ok, the two extremes of an interpreter are...you interpret
an array element as $key => $value...what if...ok so yea umm...so then you have an array element, which has indexes, then you
have the value of the element. Now, the trick is to like interpret the value a certain way. So freaking ok, umm...so like if we
interpret the array anonymously what we end up with is a set of like inputs for the thing, so freaking umm...so then we have a
pure value, so thats what that is...so freaking ok, like what we would have is a straight array, then (if we wanted to) what we
would do is define an interpretation for that array, kinda thing, or like a structure, where we go ok, each one of these
elements is a certain thing, the same thing in fact, so like lets say they were each an instance of a class, an object, with
it's properties and methods. Yea that's what that is. So freaking ok, now...so then we have properties, so we could given an
element a "name" and a "description", or something like that, and then we can filter input to the element with code, so
freaking that is what that is. Now, does this freaking make sense? So freaking umm...so ok this is simply how we format
elements, so if we wanted them to have a set number of properties we can do so. So basically, so we could have an element that
had a "name" and a "description". So freaking ok, umm, yea that's what that is because otherwise we have to...ok so that is at
LEAST what that is. So freaking ok, umm...so like we would have an object with properties because if we had an associative
array we would have to interpret...freaking like relatively speaking things are either 50/50 or 100%: if you code 50/50, half
of what you do is code, the other half is automation. If you do it 100%, its all code and automation. So freaking ok, umm...ok
anyways, so like what we do is...so now we have:

Cinder
	name
		"Cinder"
	description
		"Some description..."
	value
		array
			0
				value
					"some data..."
			1
			2
...

Ok so like the thing here is we can't set the value of Cinder to like an array. We have to do one thing, so we either always
set it's value to an array, or always set its value to something else. So like freaking ok, umm...or like we have to dig
deeper. So like the thing is what would happen here is when we go to automatically generate these things we have to
differentiate between types of values, so freaking that's what THAT is. So we have a value, then that value is of a certain
type: how do we know what type it is? We arbitrarily assign one. So freaking ok, we assign a type, so like we would have an
object that did this...freaking umm...

So freaking ok, we would have an array, any sort of array, because freaking...so freaking umm...it would be an array because...
freaking...it would be an array, because we're arbitrarily using an array, then it would be any sort of array because that fits
our model.

So freaking ok, then we would have data and interpretation, so we would have a completely custom interpretation of completely
custom data. So freaking ok, umm...umm...so like we would have some data, freaking umm...so...umm...huh...like we would have...
something...so ok, just throwing something out there, we would have like a value? So freaking ok, so we have a value, then
what? Then we like interpret that value's type to figure out what to do with it. So like umm...if it's something other than an
array...so freaking ok, umm...so we interpret a value...so like we would interpret the value, and if it were an array we would
interpret the array values one by one, first in, first out. So freaking ok, umm...so like freaking what would we do if we
interpreted something other than an array? Or rather, ok so we have an array, so what we do is interpret that array...so we run
through each element of the array, and...so ok what kind of comes to mind is whenever we hit an array we have to use two
identifiers to access the array elements, so freaking...what I'm getting at is the value itself is an array, so then we want to
loop through that array, so at this point we need to define some sort of process for doing this. Basically what this is is we
treat arrays differently than elements. So freaking ok, umm...so we take our value, and start recursively processing it,
treating arrays differently than anything else. 

So freaking ok, umm...then what we freaking do is interpret our array, so like what we do is display each element...or the
value of each element, displaying something like a link for arrays. So freaking ok, umm...so what this would be is...we would
have an array, then we would have keys and values for that array, and freaking...so freaking like ok, umm...what we do is we
have an array, then freaking umm...so freaking we interpret this array, so how do we interpret an array? We interpret by like
type, or just whether something is an array or not, so we can have a recursive array, then...so we have a recursive array, then
what? Then we like freaking filter through data and stuff...so then like what do we want this thing to do? So freaking ok, we
want it to hold data, and then we want to filter that data. So like we seperate the data from the interpretation and that is
that. So, if I were to make it all one, one array, with filtration and everything built into it, how would we do that? Freaking
umm, we would like freaking...so freaking ok, umm, we would freaking have an array, then we would have...so like we would have
an array, then we would somehow filter each of these array elements, so like at MOST what that would be is a class for the
elements of the array, and the filtration and everything would be built into that, so like freaking this becomes a freaking
like completely complex mess. Or does it? So freaking ok, umm, what we would do is...ok so each one of these elements would, at
most, be the same thing, so even if they are arrays...so like at least what we would have is a mixed array, where the ordered
elements would exist in case we wanted to do stuff with ordered elements within the array...umm...huh...so it would be at LEAST
an associative array, or like a mixed array, like this:

Cinder
	[
		website
			[
				name
					Cinder
				structure
					[
						...
					]
			]
		clients
			[
				client
					name
					description
					projects
						[
							website
								...
							project
								...
						]
				client
					...
			]
	]

So like at least what we would have is an associative array, so would we ever mix keys? So like have associative as well as
ordered keys? Umm...that like isn't the question, the question is like what would we do with this array? So we would filter it,
on input, and display it on output, and that is what that is. So freaking ok, we have an array, and we want to filter it. How
the hell do we do that?

So ok we could have an element class that filtered it's input, and then we filter input. It only works within the scope of a
project, but it works! Like if you ever wanted to expand you'd have to rewrite the class and transfer all the data over and
stuff, but it kind of works!

Oh freaking kay dude, umm...so lets run it through the battery again: we create this array with a program, and what that does
is define the structure of the array. So freaking what's happening is we feed it some syntax, it (automatically) comes up with
some code, and it filters the input of the array, then outputs that data per request. So freaking the hurdle here is filtering
data. If we just input data into the array and output that data, we would simply have an array. The thing is, we have to
CONTROL the INPUT of that array so all of it's data is formatted and stuff. So freaking ok, umm...so if we formatted that array
with associative keys, we would have to have a thing that interpreted that structure to do what we're trying to do. This KIND
OF works. It doesn't just plain work though. So this would be AT LEAST that. So like what that would be is:

Cinder
	Element
		Name
		Description
		...

So what we have is like a name, description, etc., just the fact remains that we have to filter that data at some point, so
from there we would...have a custom interpreter that would do this. The problem with this is the interpreter can't handle
EVERYTHING, like at LEAST LOADS of stuff. Furthermore, it can only handle explicitly what we tell it to. So freaking ok umm...
so like ok umm...so like it couldn't be an interpreted array, because that doesn't (always) work. Like we can't have an array,
with structure and stuff like that, and then "correctly" interpret that array, because the interpretation is dependent on the
array, the data, and everything needs to be one thing, so independent. So freaking now what? Ok so like what we would have is
either arrays or objects. If we made these objects out of other objects, and so on, they would filter and so on and so forth,
so freaking I mean, umm...:

Cinder (array)
	Element (object)
		Name
		Description
		...
	Website (extension of Element)(object)
		URL
		Sandbox path
		Name
		Description
		...

So freaking ok, this gets us like one step further along, where we then account for different classes in one array. So this is
AT LEAST what we're going for. I think. Huh. Nice fit. Everything like works correctly and everything up until that point. So
this would be like at least what we were going for with our webpage generator, and beyond. This way, we can have elements that
are websites, say, within clients, and then, even if we wanted, clients that are parts of websites. So freaking a dude...

So freaking kind of as a sidenote, I think I've translated all of the types in php to absolutes:

"boolean"
"integer"
"double" (for historical reasons "double" is returned in case of a float, and not simply "float")
"string"
"array"
"object"
"resource"
"resource (closed)" as of PHP 7.2.0
"NULL"
"unknown type"

would be:

boolean - false => 0, true => 1
integer - <= 0 => 0, >= 1 => 1
double - same as integer
string - length then same as integer
array - 1
object - 1
resource - 1
resource (closed) - 1
NULL - 1
unknown type - 1

So anyways on with it. So freaking ok, umm...so like we would have a freaking...smoke one dude...freaking ok man, so you would
have an array, any array. Now, what you do is...freaking...so lets say you have "an array":

<?php

$Cinder = [
	"website" => [
		"url" => "http://...",
		"structure" => [
			"(structural definition would go here)"
		]
	],
	"clients" => [
		[
			"name" => "ECJKD",
			"description" => "Eric Carr Jeet Kune Do...",
			"projects" => [
				[
					"(project details would go here)"
				]
			]
		]
	]
];

?>

So freaking there's a working array, now...ok so first thing is we would make an array a class as well, so everything is an
instance of a class. So freaking ok, then, like everything "works", so like that is what that is up to that point. So freaking
then what? Then we can code these things, one by one, but what's the next step? Lets fucking get there dude, all the way
freaking there. Call it quits for the day? Naa. So freaking ok, umm...so like what we have so far fits as far as a webpage
generator. We would define these classes...ok so what if we generalize the generation of these classes? Yea I mean that's a
thing. So anyways, going all the way there, because that's what we're doing...so freaking ok, umm...I think I'm gonna call it
for the day. Freaking tired and had it, pick it back up with a full day.

Ok so fuck it I'm down dude. So freaking ok, if this thing were an array it would be fully functional, inside and out. The
problem arises when we introduce filters and extended behavior. The thing is, extension is extension. So freaking all told the
thing works, at this point in time, as a simple array with input/output.

So otherwise how do we build this bad boy? So freaking any array element would have input/output, where we could edit/read the
value of the element, so freaking how do we go from there to where we want to go? How do we introduce extensions...so like at
LEAST what we do is...use class instances for array elements. Then, umm...then we have to build all of these classes. So
freaking how do we put the two together into one and be done with it? Freaking we're getting there dude...just keep crawling
along. Crawl; when you get there, you can be like fuck it dude I crawled my ass here, I didn't walk, I didn't run, I crawled on
my hands and knees. Freaking a.

So freaking ok, we have like a freaking array, and if we make that array out of class instances, then what? Then we freaking go
ok, we have...like...freaking...so ok like these classes would (probably) extend...in fact they would extend a class, then like
each other, so freaking what that is is...we would have something like an element class:

<?php

class Element {
	
	private $value;
	
	public function set($value) {
		
		$this->value = $value;
		
	}
	public function get() {
		
		return $this->value;
		
	}
	
}

?>

So then we have a value, and a get/set method for handling that value, so freaking umm...what we would do is...so lets say we
fired up our array, we would load an instance of this class (or some class that extended it), and what we would do is...so like
lets say we opened it for writing, writing before reading, we would instantiate the class, and that's it?:

<?php

class Element {
	
	private $value;
	
	public function __construct($value) {
		
		$this->set($value);
		
	}
	public function set($value) {
		
		$this->value = $value;
		
	}
	public function get() {
		
		return $this->value;
		
	}
	
}

?>

So we would have a construct function so we could just construct the instance and that's it. So then, we can get and set our
value. So like that WOULD basically be it, from there we would loop through the value/etc. however we wanted. That would be AT
LEAST what that is. So freaking ok, then lets say we had a class that extended this class, or what? Umm...ok so like lets say
we wanted to check to see whether there were two other rows that had the same value as something, how would we do that? What we
would do is test for a match, or would we test for a mismatch? So we would test matches, because that is...the point is the
matches, so we would test those, not the mismatches. At least. So freaking ok, we test for "matches", and the thing is we test
for more than one of them. So what is happening here is...we're testing a value against an existing value. Generally speaking
that is what we are doing. So like what we do is...ok so the thing is, we have to...we could do anything at this point, so like
more accurately what we're asking is what is all code? Like freaking that's what that is. Lol. :) Get it done though dude, it's
all string, so it's a freaking explanation of everything in the fucking universe, more power to you dude.

Freaking you know what dude, whoever you are, if you ever read this, this is what this is: you know something. You know
everything about something. Relatively speaking, all that is wrong is you are asking the wrong question.

So freaking anyways, there's my big fat fuck you to whoever is running this thing, along with everyone else here. Everyone
ELSE.

So anyways, where was I? Ok so you have an array, now what can you make of an array? Freaking umm...so like we have an array,
then what? Then we have array elements, so umm...ok so like we have an array and then we have an extension, filtering input to
that array/etc. So freaking ok, umm...so like we basically have some code, because we could have an array of php code, and then
systematically execute that code. So freaking ok, how do we code this thing then? Freaking a. Umm...so freaking ok, umm...so
like fucking what this is, is...freaking...so freaking a dude, now what?...Fucking a dude...drawing blanks like freaking crazy.

So freaking ok, umm...freaking a...freaking down by the bay...:) Ok for reals...hmm...so then we would have a core of functions
and stuff that we would operate on our array with, this is AT LEAST what this would be. So freaking ok, umm...so we would have
like an input function for changing the value of an array element, then we would have an output function for outputting an
array element, then we would have like, basically within the input function, a filter function that filtered the input...what
exactly is the extent of the data that like the input could be filtered against? It could be anything in the database, in any
number of databases, any data from anywhere, anything. It could freaking be anything. Freak yea dude. So how do we freaking
break that down? Going freaking straight at it dude. Umm...I think I'm out for the night, but shit, I'd like to keep working on
this...freaking just keep going dude. Just keep going and fucking don't stop.

Ok man, what this is is...so freaking ok, umm...I'm over it for the day.

So freaking ok I was thinking and...what are we trying to do here? Or thereabouts? We're trying to come up with a universal
system...a system that can accept multiples and do stuff like add, edit, delete, and read those multiples. Moreso though, what
am I trying to do? I found that what I was generally doing was going from the general to the specific and back again trying to
figure this thing out, moving bit by bit. Then I got to thinking, what would be better is if we just whopped it in one fell
swoop, and even came up with a system for figuring things out and generally doing things. So I figured ok, the first thing we
generally do is simply ask the question, so broadly. So freaking then what we do is nit-pick until we have all of the details
figured out, then we lay down the finished product. So then I wonder, what is the question I am trying to ask? I know what I
want, like in the abstract sense, but I have not identified, to a point, what even my question is. So generally what I want is
a system for handling multiple things. What does this mean? Specifically, what do I want? What I'm going for is a universal
system that does everything. And I mean that literally! So what this thing would do, at least, is take in input (add, edit, and
delete these things) and give output ("read" these things). So freaking ok, umm...that's at least what that is. In the end,
these things would be completely manicured; ordered, filtered, and so on. So like at least what this is is these things
ordered. As far as the things being filtered, the individual things themselves, I figure we can figure that out when we get to
the point that we're dealing with these things individually. So when it comes to multiples, all there is is the order of these
things, aside from how they get in and out of there, if they are "just there", if there are multiples, that is all there is is
the order they are in. So that's what that is. So then we want to be able to add/edit/and remove these things? Or then what is
left? So the order they are in is AT LEAST what this thing IS. So then what else it is is...at LEAST the ability to add, edit,
delete, and read these things. So freaking ok, umm...so we can add these things...we can edit these things, and we can delete
these things, then we can read these things. So you have an array with I/O. Is that freaking it? Dude I think that's what that
is! Freaking that's at least what that is, so is that at most what that is? Freaking a dude...whoa that's snappy. Ok so just to
run it over one more time, just to make sure, if there is more than one of these, all that matters is the order they are in. So
freaking adding, editing, deleting, and reading happen piecemeal: we don't do this, in terms of efficiency, until we reduce to
one, to generalize the system as much as possible. So freaking that's what that is.

So should we freaking code it? Should we come up with something bigger? Better? Is this right? I mean I want the thing to
filter input, too. So freaking I guess this isn't right...like is that fundamentally what it does or? So at least I don't think
I'm right so I'm gonna plug at it and see what I get.

So freaking ok, this thing is AT LEAST an array with I/O. So then, what I also want is filtration on input, so then what? So AT
LEAST what this thing is is an array with filtration and I/O. So freaking there, now what? Freaking a...so WHATEVER it is is at
least some code...

Like what this thing is is an array with some I/O and some code. That code extends the functionality of the array and the I/O.
So freaking what this would do is...well, honestly it could directly affect the array and the I/O, like what it would do is...
alter the array/I/O before and after they are called, so the thing could be completely tweaked to perfection. This is AT LEAST
what this thing would be. So freaking then, the question becomes: what exactly is the extent of the extension that could
happen? We could do anything with the array: what exactly is that, in finite terms, what exactly is the string that this thing
IS so we can type it out and thus code the thing? Like the beauty in this, dude, is that whatever it IS, it IS string, so we
can definitely type it out. Freak yea dude. Freaking a. So freaking ok, umm...so freaking what this would be is...an array, a
beefed up array. So like our input would be something like edit, add, and delete, and our output would be something like read.
So freaking like basically what this is is...umm...there would be like...good lord this is such a big question dude...is there
really a way to reduce this to a FINITE amount of string, or is it an INFINITE amount of string? Freaking a. So like freaking
what this would be is we would have an array. Now, this array...so ok we would have an array: not a string, not a number, an
array. So then, we would add/edit/delete the ELEMENTS of this array, so one consistent, unilateral rule. So what we would have
to do first is add an element. Then we would need to be able to edit that element, and finally we would need to be able to
delete that element. Other than that, we would need to be able to read that element. So freaking that's what that is. Now, even
if I'm not right we can always fix this in the future. So freaking ok, what we would have here is a freaking...so we wouldn't
need a filter on the delete or read functions...would we? It wouldn't be a filtration mechanism. So ok, what we would have is
a filter on the add and edit functions of the mechanism.

So now we have to like ask ourselves some fundamental questions: what if we wanted to insert code before or after the read,
edit, add, and delete functions? What about our array itself? Does it just stand alone and that's it? Or does it need stuff
"before" and "after" it? What else is possible? Freaking yea dude, what is that? What does all code come down to? Freaking
glorious question.

So, we begin. Lets come up with a rough sketch by going ok, we have an array, then we have read, edit, add, and delete
functions for that array. So freaking ok, we have an array. Then, we "add" an element. What we do is systematically filter
input when we do this. So freaking what that is is...we either manually enter a filter (a regular expression or something, wide
open), or we generate one (somehow). So freaking ok, umm...if we manually enter one, what we would have is some code, not a
regular expression, so we could completely control the filtration (the filter is therefore some code, so you could, for
instance, utilize the "unique" function of mariadb). So freaking ok, umm...we would apply this same filtration mechanism on the
edit function. So pretty much what we have to come up with is an automatic filtration system for this thing. Or like a
relatively automatic filtration system. The more automatic the better. So freaking ok, umm...so like what we would have is...is
that all we would have? An array with some filtration? So like what we want is a freaking completely automated system, long
beyond the scope of php and the like. Freaking like, just a completely automated system. So freaking how do you build THAT?
Hah. That's so what that is. So freaking ok, umm...

Ok, so freaking this is going to be a task and a half. So freaking ok, what this thing is is an array with some I/O, so
whatever we end up with, that is AT LEAST what it is. So freaking ok, now what? So we just keep digging until we get to the
bottom of it. So like freaking ok, it would be an array, then it would have some elements, then we would order/edit these
elements...so like what is the extent of everything we can do with these elements? With this array? The maximum would be
something like infinity, the minimum would be something like 1. In fact it would be "1". So ok, umm...freaking a...what this is
is...there are infinite possibilities, and freaking a finite amount of characters that define the code that is this string. So
freaking ok, you have two options: bail, or stick it in there and fucking go for it. Fuck yea.

Freaking a dude. How is this going to work? How are we going to earn an income while we're doing this? That's totally what that
IS. Freaking a. Umm...huh...ok the thing is we can speed up production by generating some stuff: if we use a filter and an
error message if that filter fails we end up with some generated CRUD? Yea that's like what that is. So freaking that is, at
least, the way to go. So freaking ok, what else? Umm...freaking...ok like what this is is...we'll overpower it dude, just keep
going. Freaking don't stop dude. DO NOT stop. So fucking ok, what this is is...

So freaking ok man, what are we going to do today? Do we freaking press on with this thing or try and get some work done? If we
try and get some work done, what exactly do we do? We generalize everything, to a point, so freaking ok, what we do is...we
come up with some syntax to drive this thing, so like ok, we would generalize the process of creating a table, and the CRUD for
that table, so...so we have something like:

<?php



?>
...

Is this even what we want? What if we want something different, I mean what if we want to freaking go for it? Should we just
work on that or do this? We have to like do both at the same time. So freaking ok, umm...freaking umm...jesus dude...the dream
is so freaking big. So freaking what we do is...we freaking...umm...

Ok how do we do this? Freaking a dude, it's something super simple, freaking umm...there's a way to do this. There's a way to
do all of this, and the thing is, there's no difference.

So freaking ok, umm, there's no difference, now how do we do this within that context? Or what? Do we just keep chugging along
with our array, or what? I mean it's all string, just I don't really understand...you know what the answer is in there.
Freaking ok, if we have an array...what if we have some syntax? Like what does this thing LOOK like? Or like what? Or are we
just being wackoffy instead of getting to work? Umm...freaking...so like freaking ok, umm...so like ok, what do we do here? I
guess just start coding this thing? Less talk, more rock? Umm...freaking...hmm...so like ok, what we do is...freaking...umm...
just start coding dude...ok so like what we could do is generalize things, to a point. So like ok, now, if you freaking take
everything and go ok, so you create a thing to generate everything, what exactly is that, IN SYNTAX, so we can get a good idea
of what it would take to fully-automate this thing? Like ok, so we type freaking some commands to generate an array and I/O. So
freaking ok, what that is is:

<?php

include("Cinder.php");

$Cinder = new Cinder([
	
]);

?>
...

So freaking ok, umm...do we need some syntax or do we need the core idea? Like basically we just need the idea. So ok, we type
in some syntax, and the thing generates code. So freaking ok, umm...so we have the syntax, now what if we reduce the syntax to
a single 1? Or close? What if we reduce it to a 1 or a 0? I mean I'm just trying to come up with a way of doing this, it's like
so freaking complex. So freaking complex. So like ok, umm...so what we do when we do this is we indicate...:

<Cinder>
	<projects>
		<project>
			<tables>
				<table>
					<name>My Table</name>
					<columns>
						<column>
							<name>Test</name>
							<definition>
								<type>VARCHAR</type>
								<arguments>
									<argument>200</argument>
								</arguments>
							</definition>
						</column>
					</columns>
				</table>
			</tables>
		</project>
	</projects>
</Cinder>
...

So like ok, there is a lot of stuff here...so like what we would have to do is use a syntax that broke down, bit by bit, so we
could define extensive definitions if we wanted to, and not if we didn't. This way if we need more definition to define
something we can give it, and otherwise it's good (and doesn't require a ton of definition). So freaking ok, what this is is...
ok what if we break it down to lines:

<?php

include ("Cinder.php");

$Cinder = new Cinder();
$Cinder->project("Test");

?>
...

So like ok, then we have methods of Cinder, so...then we just define, line by line, all the code. So freaking ok, now how do we
reduce the number of lines that it takes to define something? Macro's? We would have to, at some point, define table and
column names automatically. Any idea how we would do this? Or what? Freaking umm...ok so like what we did in the beginning was
go ok, we have some code that defines multiple things (that are very similar), then we compress that code until we end up with
a generalization that we can use to speed things along. So freaking ok, umm...so what we need to do is figure out how
multiples, in general, are similar so we can generate them (with less or no code). So freaking ok, umm...so like freaking ok,
umm...freaking...so in general, umm...like what I'm trying to say is that we have two things, so we generalize them into one
thing, then we have two things AGAIN, and then we generalize them into one thing AGAIN. What I'm trying to do is say this in
plain english, or even thereabouts, so I can get a good idea of what it is I'm trying to do, or doing. So like ok we would have
multiple webpages, then we would have multiple websites, then we would have multiple...? Things? What is a thing? So freaking
ok, umm...so like...so then we have two websites, then we have...then like that's it as far as Cinder is concerned. So freaking
ok, can we define two things in a deeper way that we are down with? Do you have ANY interest in two things beyond that point? I
don't even have any interest in two things at THAT point. It's not right. It's supposed to be one thing. So freaking ok, now
how do you do this? How do you generalize all of this stuff, down to a point, with one thing, and not two? Like how do you
generalize one thing? That's basically what I'm asking. It doesn't make any sense. You can't generalize one thing. It's already
generalized. So is there a freaking way to do this then? Or are we just stabbing around in an empty, dark room, for nothing?
Umm...ok so we have two websites, now what? Then we like freaking...then we figure out what a website IS, and then generalize
the process of building one. So what is a website? In general...ok so a website could be anything, a website could be a
freaking dog! Shit! Dog shit! Dog! Shit! Dog shit!

So freaking ok, now how do we do this then? Is there a point? Or is all work the trudgery, the gruelery, the hatred...freaking
ok, umm...so like what this is basically there's a heap of work to do and nothing else to do but do it. So freaking ok, umm...
like ok, where we start is...like...ok so we have everything laid out in terms of string, everything is one thing, string. It
might as well be anything at that point, but the important part about this is it works. So freaking ok, we just continue the
same way we got here, keep it consistent, and keep marching through.

So ok, how do we build this thing? What is the next step? And so on and so forth? Freaking umm...so ok then we define what the
first thing about this is...we go off the top, and scour the whole thing clean until we can clearly tell what it is we are
looking for. We have to find something...we have to identify what something is out of pure potential, so we have to go from the
top to the bottom: from all the way up, with the volume completely cranked, where we have something consistent to work with, to
the very bottom, dead and complete silence, where we can tell what that thing is.

So we begin.

So freaking ok, umm...this thing is potentially anything, so how do we reduce that potential to the point where we have this
thing coded and it works and everything?

Ok, what we want to do is reduce everything to a single thing, then reverse flow and generate multiple things consistent with
that one thing. So basically we have one thing, and that thing can replicate and make multiple things. So freaking ok, what is
this one thing? Also, we need to get shit done dude! The thing is, it IS possible to do more than one thing at a time. You can
prove this, you can do this. So prove it! So prove it and then do it! So just do it! There is no difference.

So freaking ok, umm...so potentially this thing is anything, potentially it is maxed out, 100%. Potentially it is also minimal,
0%, "1". So which is it? Well, it's the greater, by comparison. So freaking ok, it's maxed out. So what does that MEAN? What
that means is we (at least) have to go through every possibility that this thing has to figure out how it works. Like the thing
is it freaking can do anything, when it's done, so you have to figure that out. You have to figure out how something BIG does
everything. So like freaking you have to figure out, from the top down, every bit of generalization, all the way down to the
bottom. Freaking a. This is like not going to be easy.

So how can something like this be generalized? Basically, every so often there is a point where things become such that they
can be generalized, so like strings turn into numbers, numbers turn into booleans, and thus can be generalized. I think. This
WOULD make sense...this like makes sense, yea that's what that would be, is we would have generalizations...so ok we would
generalize, say, string into numbers by character code, or something like that...technically speaking we wouldn't need to know
what that was. We wouldn't have to know what anything was. So what is it if you don't know what anything is, if you are not
capable of knowing? What are things if there is nothing? Something? Nothing? If there's nothing there, is there something there
or nothing there? There's something there. We know from experience that there is something there. That's what that is. So like
freaking ok, umm...

Ok so like we need to do some stuff: first, we need to designate what "one" thing is. Is it a website? Is it a "thing"? It's a
"thing". So...code...so ok a "thing" is a "website" in that I have to start somewhere. So what is a website? A website has a
URL, probably a name, a description, so on and so forth. It has a nested structure, it is recursion-friendly. It has elements,
nodes...ok so what is a website? A website is a collection of webpages. And what is a webpage? A webpage is an array of data
displayed on the view. That's it. It's styled and stuff, but I mean really it's just an array displayed on the screen. 
Fundamentally, a webpage is an array displayed on the screen. So ok, now, what is the "peripheral" of an array, then? Or, how
deep does the rabbit hole go in terms of arrays?

So an array...like...freaking ok, this is BAD. Dude this is BADASS. A freaking array, ok what is an array? What a QUESTION! An
array is a freaking collection of elements...what all can you do with an array? So ok, you would need the ability to...you
would need the ability to get in there before and after array elements, so BEFORE the ELEMENT itself you could make something
happen, and AFTER the ELEMENT itself you could make something happen. So ok, does something HAPPEN BEFORE and AFTER an array
element? Umm...or is this even the question to ask? What is the easy path? So basically you would need to be able to input and
output an array, so set an arrays elements to certain values, delete array elements, and display array elements to the screen.
That is AT LEAST what that is. Ok dude! You have a sprout! So ok man, freaking what is this bad boy? So we have input/output,
so freaking umm...we have a freaking array, and...input/output, so one thing, an array, then input/output, two things. Ok? So
freaking ok, umm...yea then from there we build the thing...so what do we have here? We have an "array" class that has input
and output methods. So freaking ok, umm...now, maintaining the fact that something like an empty string IS a value we have to
expand our input to add, edit, and delete, and our output is simply read (or just "output"). So freaking ok, umm...then, what
we're going to need is filtration on "add" and "edit". The thing is, though, that this stuff needs to be granular, so the whole
structure builds up further from that point and breaks down perfectly. Not even gracefully, perfectly. So what this means is
that every little thing comes down to one thing, and not two.

So, how do we build it? Well, we have a master class, "Cinder", and from there...or what? Ok so at some point this would be
"Cinder", because that's what we want, so that's at LEAST what this is. So freaking you're good to go, carry on. So freaking
ok, we would have a central class, and there (or so) we would have an array. So then we need to be able to edit and output that
array, so we have a simple set of I/O functions ("input" and "output") that set the array's value and output that value. So
freaking ok, umm...yea that's what that is. So if we just stay on top of it and make sure every one thing is accounted for,
this works! It freaking works. So by the time it hits the ground you've got it all figured out, just code the bad boy. So
anyways, so we would have an array...are we sure we would have an array, or what? What if we want it to be something else?
Umm...what if you generalize the process of building something that generalizes something? Like we go from building static
websites to building programmatic websites, and we therefore generalize the process and get more done, what if we continue this
pattern until we max the thing out?

Freaking ok, so what do we do when we go from static websites to programmed ones? We figure that it is better to "program" them
because that results in more with less. So freaking what does this require? What is already there, at that point? So we need,
at least, some memory, to store even the code itself, and like that's it. Freaking ok, so where do we go from here? Like ok,
umm...so we have some memory, then we go ok, we loop. We loop through stuff to come up with "generated" content. So like what I
mean by that is in order for programming to have any point it has to loop through memory to generate content, otherwise there
is only one thing there and there is no point to "programming" the thing, where "programming" therefore means looping through
memory to generate content. So freaking ok, umm...so there's no point to programming. Well, there's a point, but it's not a
good one. Well, it's a good one, but it's not as good as not programming. So freaking ok, what you're trying to achieve isn't
that pure, but it is, if you REALLY want it, just don't go for it unless you're damn sure you're down. Like we're looking at
the end of the world, we're totally in that context, so if you're not right, if you're not SURE, don't do it! You'll likely end
up way deep in hell, and that totally SUCKS...like I mean it's freaking dirty and nasty down there, that's totally what that is
is freaking getting comfortable with the universe. So freaking ok, umm...so why program these things instead of building them
static? Huh...I mean ok, what is the essence of acceleration and, ultimately, maximum speed itself? So acceleration is where
you take something and you increase it somewhat exponentially. Speed is where one thing is moving FASTER than something else.
So freaking ok, umm...so what we want is to "accelerate" until we reach "maximum speed". So how we do this then is...to move
FASTER than something else; that is both acceleration and speed. So freaking ok, at some point one must make the quantum leap
from one to two...from there the math is simple, but until that point, how do we do it? So like ok, the way things would work,
in terms of acceleration, would be something like multiples of two; so much acceleration equals so much exponentiation of two.
So freaking ok, umm...therefore one is two to the nth power. So freaking ok, umm...is there such a thing? Or do we need to come
up with some other...ok so what if the equation is:

x = 1 * ((2 ** y) / 2)

? That fits our curve. Freaking ok. Umm...so like that's what THAT is. So freaking ok, umm...yea dude! Smoke one. So freaking
ok, umm, now what? Now, like, how do you apply that formula to your project? Freaking umm...huh...code this thing.

So now reduce that to single steps, 1, 2, 3, 4...

So if y = 1, x = ...

Ok so:

x = (2 ** y) / 2

Or just x = y...

Ok, so what is the extended form of this? Any working code...anything that works! Freaking a. Anything works because there is
variability when there is no variability. The limitation of no limitation. So now, foo, freaking build this thing up! So what
about it? What if you have an array with input/output? Any form of x = y. So that's what that is! Freaking a! Ok, so it can't
just be anything, so then what is it? Freaking a. Ahh freak...

I don't think this is right.

y	x
1	1
2	2
3	4

Yea that's not right...dammit. Ok but wait what was I trying to describe?

x = Math.sqrt(y ** y)

y	x
1	1
2	2
3	3

Ok this fits...freaking ok, so what was I going for? So I'm trying to descibe an accelerative model...I need something that
makes a lot of a little, so...umm...now how do I fit code to a curve?

So either the previous equation or just:

x = y

...so freaking ok, as long as...now what does this describe? Why does x need to equal y? Because then there is no difference!
Part of what we were trying to describe is indifference. So ok, what is a model that fits this equation? What is a model that
fits the equation: x = y?

So freaking ok, umm...how do we do this bad boy? Or what? Ok so we need to get some stuff done, still, so I mean...huh...ok umm
so what we'll do is just start working and hope for the best? Or how are we going to do this? It's all string, so I mean...so
ok should we just start hacking at it or what? Won't it become obvious once we get there? Like once we get some stuff DONE, and
by DONE I mean working and on the screen and everything, won't it become obvious what we need to do to proceed past that point?
Jolly good point. Let's say we made a simple static html page and did this:

<html>
	<head>
		<style>
			* {
				font-family: Arial
			}
			body {
				margin: 0
			}
			#header, #display {
				padding: 15px
			}
			#header {
				background-color: black;
				color: white;
				font-size: 60px
			}
		</style>
	</head>
	<body>
		<div id="header">
			Cinder
		</div>
		<div id="display">
			Hello world
		</div>
	</body>
</html>

So ok, first things first, what we need is programmatic stuff, so php. We're inside index.php, so all we have to do is add the
php code. So freaking ok, then...so ok, in plain text, like in pre tags, what this is is we have our php file, and what would
happen is we would write, to start with, so when we read it was up to date, and then we would read our data, then we would
output our html, and when we do this, it's a matter of a mix of html and php. So what I'm getting at is that there are forks in
there that we have to account for: php embedded in html, css, and js. So ok, now why not xslt and xml? If we do that, we have
to use (rather) static webpages...is there a point to not using straight php instead? Fuck dude, we're GOING to get to the
bottom of this, just keep chugging along. Chug. Chug chug. Ok dude, so freaking umm...so what we would have is...php, so
forks in php (if/else, switch, etc.), then we would have html, so forks in html (script/noscript), then css (php executed
inside css, before css), and finally js (php executed inside js, before js). Then, anything else would be put in order with
everything else, so like xslt, xml, etc., all filed in there logically (at that point in time). So freaking ok, umm...so what
we would have is:

php
	forks
		if/else
		switch
		etc.
html
	forks
		script
		noscript
css
	forks
		php code embedded in the css, fires before the css
js
	forks
		same as css

So freaking ok, umm...then what? So ok, then IN GENERAL, what we would have is...so then, first off, we would have looping
inside of php. So then the thing is, forks can come before or after looping...but like the thing is they would come AFTER
looping, otherwise we can't conditionally loop, simply put. So then we have loops...:

php
	loops
		forks
			if/else
			switch
			etc.
html
	forks
		script
		noscript
css
	forks
		php
js
	forks
		php

So like what we have is php controlling the whole thing, because all of the looping/etc. is happening within php. All of the
"looping" is happening within php: we loop in php, then we output html with php and that's the html, so all we have is php. And
we're simply within a php file, therefore all we have is php. So freaking ok, umm...so do all the php first, then go from
there, or simply plop it all down in php, one thing. Freaking ok, umm...so that's why php. :) Oh freaking kay, so start coding
or what?

So like freaking ok, what we have is an array of data, then some code "interpreting" that data. So what that means is like we
would read the users from this array, and that's how we would log-in to the system. Then, we interpret the array in a different
way, and read the webpages. So freaking ok, umm...so then we have data and interpretation: one data and one interpretation. So
the next thing that naturally follows is to figure out the interpretation. So freaking ok, how do we do this? Fundamentally. So
ok, umm...so like what we would have is a value with a type...are you SURE it's a value? Umm...freaking umm...so like what
would this be? Freaking umm...so like you have to bridge the gap between these two points, between the heavens and the earth,
between our idea and the view. So freaking ok, umm...what we do is inch our way towards our idea from our view. Or so it seems.
Even if we do...so where are we here? We have a bunch of data that adds up to a view, so then what? Then what do we need to do
from that point on to get to our idea? So ok, what we do is load all the data that has a parent ID of 0, and display that on
the screen. So freaking ok, umm...what about users? Or are users just "another form of data"? So like what we would do is...
put the two of these together into a single table...then read that table and thus read the array data into the view. Now, what
if we put these both together into one table? So freaking ok, umm...ok so the thing is, you KIND OF have this thing down! You
have an array with I/O. So then just put that together with a view that you want and stuff...so freaking ok, how do we get from
where we are to THERE? So like umm...we have an array with our users and other data in there, all of our data is in there, then
what we're doing is carefully interpreting that array...is that the problem? So now inch your way there dude. So freaking ok,
umm...so the array is successful, so then we just use that...so like what we do is interpret this array, with hard-wiring or
otherwise, and that's what that is. So freaking ok, umm...fundamentally how do you do this dude? Just start building. So
freaking ok, we're fundamentally building...so freaking ok, umm...so like ok, what we have here, at least, is a conditional
statement. So what we have to do is generalize all conditional statements. Fortunately this is basically already done, as true/
false is what runs a conditional statement, so there are two possibilities, with true being the one true path of the thing in
the end. So freaking ok, umm...beyond that point there is only one thing going on. So freaking ok, umm...:

<?php

$boolean = true;
if ($boolean)
	// do something

?>
...

So freaking what this means is...so like what we need is one thing that we can do over and over again. Freaking something,
SOMETHING. So like what we have then is php code. So freaking ok, umm...hmm...so ok what we are doing, or what we need to do,
is generalize the process of forking...so like ok, umm...so do we need forks before loops or loops before forks?:

if logged in
loop through data...

So how do we know if we're logged in? A session variable that says "logged in" or something like that. So freaking ok, umm...
when would we need to...so like basically what we would have is:

if logged in
loop through data
if not logged in
loop through other data

So freaking ok, umm...so generally speaking we would need to check to see if we're logged in before we loop, so that's what
that is, is we fork before we loop.

So freaking ok, if we make this thing out of forks and loops, then what?:

fork
	logged in
		loop
			display loop data
				fork
					condition
						loop
							display loop data
	not logged in
		loop
			display loop data
...

So generally what we would do is fork, at which point we check a condition, then loop (based on the direction the fork went
in), at which point we display the loop data. So freaking forks and loops. Ok, umm...so what if we build a master system out of
forks and loops...ok so how do we reduce those to one thing? Or I mean...there IS a finite number of them (two), just...if it
isn't one it isn't going to work! Freaking a! So like what if we have a recursive function that does something conditional
(forks), and then...yea I mean that would work? That appears to work. Ok so we have a fork. So freaking then what? Freaking
umm...so then we build this whole thing out of forks. This is going to be so freaking hard...ok it's not going to be hard, it
just seems like it. So freaking ok, ummm...forking ok, umm...umm...so ok now we have a master system, now what? If we can...ok
so now we build code out of these forks, or we build everything out of them, then when it breaks down it breaks down neat and
clean...what does one of these look like?:

<?php

function fork($condition, $callback) {
	
	if ($condition)
		$callback();
	
}

?>

So it would look something like that. So freaking ok, there's like no reason to have one of these, except it reduces all of our
code to one thing. So unless we break code down to single characters or something like that this is definitely the route to
take. Freaking umm...here lets make one of these real quick and use it and everything and see if it works:

<?php

$array = [0, 1];
$key = 0;
$looping = true;
function loopOne() {
	
	global $array, $key, $looping;
	
	echo $array[$key];
	$key++;
	if ($key > count($array) - 1)
		$looping = false;
	else
		fork($looping, "loopOne");
	
}
function fork($condition, $callback) {
	
	if ($condition)
		$callback();
	
}
fork($looping, "loopOne");

?>

Works! Hah! Oh freaking kay, now we have the factorial power, take the day off and relish? Umm...pee.

Ok dude! Onward! Freaking a! So then what do we do? Then where were we...so we loop through our array with this thing...umm...
so ok we have to loop through user data (and make sure a user is logged in or not) and freaking like...check passwords and
everything...then we display data on success, so freaking ok, umm...so generally what we have is:

index.php
check whether logged in to backend or not
if so, commit input (if user has the required priveleges)
...

So freaking ok, we need something that: is like, stretchy. Like we could need any number of things...when a user goes to commit
input, there could be any number of privelege levels that could be in effect, so like...we need a thing that checks a value
against a battery of values and returns a 1 or a 0 based on that comparison (1 if it's true, 0 if it's false). So freaking ok,
umm...like, bottom line, there could be any number of things that a website could do, so...we would make some sort of
comparison and output accordingly, so umm...so we have like a switch statement...so freaking ok, umm...so like, several
priveleges, several webpages...so what we do is look through the possibilities for a match, and...ok so we loop through the
possibilities, looking for a match between a given value (given through output or something), and freaking something in the
loopable, then we do something based on any match found. So like ok, in terms of looking through users to confirm that the user
is logged in...so like this would be an arbitrary sequence of a log-in view and logging the user in, and thus, also, checking
whether the user is logged-in or not. So freaking ok, umm...then we would display the array, if the user is logged in, and if
not, we would only display part of the array. So like ok, umm...so like what we would do is display the array anyways? Huh...
tough shit. So like the array would be the website, and the input would be reserved for users only, and the output would be for
everyone, so the website would basically be the output. So freaking ok, umm...so how do we reduce the input to such simplistic
terms? Or what?

Umm...freaking umm...huh...so where do we go from here? So we have conditions covered, so two things, so then what? How do we
go from there to one thing? Or what? I mean the fork covers everything...we can fire it with a constant as it's condition and
it'll shoot something off (arbitrarily). So like umm...so yea where do we go from here? Freaking umm...huh...yea what is that?
Ok so off the top...so we want a system that solves all problems, so like what is that? In terms of "fork", what is that?
Umm...freaking umm...so like we have an array and a fork. Eat up! :) Umm...so freaking ok...so how would this thing go?:

index.php
log-in user
if logged in
if has priveleges
commit input user has priveleges to commit
discard the rest (or save it or something)
read data for output

Ok so lets reduce this a little bit. What if we just have an array? What is the output then? So we just print_r it to the
screen, so otherwise what we have is some code that determines what we do with the array. So ok, umm...freaking umm...so like
what do we do here dude? Freaking a.

So like ok, run down what you are trying to do again, off the top. Go "off the top", is what I'm saying, go from the general to
the specific. So ok, what I'm trying to do here is...build a system that can handle anything, that can basically generate
accurate data from less, accurate data. So it extrapolates, it's an extrapolator. Freaking umm...yea...so like ok, umm...what
do we do? We have to DO something. Freaking umm...like we definitely start building, TODAY! We have to start building dude.
We're totally just sitting here chilling and not getting anything done, like completely disconnected from the real world and
shit. So freaking ok, umm...just keep chugging along dude, eventually (and not even in so long a time), you'll run into the
fact that you need to speed it up, which is like the moment you take a look at the speedometer. So freaking ok, umm...(glances
at the speedometer) yea, we need to speed up. :) Naa ok dude, just trust yourself, trust your system.

So freaking ok, umm...so freaking CAN we use a qi to make it through to heaven? Even if after we die? Umm...there's no
difference, therefore we both can and cannot use a qi to do that. So freaking ok, what this means is...there's no difference,
so we can do whichever we want to. So freaking ok, umm...so there's no difference, so...so like there's no difference between
the two. So it's freaking a trick question. There's no difference, simply put. Therefore you can do whatever you want, you can
do either of the two (and it will work).

So freaking ok, that's what that is. Freaking a. So we can even just sit here with a qi and it'll go through there, it's all
good. Yea that's what that is. So freaking ok, umm...otherwise how do we do this? Do we just code like a madman until we get
there or what? What SHOULD happen when you start coding is it should start to curl in a circle, at which point you SHOULD be
able to tell what this thing does in a circle (how big of a circle it is). Then you just code the circle (which you'll already
be doing) and you're done! So HYPOTHETICALLY that's what THAT is. Now, lay it down:

<?php

class One {
	
	public const ONE = 1;
	
}
class Zero extends One {
	
	public const ZERO = 0;
	
}
class Fork extends Zero {
	
	public function fork($condition, $callback, $dieReason) {
		
		if ($condition)
			$callback();
		else
			die($dieReason);
		
	}
	
}
class Cinder extends Fork {
	
	
	
}

?>
...

So freaking ok, umm, so we have a fork...where does that really get us? :) Like what if we have a log-in routine that returns
to the log-in screen if the given credentials aren't valid. Then we don't just have a fork, we have a fork with an alternate
route. So ok, I mean we could, at that point, just use straight php. Is this a good idea? Freaking umm...does it even solve any
of our problems to have a fork and a one and zero constant and all that? It's less code to just type a 1 or a 0, and it's like
less code to just code straight php than code forks. BUT, you HAVE them, at the core of the beast. That is what is important,
is either way they are still there. So freaking ok, umm...either way dude. Either freaking way. So freaking ok, umm...that like
implies brute force to do this. I'm just all fired up, I want the thing DONE. I mean I know it's all good, and we can take our
time, and not even get there, but I just want the thing SAID and DONE! Fucking a.

So freaking ok, umm...you need to run some tests. So it's definitely less syntax to just type a 0 or a 1, so the "One" and
"Zero" classes are out of the question. What about the "Fork" class? Ok so like every time you use it you have to define a
function to callback, which is more than a variable name (two characters ("$a", for example)). So freaking at this point this
doesn't make sense. Isn't that it? Yea that's it. Well I'm pretty sure that's it. It doesn't matter, either way. So freaking
ok, if we use one if statement versus our "Fork" which takes less syntax?:

<?php

function fork($condition, $callback) {if ($condition)$callback();}
if ($condition)$callback();

?>
...
<?php

$condition = true;
function callback() {
	
	echo "Hello world";
	
}
function fork($condition, $callback) {
	
	if ($condition)
		$callback();
	
}
fork($condition, "callback");
if ($condition) $callback();

?>
...

So it actually takes less code to code a straight "if" statement than it does to call "fork". What if we shorten the function
name of "fork"? We still have to write the functions that we will supply as callbacks, which requires (at least):

"function funcName() {"

As opposed to just:

"if (condition) {code}"

So freaking it doesn't make any sense to do this. So freaking ok, umm...so what do we do? Are you SURE that's what that is?
Does it catch up at some point in time, or is it just plain more...:

<?php

$condition = true;
function c() {
	
	echo "Hello world";
	
}
function f($condition, $callback) {
	
	if ($condition)
		$callback();
	
}
f($condition,"c");
if($condition)c();

?>

So ok, it's LESS code to use our fork, after a billion repitions (in fact, a billion repititions would save us a billion
characters). So freaking that's what that is. So freaking we DO use our fork, and freaking what ELSE? Ok actually that's not
true! There's a dead tie! Freaking a dude! So which takes less code, to code a straight "if" statement, or our "fork" method?
Ok so we can simply analyze our previous code to figure this one out...so it takes more code to declare the "f" function, and
then call that function, than it does to just use a straight "if" statement real quick. So that's that that is. So freaking ok,
umm...so the thing is calling the "f" function and using a straight "if" statement both take the same exact amount of code, so
OTHER THAN THAT, we have to declare the "f" function, which takes code, which takes up more space than a straight "if"
statement. So that is, in fact, what that is. So freaking we have straight php again. Now what? Start freaking coding or what?
So like ok, now, if we had an array made of objects, we would have our array itself, which would like reside in "Cinder", then
everything after that would be inside the array itself, so like then Cinder would interpret that array meaningfully...so
freaking ok, umm...like what we would do is...so freaking hard dude. Fuck. Fuck fuck fuck. Fuck fuckedy fucklesworth. Fuck. Ok
so freaking what we would do is...freaking...I'm out for the day.

Ok I'm back. Gonna make 3 more hours to get up on it a little bit. So freaking ok, umm...so like what do we do with freaking...
like ok if we have one thing, then what? Then what do we DO? You've successfully reduced it to one thing, then what? Then we
freaking build the thing up, so like we account for freaking everything. Is that really the way to do it though? Or should we
just work along the lines of the potential? Like should we just plug away at it any old way or should we like calculate a way
to go about it? Like by calculate I mean like, freaking, figure out what to do beyond the point of everything being the same
thing and then do it. That's roughly what I mean. Freaking umm...freaking a, like, ok, umm...so what WOULD we do IF we were to
calculate our way and go that route? Like freaking ok, umm...so we freaking come up with something...anything...like what we
have to do is calculate the potential of the thing and then build that, whatever that potential is.

So potentially this thing can do anything! It sounds nuts, but don't let that stop you! So freaking at this point you have to
consider, what if you just like force a qi through there (in an instant) instead of plodding through this project? Freaking
umm...hmm...like ok umm, either way. So how COULD we force a qi through there? We just hold out our hand, stand in front of a
moving semi-truck, and watch the magic happen. But really this isn't that realistic. We COULD get hurt. And we can't handle
that right now. So then the question becomes: do we freaking build this thing or work on getting some shit done? Both? How do
we do both? Freaking like ok, we handle the more pressing matter, getting shit done, and while we do that we get this thing
done, so like we figure...I mean this really doesn't make sense, we're talking about moving more slowly than otherwise to get
more stuff done. That doesn't make any sense. It doesn't even make sense. Like ok, what if we don't have food to eat or air to
breathe? We'll have those things either way. So freaking ok, it COULD be BETTER by getting shit done, or rather we COULD do
BOTH at once. So freaking that's what we do. I have no idea how we're going to do this, but we're going to do it. So freaking
ok, we have an array:

<?php

$array = [
	"users" => [
		[
			"id" => 1,
			"username" => "Cinder",
			"password" => "some_pwd"
		],
		[
			"id" => 2,
			"username" => "test",
			"password" => "some_other_pwd"
		]
	],
	"pages" => [
		[
			"name" => "About",
			"structure" => [
				
			]
		]
	]
];

?>
...

You know what dude lets just hit it and get a move on. Let's fucking beat it.

Ok man, so if you build a thing that builds a thing, so if you have some syntax that defines something else, does that come up
with something that is accurate, to a point? Like CAN you hyper-generalize things in this way, or is this simply not possible?
Hmm...freaking umm...there's like only one way to tell: code. Just start coding dude.

Ok so what if we do THIS: we code some of the classes of the array, with each element being an object, and see what we get.
There will probably be some stuff in common that we can draw on to get an idea of where to go with this thing. Smoke one man.

So freaking ok man, you have your work cut out for you. You need to build integrated HTML, CSS, JS, and PHP compressors,
freaking man this is going to be nuts. Like what you do is freaking build a main system that does all this stuff,
automatically. So like you export the site and it compresses everything and everything. So freaking ok, umm...we could probably
start with some CSS to get things moving. So freaking ok, umm...the thing about this is if we don't do it right, and I mean TO
A POINT, we have to freaking rebuild this thing whenever the slightest thing changes. A feather freaking falls on this thing
and suddenly you have to rebuild the whole, damned, thing. So freaking ok, umm...so freaking ok, umm...like freaking ok, man,
you totally have this!? Freaking a! So like freaking ok, umm...huh, the potential is freaking amazing from this vantage point.
It's like the freaking northern lights in here. Freak dude, you MUST figure out how to do this! You just MUST! Freaking a, umm,
so like what we do is...drink some coffee!

Ok man, freaking a! Like freaking ok, what you have here is...something that is like not at all systematic. It's freaking big,
it doesn't come to a point, and it won't last. So freaking ok, why not? Like freaking ok, umm...so like what this is is you're
going to have to rebuild this thing whenever php/etc. is upgraded, so like it needs to be VERY graceful. Like what if you had a
freaking system where: all of the syntax were generated by the system instead of manually typed? Like freaking ok, much like a
DOMDocument object, you just output the syntax based on a working object instead of manually typing the freaking code. This
makes a lot of sense...what if the whole thing was built out of forks? Or what? So like freaking ok, how do you make this thing
COMPLETELY freaking tits, I mean beyond time-space, beyond the great blue sea? Beyond the great starry night itself? NOW we are
freaking talking. Ok, so like what this would require is a pipe, a tube, a straight pipe or something like that. It would have
to travel in a circle and be hollow in the middle (of the circle), because what this would be is something that would handle
all data, so like that's what that is shaped like.

So like freaking ok, we build a system, and what it does is...it's the main system, so it is one, and then it builds everything
else inside of itself. So freaking ok, umm...like what this is dude is freaking menacing...you have to build a freaking system
that takes some freaking input...like ok, maybe it's not THAT bad, but I mean...I dunno...it seems pretty bad. :) Maybe it's
not though, I mean how hard could it be to build a code compressor?

Freaking pick this up tomorrow? Smoke one man!

Ok dude, so what do we freaking do? Like once we get (if we get) a fully-integrated code-compressor done, then what? Then we
have to build websites, and freaking...like what a menacing assed freaking thing dude. So like freaking ok, umm...once we get
a code compressor done we have a grip on our code. We can do things like scan for errors and stuff like that (as if errors
generated by php aren't enough!). So freaking ok, umm...yea I mean why would you reinvent the wheel...ok, so, umm...so we build
a code compressor, so freaking ok then what? Like ok, umm...like freaking why not just build the motherlode...freaking a. Yea
why not? Makes perfect sense. Freaking umm...the thing is, can we get this done? What if we build and build and never get
there? Freaking umm...can we have a sphere of infinite size? What can we do with it, still, at that point? Can we trace the
outside of it or...? Like there's no way to have coordinates with infinity. If we have a sphere of infinite size a coordinate
on it is in a place that is like undefineable. We COULD define it, if we defined like axes and then fractions, so like "1/2 to
the right", and stuff like that. Would this really work though? Can we really do this? Does it matter? Does it even matter?
Freaking is it getting you ANY closer to your goal? Freaking a dude. So freaking ok, umm...so freaking like, ok so you have a
sphere of infinite size, how do you draw that on the map? So freaking ok, umm...if you have a sphere of infinite size, an arc
of that sphere is infinite in size. Therefore there is no way...therefore there is no way to map points on this sphere.
Relatively speaking you can do this, but in the end it must be finite for us to handle. Fucking ok dude, freaking a. Like
freaking ok, we're inside a vacuum...dude this is going to work. I think it's working. When we start to spin in a circle is
freaking when it all comes together, because this is only possible because it's (rather fundamentally) circular, which means we
travel the circle and come back to the starting point. If it weren't for this the code would go on forever. It totally goes in
a circle. Call it for the night? Yea lets go.

Freaking ok, I'm back. So freaking ok, how do we do this? We need to code a BUNCH of stuff, and like it needs to last. So like
what if we program a system, basically a programming language...and then we program this stuff with THAT, so that if the
underlying stuff is ever upgraded (php, etc), we just update the programming language and the code still works? I mean yea this
makes sense...makes so much sense...so freaking ok, umm...fundamentally...fundamentally we just start building and we freaking
get there. We freaking GET THERE. So like ok, now you have to consider that in order to build a LOT of stuff you have to build
every possible combination of functions/etc. So like ok, now what if we program something that makes no sense? Like an fread
before an fopen? Or what? Like freaking ok, umm...so freaking ok now what will happen is we'll code like a CSS refiner, and
what that will do is rebuild and organize css until it's completely stream-lined. So ok, now we have to wonder, what if we do
something like recommend fixes based on what we find in the code? Like we find that...like ok, so what if we trace every 1 and
0 until we get there? It will go in a circle. We just have to figure out what that circle is to freaking get there. So freaking
ok, umm...should we just start coding or what? I mean ok, so we start coding this thing, and what we do is trace css...ok so
also we need to trace html, well we need to trace javascript, then css, then html, then, finally, php, and what we do (at
least) is map variable names correctly and stuff, so as to replace long(er) variable names with shorter ones (more
efficient)...now, at this point we can do stuff like trace errors and stuff...so like ok, what if we trace css errors and the
like...is there a point? Freaking umm...damn this is nuts. Ok, so we build this thing, then what? Ok so then we need to just
plain figure out what the root of all of this is. Like ok, from there...yea then from there ok, we're in the central unit, just
we need to keep it that way. So freaking ok, what this is is we have a...what if you just manually primp up your code? I mean
you aren't taking on any huge projects or anything yet. Could work! Which one is faster? Well ok, the thing becomes, in
cascading logic, if we build a thing to clean up code, and we don't just go all the way from there, freaking like, umm...we
have to freaking rebuild like the core of the thing every time we change something. Like every time we build a new website we
have to rebuild the freaking core of the thing. So like ok, how do we not do this?

Umm...so ok, there's no point, then, to building a fork into the thing until we gain our bearings on what is what anyways,
until we clearly identify one, basically. So like there is no difference dude, first, there is no difference. Then, when we get
there, we can program a fork. There just isn't a point until then.

So freaking ok, basically what we need to do is bulk the thing up, until we start noticing redundancies, and then attack those
to get those down to zero, and freaking that's that. So like you figure ok, if it gets so big, it starts to repeat itself IN
SOME WAY, at which point we can reduce it, distill it, to a pure form. So like what is this? So in a website we would go:

index.php
check user credentials
...

Ok so shortly, what would be the rock-bottom of it is a blank php file. We know this because size matters, and a blank php file
is smaller in size than otherwise. So freaking that would be what that is, since we're in php. Hah. Now what? Ok, so now we
have to program our way up from there, so we need to do this very tactfully, completely tactfully. So freaking ok, what that is
is...fundamental programming? 

So ok, umm...are you SURE that's what that is? Yea man, that's as small as it gets, so completely fundamental...so freaking ok,
then we code our way up...first make sure you're right. You totally don't want to make any fundamental errors. Ok so freaking
umm...

Ok what about this, IF we program a programming language, now lets say we bring it to a point, and we have an empty php file.
Now, ok, freaking...so what we would do, in any situation, to do that, is basically include the empty php file from another php
file (that has everything coded, so runs correctly). The only reason it would work is because of the rest of the coding, in the
file that included the empty php file. So freaking what that means is...now lets say we magnify the view a little bit, just one
tiny little bit, so there are two things, instead of one: what do you see? Like basically what this is is any old computer
program, so freaking ok, umm...so like basically what this would be is:

<?php

function func1() {

	echo "from inside func1";

}
function func2() {

	echo "from inside func2";

}
func1();
func2();

include "index.php";

?>
...

So like ok, we have two functions...that would be the magnified view, then the include directive would be the point at which
everything becomes blank php, completely fundamental, so ok, umm...so like effectively what we're doing is creating a wrapper
function for these two functions: a function in which these functions are called ("func1", then "func2"). So freaking ok, now
what if you call them in the reverse order? Then you could (would) have two functions...so then you have to wrap those in
wrappers, and this doesn't work, because it never comes to a single point. So freaking that's what the short-circuit of THAT
is. So freaking ok, what do we do then? We bring it to a single point. It like doesn't make sense to freaking...things have to
come to a single point, otherwise they don't make any sense. So ok, now IF we did this, what would be the point of having any
code, of not just having a blank php file? Does having anything other than a blank php file therefore ruin it? So ok, if you
had two functions that you wanted to centralize in a single wrapper function you would have to have two wrapper functions
because those two functions (that are being wrapped) could go in either order. So both things have to come to a single point
and go in a single sequence. So freaking that is what that is.

So then the question becomes, what is the sequence? So freaking ok, umm...how do we figure this out? Just code the damn thing?:

<?php

function start() {
	
	
	
}

?>
...

Or is this the way to do this? So freaking things come to a point, so what is that point? Or, fundamentally, what are we doing?
What is going on here? Freaking umm...just code dude. Freaking like ok, so if you make a core class ("One"), then...then you
make a "Zero" class, and...then you just like code from there. So like ok, if we fail we do something with the zero class like
fail or whatever, or what? Or like we have an Error class that extends the Zero class that...freaking like...handles errors and
stuff like that, then what? So like we draw out a little arc, then a bigger one, until we draw a circle, and we're done. So
ok let's just start coding and see what we get.

So freaking ok, we have an error handler...what else do we need? A database connector (mysqli will work for this), a filesystem
class, freaking...umm...hmm...an image cropper, a rich-text editor, so on and so forth. So freaking ok, umm...freaking sit back
in the captains chair...so freaking ok, umm...what do we do? So we code this thing, so like lets start coding the
code-generator.

So ok, does this even make sense? Or do we need to code these things one at a time? If you generate code...can you nail it? Can
you absolutely nail it?

Freaking ok, so there is a sequence to things, does this mean that things come down to any old one thing, or do they
specifically have to come down to a qi? So freaking ok, umm...freaking...so like ok, all code has to happen in a particular
sequence for everything to work right, so like ok, what does this mean?:

write
	filter
	files
	database
read
...

So freaking ok, when we write, first we filter. So we filter sequentially, so like umm...so we run successive filters...so we
have to be able to nest filters. Freaking this is going to be complex. So like the filters come before the table definitions
and stuff like that then. So freaking ok, umm...so like everything is all over the place, so basically you can put a project
inside of a client, or a client inside of a project, and the way this works is that, when it comes down to it, projects and
clients are sequential. So freaking ok, umm...what is the sequence? Clients would come before projects. Writing would come
before reading. So freaking ok, clients would be writing and projects would be reading. What the hell does that mean? Lol. :)
Freaking ok, umm...what this freaking means is...freaking a. So like ok, umm...so how does our code generator go?:

tables
	columns
		column
			name
			definition
				type
				arguments
			filters
...

So freaking ok, umm...then we make the thing so you can define anything anywhere, so like ok, why would you put a column in a
table? Why a table in a column? What about other data, like custom tags and stuff? Freaking umm...fuck. Fuck fuckedy fuck.
There's like no easy way to do this. So like basically what we have is table definitions in php, then filter definitions. So
like what we do is...have a filter function that we call whenever we want to filter the data...so freaking ok, like this
becomes a more generalized thing...freaking that way we can get the freaking show on the road anyways. And as far as code
reusability goes, until we have anything to reuse...so freaking ok, umm, you'll have to code these things one by one? Are you
sure that's that you want to do?

Ok so at this point, what if we do something like...so we code these things one by one, then we re-use them as we go along, now
what if we code common components of these things so we don't have to re-code those components? So freaking like ok, umm...what
if we get our hands on an image cropper...yea I mean we definitely need to start building. So freaking ok, umm...so like we
build this thing in wordpress, then we freaking...yea this makes sense. Then we use a bunch of pre-built components instead of
building everything from scratch and...it sounds good, but is it really? Completely sequential, completely logical, it's
making sense. So freaking ok, umm...so like lets get down to business...

So freaking ok, umm...so we have mysqli for database connections, built-in file handlers and stuff for file operations, so like
lets just start coding? Freaking code this bad boy dude. Ok so lets run down some stuff:

write
	install wordpress
...

Ok so freaking...install wordpress, install plug-in's, freaking...so you have to BUILD plug-in's to freaking...to get going
with WordPress. Then, once we get there dude, how do we freaking do business? Just keep chugging along dude. Freaking a. Smoke
one.

So freaking ok, that covers that. So freaking now our log-in/chassis are all legit, now what? Freaking ok, build yourself a
portfolio.

So freaking ok, along the way I discovered that I need a method of organization. Everything is kind of out of whack in terms of
organization right now, and everything needs to be tight. So freaking ok, I propose that we have folders named by date
(MMDDYY) that freaking...have folders numbered 1, 2, 3, and so on, counting from 1 up, and thus we have a completely unique
storage system for everything. The only thing I can really think about is this is going to be super confusing. So freaking ok,
umm...so like what we need is a nested structure, so really all we need is a numbered (or otherwise keyed - so whatever keys
will work) system for doing stuff. So basically anything goes. Freaking 'cause like the thing is if you order these by date and
then by number you have to keep track of what is what. Kinda confusing. So freaking ok, umm...the thing is though...ok so what
is the bottom line? The bottom line is you need unique folder and file names in the filesystem. So freaking ok, like what we
would do is use a layer to assign these, so then what? Then we're inside php, so like freaking ok, umm...then we code this
thing, so umm...ok so then we're inside php so that's one and that's it. Ok so just stay inside of php. We're inside of php,
we're not going outside of php, and...

Freaking ok, so like I started building a portfolio and I was thinking: what is the point? What is the fucking point? I mean I
need work and stuff, but more than that I need a freaking way to heaven. I need the peace of mind of knowing I'm going to
heaven, for sure. So freaking ok, how can I be ABSOLUTELY SURE I'm going to heaven? Freaking umm...ok so like there's a qi,
there's no difference, even strictly speaking, and there are two paths: one goes to heaven, and one goes to hell. So how do I
go to heaven? There's no difference, so just choose heaven. There's a qi, so freaking...ok umm...so like what you do is
freaking go ok, umm, there's no difference, so there's no difference between one path and the other, so you're all good, you're
sitting in a medium in which you are all good. So freaking ok, umm...like there's a way to do this, you just need to figure out
what it is. Like freaking ok, so, in the past when you did your data breakdown, did that yield ANY information about this? I
mean when it came down to it things were 1, which is a positive number, so does that tell you anything? So freaking ok, umm, a
positive number...is true...does it matter whether it is true or false? Ok here we go, if this is a fundamental mechanism, the
question isn't the breadth of it, its the fundamental point. So freaking what I'm getting at is there is a fundamental point,
and the rest of the mechanism isn't in question. So freaking ok, what that means is everything works, so just go for it. Ok, so
that's what that is. Good. Carrying on.

Ok, so I figure what everything is is basically an array that is read through with PHP and output inside of div's. Div's
because they are block-level elements, and other than them, I don't think there are any block-level elements. If we're not
right we can fix it. So anyways, umm, so like what this is is...leaf's displayed in div's. So freaking ok, then one has to ask,
what do we do from that point on? After everything is a div, is that it? Or are there other stylings and stuff that must be
adhered to after that point? 

So freaking ok, umm, so we have div's, is that what every array element IS then? Or like what? Yea what is an array element? So
like freaking ok, there would be...array elements, or one array element, and then...then we would display that array element in
the browser, so like...if we had an array, we would have to do something, if we had a string, we would have to do something, so
like in every instance we have to "do something". So freaking ok, umm...

Freaking a. Like ok, there would be...there would be...like ok there would be an array full of data, recursive and all. Then,
we would need a way to display that data on the view. We COULD just print_r this data and be done with it, but that doesn't
really sate the condition, it's not really a website. So freaking ok, umm...so lets say we used some html, then what? Or is
that even what that is? Like freaking what this thing is is an array with some storage and that's it! No passwords, no
usernames, none of that sheeit. So freaking ok, umm...what this is is...so like ok why do we have an array? Why not a string or
something? Or like what? Like a freaking dog, a mountain, what? Well I figured an array because they hold multiples, and that
is what we are doing is figuring out multiples. Like aside from that there's no work to do, so that was my reasoning. Is that
what that is? Freaking umm...freaking ummmm...like freaking ok, what that is is...so like freaking we have an array, we have
some data in an array, now why do we need to display this data? What is the point? Why not just sit there in utter indifference
and go that route? Freaking umm...

Ok so freaking lets just mix it up and keep going, so now what? Freaking umm...ok so we have a website...where were we here, we
were building our portfolio, and freaking...like ok I was building my portfolio, and what I was doing is...ok I was laying out
data from an array to the screen, and what was happening was I was taking array elements and laying them out in div's, and like
div's inside other div's, and it occurred to me that: we will only ever lay data out in div's, and...like at LEAST...so like
freaking ok, umm...we lay some stuff out in div's, freaking then what? Like the fundamental problem with this is that you have
two things. The solution isn't that you have two things, the problem is. You have to have one thing to have a solution to the
problem. So freaking ok, umm...so like an array is totally NOT the solution to the problem. Freaking like a "1" is. So freaking
ok, umm...

Ok so off the top, we're trying to build an extrapolator, and freaking websites almighty and stuff, and...and now what?
Freaking ok, umm...so like we have a freaking array, or do we? Is that what we WANT or what? Freaking a...smoke one dude...

Ok so freaking lets say we have an array of data, or a potential array of data, then we have...freaking...a view that is (at
least) these array elements displayed in div's, so freaking how do we break it down from there? The thing is that's like a
completely functional view of what we're going for, we just have to like work out all the kinks from there up. So freaking ok,
umm...so like ok, the reason we would simply display these in div's is that if we indent (nested div's) we have to account for
infinite indentation, which isn't possible (in any realistic way), so we simply have a list of all of the elements of the
array.

So I'm thinking that at that point what we would do is try and abstract the layer between the array and the view such that: the
structure of the array remains intact, and the peripheral code of that array is generated (as much as possible, to save time).
So freaking ok, I figure that the array is concrete, and the rest can bend and flex around that array. It SHOULD be possible to
automate everything but the array, is what I'm saying. I think. I haven't worked out all the details but I THINK it should
work. So freaking ok, lets get down to business.

Ok, so lets say we have an array, any array, a mix of associative and non-associative keys, any element values, any old array.
Now, we display those array elements inside of div's. Then, we style those div's at will and voila, website. So freaking ok,
does this make sense? Umm ok, so we have some backend that stores array elements in tables in MariaDB, then we call up those
array elements at will...so we'll need to code all of the connective tissue between the rows and everything else...how can we
generalize this process? So like ok, we would have unique ID's for everything (EVERYthing), then we would have parent ID's, and
that generalizes the array, in terms of MariaDB. Now, we also need to be able to code this thing in filesystem/etc., so it
isn't just MariaDB-centric. So that's a general pattern we follow, and all it is is an array in abstract space. An abstract
array. Kinda dealie. So ok, we have our array, now, we display the elements of that array in div's and style at will, and boom,
website. So ok, umm...freaking code this bad-boy? Umm...freak...

So freaking lets lay this thing out, in detail...so freaking we have an array, laid out in MariaDB or something. How exactly
will we do this? We go ok, for every MariaDB table we lay out, we lay out a php class (the array data is classified). So
freaking ok, umm...then from that point...ok so we have an array, then like what that is is any resources will not be
persistent (like stored strings, numbers, etc.), so those are out of the question. So freaking ok, what we have then is a pure
array and a filter. This filter filters out resources/etc. from the array that cannot be carried by a database. So freaking ok,
what we do is...so then we have an array, we have a filter, so we have filtered data in our array, then we just need input/
output for that array, so like ok, the input should be rather static, and the output will be a much bigger hurdle. So freaking
ok, umm...so we have an array...then we freaking...umm...then like umm...so we have an array, is that what we have or what? So
ok we have a value, then like we have nothing. So freaking ok, umm...so is it a value or input? What if we have no input? Then
we have a static website. So yea it's like at least input...so freaking ok, umm...what we do is...we have an array, ok we have
some input, then we do stuff with that input. Or we have a static website. So ok we have AT LEAST a dynamic website. So
freaking ok, then we freaking...so we take input...so is what we have a website or what? Then it's just a matter of static/
dynamic. Otherwise ok we have like an array of data, any old data, and what we're doing is filtering that data and freaking...
storing it...and outputting it to the browser. So basic output is a simple "pre" tag coupled with print_r, so that pretty much
knocks that out of the park. Basic input is just typing stuff into an array. Filtration is filtering that input, so ok what all
can that input be? Strings, numbers...it would come in as string. So freaking ok, we like filter for...ok is this going to make
sense when we get there? Dynamically coding this thing? Or does it all need to be hand-coded? Freaking umm...so ok if we have a
function that dynamically generates code, what that does is makes two things out of one, so the resolution of these things will
not be as good as they would if you coded them one at a time. Or like...yea I think that makes sense...like lets say we
freaking code a thing that...codes filters, basically, for this thing. So like what we do is input filters, and it handles the
rest? I mean ok, so potentially we do this, now what happens is the input is interpreted by the code and translated into
working code, so like...so like lets say we programmed a thing that had a table with "name" and "description" columns, and then
freaking the thing outputs this...so like ok, we would also input our filters (lets say there were none), and freaking...then
the thing outputs working code for our table, and what it would do is...so like ok, the thing would have to be completely
internal to Cinder: when the thing "codes" the things it needs to output completely tailored code for these things. And what if
there is more than one of them? Then it needs to idealize the code so there is no repitition...so like what you need is a thing
that cleans up code. So freaking ok, umm...so we just hand-code these things...freaking like ok, umm...so like ok, what we
would do is freaking go ok...so freaking there's the potential for these things to be off a little bit, so how do we figure out
whether that's the case or not? So you freaking code the thing to EXACTLY code a freaking thing...so ok, how do we centralize
all this code...we have a deeper underlying problem: what if our code, in general, is redundant? So we need a thing that
intelligently skims through code and corrects redundancies/etc. This thing would also trim code so it was lean and mean. So
freaking ok, umm...the good side of this is we're inside Cinder, at that point. So freaking then we have one central thing
going on...so freaking ok, ARE multiples redundant? Ok, so at the point at which you have input it makes sense to have some
redundancy, because it's not really redundancy, you're just accounting for the input. Beyond that, however, it doesn't make any
sense. So you MAY not be able to code a generator...it SHOULD work, though. Everything works. IF IT DOESN'T, though, it will be
very revealing of the root nature of the universe. Then one has to ask...ok so freaking how far down does this thing go? Like
so we're at the point at which we're inside of Cinder, so like then what? It's going to take a freaking heaping load of work to
code this thing, and I mean...like fundamentally, what are we doing? So we're taking some code and refining it...we're building
perfect code inside of Cinder. So freaking ok, umm...so lets narrow it down: is this even possible?

Ok, so I was thinking if you had two, and 4 units, and you squished the thing, you would have 1 unit on one site and 3 on the
other, whichever, and otherwise you would have 2 on each side. So freaking ok, umm...like what this means is that...freaking...
like...so freaking what this is is we just plain have to figure out whether we can do this or not, or I mean...the deeper,
underlying problem here is that...like that you can't have one without the other. So freaking what that is is...you just plain
have to start living right. Like I mean ok, umm...so like the problem here is that there are two of them. If there's two,
whenever we choose one, there is another, so we're always up in the air about it. If there is one, there is only one path about
it and we're done. So ok, how do you reconcile these two...so like freaking ok, umm...lets say you had one of them...one. And
so freaking what you do is go ok, it's a simple question: one or two? So one, because it is more fundamental than two, but then
why one instead of zero? Because it is greater than zero. So why not two instead of one, because two is greater than one? There
is something else going on here. So it's not one instead of zero because one is GREATER THAN zero, it is one instead of zero
because one is more fundamental than zero, as it is with two. So freaking ok, what that is is...freaking there's a way to do
this dude...there is a way to do everything. Potentially, there is a way to do everything. So freaking ok, potentially there is
one thing...so like...freaking...ok so within that one thing there are two things...and what is happening is these things are
squishing so as to make one bigger or smaller than the other, and ultimately what is happening is there is no difference, so
like what we're doing is resolving the difference between the two until there is one, and not two. So like ok, umm...what this
is is...freaking...umm...like...so like if you make one thing that is two, then what? Or just get straight to the point dude.
Freaking ok, so potentially there is one thing, or there is one thing. So then what? Then we decide to freaking work instead of
like something else. Like freaking a. Why? WHY? Freaking ok, umm...yea no idea why, maybe I won't. So freaking ok, umm...so now
what? Now do we just sit here and do nothing, or freaking what?

Freaking umm...shit man. What if there's no way to do this? Like ok, two doesn't go down, one goes down, so there's a way to do
this. ? Are you sure? Be sure dude. Ok so if I build this thing, freaking it generates some code and freaking...then you have
to go with whichever is the smaller, a standalone version of the things or a single unit that does everything. So like freaking
ok, umm...so freaking ok, umm...so like ok, there's...a freaking...so like at least what this is is you program one, which
programs two, and you lose resolution in the process. Freaking a dude...that's like totally what that is. Umm...so like
freaking ok, umm...fuck dude. Fucking a dude...so like freaking ok, figure it out dude! Ok freak dude, yea like thats what that
is is when you make two out of one you lose resolution. Fuck dude. I think we're fucked. So like that's what this is, that's
what life, as we know it, is, is a low-resolution image of a qi. Fuck. Ok are you ABSOLUTELY sure? Because what if I program
something that has a function...:

<?php

function func1() {
	
	echo "this";
	
}
function func2() {
	
	echo "'s";
	
}

func1();
func2();

?>

So like what is happening is something that is entirely correct. Like the only problem is that there are two echo's. Otherwise
we would only have one echo...but like in a situation where we needed access to both functions freaking this works. It works...
like ok, I can form perfect output, so I mean it makes sense? So ok are we limited by our html inputs? Radio buttons, text
fields, etc.? Umm...that and GET variables, even though like these shouldn't be set manually? They CAN be though, so that's
what that is. So like freaking ok, umm...so you have GET and html inputs...or like basically you have html inputs...cause like
those set get variables so like...so yea we have html inputs, at least. So freaking ok, umm...so we tailor the thing to html
inputs...so freaking we have some input...ok so we fire the thing up, it checks to see if it's installed, what exactly is that?
Does it have tables and stuff to install or is it a little deeper, is it a standalone unit?

Freaking ok, so you're going to build this freaking massive thing, does this at all make any sense? Like is there a way we can
do this that it actually makes sense or are we just floundering around in the big open sea? Umm...freaking a dude...

Ok so freaking umm...I think that: I think that we have a freaking working thing going on here, with our array and our div's,
and what we should do is dig into it and get it done. Like ok, what comes after that? Is it all custom beyond that point? Can
we generate code, or does this result in crap? So on and so forth. So freaking ok, umm...NOW start building? Freaking umm...so
like freaking ok, off the top, we have an array and we display that array with some div's. So ok, now you need to figure out...
you COULD scrape it all and see what you need to do here and there to get it done, but like that's inconsistent. What you do is
keep digging and seeing what you need to do from this point on to get this thing done. Freaking like ok, so we have some div's
on the screen with some array data, then what? Mission ever so slightly accomplished.

Ok man! So freaking in a nutshell, how does your system work? Or what...I mean it needs no explanation...explained dude, in
freaking some 9500 lines!

Ok dude! Freaking lay it down. Where do we go from here?

So like from this point on, everything is custom code, so like what we do is...freaking like bang everything into position
until the freaking milk comes out. Like freaking ok, umm...so like there's a freaking...so we have an array of data, or less,
and freaking what we do is...what if we have less than an array? What if we have like a string or something? So we just design
AROUND that, since that's what that is, so freaking umm...so like we're circling around the center, freaking now we just need
to lay down steps down to the center and we're done, so freaking umm...so like ok, what we do is...so lets say we design one of
these bad boys, what exactly do we do? So we lay out data, so the value structure, filtration, all of that...what if our value
is a string or something? We can still filter that data! That's what that is! Unilateral freaking goodness. So freaking ok,
umm...so like we would write before we read, so we would "write" our php before we "read" it's output to the browser, so like
ok, umm...relatively speaking that's what that is, so like you get what I mean, like we would write the php before we "read" it
with the browser. So freaking ok, umm...so like in terms of writing, what we would do is...ok heres what:

write
	php
		filtration
			filesystem
			MariaDB
			etc.
read
...

Ok so if we wrote a php file, what would we do? Like in terms of writing, what do we do? So we write the php itself, and that
reads GET/POST/SESSION variables to see what kind of priveleges the user has, then like...so ok, then we have to consider
authentication systems themselves...so like how (else) can we authenticate users, define user priveleges? So freaking ok, if
everyone has all of the priveleges we're kind of in a bind, because we can't control the output of the website. So freaking ok,
umm...so we (potentially) create an authentication system, so freaking ok, umm...

Ok, so what we do is run down a website...so lets take our portfolio and go ok, so we have wordpress installed for dynamic
content (or it's just static), so like what we do is...either frontend or backend, then freaking...so like freaking ok, umm...
so we have a website...so like what would we do here? Ok, we would write the backend, or just chalk the backend, whichever...
it's faster to just chalk the backend, since we can just hand-code the thing. So freaking we chalk the backend, then the
backend becomes manually writing php, so like freaking ok, umm...we code the freaking...we code the...ok so we write our array,
which holds all our data about previous websites we've made and stuff like that, then we write our peripheral code, the code
that actually displays the array on the screen. So freaking ok, what we do is code some code that displays the array, so like
what that would be is freaking some completely custom code...I think. So like it will simply be too busy...ok umm, so then we
have to figure out how we would have to structure the array. Do we nest projects within other projects (of clients), when
applicable, or not? Freaking umm...so ok like what we have to do is lay out a website to figure all this stuff out. So lets say
we lay out a general website, with front- and backend, and freaking go from there.

So we would have our backend first, because we need to be able to write before we read, or at least potentially, so lets say we
use WordPress, then we have to write all of our WP plug-in's, then we have to actually write our data to the site. Then, we
freaking write our frontend, which is a styled interpretation of the data stored on the backend. So freaking ok, umm...what we
do is...so like I think what the problem is at this point, or what the problem is at this point, is that there is a division
between front- and backend. The two need to be one so the thing works (as we stated earlier). So freaking ok, umm...so what we
are doing is we're writing the php, then we're reading the php, which is writing data to the backend, and then reading that
data to the browser. So we're alternating, write, read, write, read. So freaking ok, what we need to do is figure out exactly
what we are doing when we're writing/reading and go from there. So freaking ok, the problem here, then, is that there isn't
just one thing, because otherwise we have to write from the point that we write/read until we get to the point that we have an
error and therefore have to use one thing, and then use one thing. So freaking ok, umm...the only problem here is I don't
really know how to do that without breaking it up into two things, but I mean it still works as it is still one thing. So
freaking ok, umm...so like what we have so far is:

index.php
	backend
		filtration
		storage
	frontend

So freaking ok, umm...ok man, so freaking dig in. What you need to do is lay out a dummy website with full-blown this and that,
and then break everything down to 1's.

Freaking ok man, so lets say we have a website with full front- and backend, and freaking...so we write the backend first, so
lets get to it dude. So freaking lets say we have an array structure, so like what we would do is program the thing to the
array structure, TO A POINT. So what this means is if you need to code it all by hand, so be it! So are you SURE you want to be
a web designer? :)

So freaking ok, what we would do is...so lets say we start off by laying out the array structure, so like we define our filters
for our data and then the storage mechanism. So freaking ok, umm...so if this is freaking concrete, if it is stone, we can code
it once and be done with it. But it has to be right dude. So freaking ok, aside from filtration and storage, what is there
(when it comes to backend)? Ok I mean it doesn't have to be right, but the better the better. So freaking ok, code this bad boy
or what? Freaking ok, how would we code this thing?

So like we define an array structure (or some value, whatever that means), and then we tailor some peripheral for that
structure. So freaking we have the array itself, then we have all of the buttons, all of the inputs, everything to control that
array. Freaking then we define a frontend for this array as well...so like what this would be is...php! Shortly it would just
be some php. So freaking ok, umm...

So like freaking what we do is...basically we just start chugging dude. So freaking does it make sense to code this thing?
Umm...hmm...so like if we code something that codes something...what we have is...lets say this thing takes a variable and then
creates something based on what that variable is, so like one or two of something (variable = 1 || 2). So then what we do is...
freaking...umm...ok umm...or like how do we do this? Ok yea this SHOULD work, I mean at SOME point it works, so freaking...:

...

Or like ok, lets say we code the thing and it has like two "levels" to it, so one being...or freaking like how do we do this?
Freaking umm...Ummmm...good lord dude it's not that hard of a thing to figure out, just code the damned thing until you figure
it out. So freaking ok, umm, to subvert wasting all that effort...so freaking ok, if we code this thing, freaking what it's
going to do is make two out of one, I mean are we even going to freaking code this how we think we are? Like ok, so what if we
just hand-code these things? What's the problem with that? That way we have complete control over the thing...but I mean it
WOULD save you a LOT of time if you had this thing, so lets say both, so lets code it. So freaking what this is is...so like ok
umm...how do you code this thing so it is completely efficient? I mean like so if you wedge it into wordpress there's no
overlap whatsoever...you would have to like analyze code to see what you could and couldn't reuse...does this even make sense?
I mean yea it makes sense...it at least makes sense, or we can always come back and fix it, so ok where do we go from here? So
freaking ok, umm...so like what if we code...like a freaking HUGE thing. Like freaking GARGANTUAN. How could we code ALL this
stuff in one, tiny, little, thing. Freaking dude what if this thing works? You have to consider, what if it works, so that
freaking it's already working and we're just sitting here having a hard time?

So we circle back around: is there a difference or not? There's a difference, but that difference is submerged in all-
permeating indifference, so there's no difference. At least. So freaking ok, umm, how do we MAKE SURE we're right? Well, if
there's no difference we're no better off, either way. So freaking go for it dude! See what the hell you get. Maybe it will
fire right up and we'll be on our way. If nothing else, just keep coding along and you'll get there anyways.

So freaking ok man, that aside, how do we code this bad boy? So it comes down to one thing, and then what? Then we like
freaking go umm...so like umm...we freaking...go...ok so like it wouldn't make sense to not make these things individual
plug-in's for WP because then they wouldn't be able to be run independently, so IF we tried to run them individually it
wouldn't work, which is (at least) not what we want. So that freaking knocks it out of the park, we freaking code a single
thing that does all this stuff...so freaking ok, umm...so then we just code this thing. That's it. So like freaking just do
your best and that's it? Freaking ok, umm, we would be limited by input, so like...ok so whether we directly modify GET or use
html input we are limited by html input, so that's what we use to do this bad boy. Or what? That or prompts with JS. So
freaking lets just assume that's what that is, so then we freaking...so the interface would be dependent on the rest of the
thing (because we're coming from the code up), so we code array structures, so like what we do is...define html inputs, and
have the thing generate the rest of the code. Does this REALLY make sense, though? That makes a damned lot of sense, especially
because you can put it on the screen, but I mean we DO have to be ABSOLUTELY SURE we're right. So freaking ok, now we can't use
JS prompts when it comes to noscript, so freaking ok umm...but we can in terms of script, so thats textual input, what about
mouse input? Freaking umm...so like we can emulate radio buttons/etc. with JS, but like this really doesn't make sense, because
we're INSIDE of html. So like html it is? What if we have some weird kind of thing like a slider or something that we have to
code with js and so on? Like as a matter of efficiency we would use html, it's first in line and that way we only have one form
of input. Does this REALLY make sense though? Umm...freaking...well, I have no idea. I suppose we just code the thing and see
what we get? Freaking umm...is this even the root of the problem? What is the root of the problem?

Freaking umm...so "like" we have an array, I emphasize "like". So ok what this is is we have to tailor the whole thing to an
array, so like do we go one step further and tailor it to a value? Or I mean what? Freaking umm...ok so like the input could be
anything, literally anything, so like that's what that is. So what is it, then? Some string? I THINK it's some string. Doesn't
really matter though. What are we getting at? Freaking umm...like...we freaking code this thing...so where do we start? Just
start coding? Freaking umm...we freaking...push it out dude...ok we freaking...like code the thing, "like" code the thing, and
it all comes together. So freaking ok, umm...so like how do I code this thing? So like there's a freaking main dealie that does
everything, is this always going to be the case? Should we just get our hands dirty and start coding? Seems like it. Yea let's
do it.

Ok so I just started and I was thinking, what if we plan this whole thing out, the WHOLE thing, before we code it? That way we
don't waste ANY time coding. Like no redundancies/etc. So freaking ok...

So lets run this over, what exactly does this thing do? It generates webpages based off of array structure definitions, or
somesuch. So what that is is syntax that defines an array, with filtration and everything. Now, the thing is, we're going to
need more than just arrays, we're going to need inputs and stuff, so like radio buttons, etc. So freaking ok, umm, so like what
we have to do is...install, "install", radio buttons and stuff. So lets say we wanted a radio button that defined something, a
number between 1 and 3. So freaking ok, umm, we define this stuff, create the tables/etc., create the inputs, and freaking that
is what! So freaking ok, this might be a little more complicated than it seems. Freaking ok, umm...so like kind of what I think
we should do is use our forks to do all this stuff, because then we can programmatically break everything down and build
everything up, beyond the shadow of a doubt. So freaking ok, umm...so the thing about this is it's so expansive that freaking
it's going to take either a LOT of work or a very pronounced point. I opt for the latter, and this IS more efficient, and it
totally should be possible.

My premise for all of this is that there is no difference, due to the nature of indifference. Indifference is all-permeating
because of what it is, and therefore there is indifference. From this point on, we hold our lighter, we freaking code our
program, we succeed. It SHOULD work. Unless I've made some sort of vital error...ok so like due to the nature of indifference
this works, because if it does, if it doesn't, there's no difference, as in in a bad way. So other than that, everything is
good.

So freaking ok, umm...should we like get heavy into this tomorrow or something? Freaking a. Like freaking you totally want to
use html inputs because it's efficient, but you don't want to turn away other forms of input, because that would be cool too.
So how do you satisfy both of these? Freaking call it for the night dude. Getting nowhere and this is going to take like a
freaking long time...I mean unless you're down?

Fuck. Fuck fuckedy fuck. Ok, so this thing would be like...a freaking mess. It's like a freaking mess. So what we do is make
sense of all this stuff, so like...umm...what we do is...freaking...like basically what we do is just code the thing...the only
thing I can think of, otherwise, is plan this thing out to a point before we code it so it's all flush and everything before we
even start coding, so like ALL pimped out. I dunno. So freaking ok, umm...does this even make sense? Does it even meet the
mark? Umm...ok so if you code some stuff...if you code like a freaking thing that codes a thing that codes a thing, when is it
efficient? It's efficient when it's output is greater than it's input. So the code we actually type has to be less than the
code it actually generates for it to be actually efficient. So freaking ok, how do we do this? Let's say we code this thing...
how does it go? So we program some syntax, and then it turns that syntax into some functions and stuff, and freaking the whole
thing runs. Now, if the syntax we input is less than the syntax it outputs, we're in the clear. The math of it all works out.
So freaking can we do this? The nature of what we're doing is efficient. We're attempting to create two from one, which is
definitely efficient. So freaking ok, if it doesn't work, just fucking hang in there dude.

Ok, so freaking now what? Ok, so like what we do is...freaking...fuck fuckedy fuck dude! Fucking a, like what we do is freaking
figure this WHOLE thing out before we start coding. Like we have to figure the whole thing out...ok we totally dont HAVE to do
that, we don't have to do anything, but I mean sheeit, like freaking a...so freaking what now dude? Ok so what do we have so
far? We have something like a system made of string that is some freaking php code that is then like some syntax defining
inputs that freaking...automatically pop up here and there, so like freaking ok, umm...sheeit! So I mean ok, like if you
program individual inputs, freaking what happens is like you bulk up on tables and rows and stuff...I mean this IS a fair trade
against the syntax it would take to otherwise do this, but I mean sheeit, does it really make sense? Like no it doesn't dude...
but then again it is all string so there IS a way to do this, even if it takes a little work. So freaking ok, we program some
inputs, then what? Fucking a dude. So like ok, umm, so we program some inputs, then we program...so we program the inputs in
php, then we freaking program...ok that codes the backend...then what? Or like what? What if...damn dude...how do we get this
thing to go all the way down? Freaking ALL the way down? Like snap-your-fingers-and-something-pops-out down? Fuckin' a. I think
I'm out for the night. I'll pick this back up when I'm ready to completely freaking charge it.

Ok man, freaking a. So freaking ok, umm...like freaking what this is dude is freaking fundamental. Even if there is more than
one thing, there, fundamentally, is one thing, and therefore this works. So like what this is is we're circling around the
center and figuring ALL this stuff out, like every day I go through a whole battery of potential and come up with ideas, then,
like while I'm sleeping, I switch battery's to like a more fundamental battery, and freaking get even MORE stuff done. Now I'm
like, just freaking wham-bam that thing and smash all the juice out of it.

So freaking ok, how do we simply strike the mark? So freaking if there's one thing...umm...so like if we have one array or
something, that's AT LEAST what that is, and in fact that's inside the box, so freaking it works! Just run with it!

So ok man, what do we do here? Like freaking ok, umm...what we do is...freaking...go like...ok so we have an array, or a value
or something...then we have some peripheral, and that peripheral is determined by the value. Or what? I mean technically
speaking it can be anything, not just a value, nay an array. So freaking ok, umm...how we do this is...just keep breaking it
down until we get there. So what else can we do with an array, or what? Ok so like backend relies heavily on values, as what we
are doing is assigning values, we're taking input from the user and assigning that data to rows in a database and so on, so
like that's at least what we're doing is taking input...can you take input, store it and all, without assigning a value? So ok
you take the input, you have it in GET/POST variables (pretty much POST since GET can only handle 2000 characters), and then...
then you have to store it somewhere, so like ok, umm...I mean it IS stored, and it IS stored as a value, so that's what that
IS. Freaking ok, umm...coffee...

So freaking ok, we have a value...then what? Freaking umm...like we freaking...we freaking what? We freaking like break this
thing down...lol :)...ok so what that IS is...freaking like...freaking umm...freaking! What this is is like freaking. :) Ok so
freaking ok, umm...so like freaking ok, we need to break our syntax down so we're not sending crap over the line, so like
freaking umm...how do we do this? If we like freaking bottleneck it at the point at which we actually type the code it's
better, but it also needs to be able to deal with existing code, so like there's no way around it but to use regular
expression. So freaking ok, umm...good LORD this is going to be a lot of work! Freaking ok, umm...now, is there a way we can
cut down all the work, fundamentally? Until we freaking get to the point that there is like nothing there? I mean ok, so like
freaking we came up with LESS to do MORE, or so we THINK, so like isn't that success? Freaking umm...

Ok so like lets run over exactly what this thing does...so freaking we take some syntax, and we generate some inputs with that
syntax, so like umm...yea...so like we define a whole radio button or something with the syntax, so freaking what we do is...
generate HTML inputs, and possibly otherwise (in case HTML is extended (gains more inputs) or something). So like what this is
is we would have a system made out of things that...freaking like...are customizable, so like what we would do is...like ok one
of those would be one of our html inputs, and so on, and then we would build some common ones, like html inputs, and then leave
the thing wide-open, in case people want to add custom ones. So freaking ok, that's AT LEAST what that is. So freaking ok,
umm...so what these things are is PHP code. There's no way around it dude, freaking I mean...ok so they are freaking php code,
then what? Good question. What happens once these things are inside the box? Freaking umm...so like we define these things,
then...we like...freaking...ok so like just get it inside the box, so we freaking define these things with some syntax...what
would that syntax look like? Or what? Ok so like then it's code. So then what?

Freaking ok, umm...so like what we freaking do is...umm...something. We definitely do something. :) Ok what we do is...so like
we just continue to break it down, so like ok, first of all is this even possible? One has to wonder whether...just follow
through dude. So freaking ok, umm...so like what we do is...

Ok, hot n' heavy. So freaking we have an array, then what? Or like what? Do we have an array, do we have a value, or what? Like
ok we could have anything, so like that isn't the question to ask. The question to ask is what all can you do with php?
Freaking everything. You can do everything and anything with php. You can freaking make this work dude. Freak yea dude. Ok, so
how do we do it? We have to figure out what like the maximum's and minimum's of php are. We have to figure out what the finite
limits of this and that are to code this thing, because those are what determine what we code (and what we don't). So freaking
ok, umm...like freaking umm...so like what we COULD have is our array and all our stuff, so like what that is is...freaking...
ok so lets clarify a couple things. First of all there's no difference, because there is no difference, then we're inside of
that indifference (might as well be), and then there's simply no difference! It is the fundamental nature of indifference that
we're constantly inside of it.

So freaking ok, now how do we do this bad boy? Like freaking ok, so we code a system that codes stuff, is that (exactly) what
we do, or what? Like ok, umm...freaking ok, umm...so this thing would take some syntax and code arrays and stuff...or like is
this where we want to be? Umm...freaking a dude, what is at the core of this thing? Like freaking ok, how do we start? Freaking
same old dude, just keep busting it down. So freaking ok, we would have like an array, so like we would have some syntax...:

<?php

include("Cinder.php");

$Cinder = new Cinder();
$Cinder->newInput("radio", [
	"settings" => [
		"red",
		"green",
		"blue"
	],
	"default" => "blue"
]);
$Cinder->newInput("text", [
	"filter" => "/[0-9a-zA-Z_]{4,16}/",
	"errorMessage" => "...",
	"default" => "Hello_world"
]);

?>
...

So like freaking ok, umm...like fundamentally what is going on here is we need an opening and closing syntax to group stuff, so
like to create arrays (within a value), so maybe something like XML...freaking umm...so like ok...

So like ok, freaking umm...freaking we'll get this thing done dude, don't worry about it. Ok, umm...so like freaking what is
this? What do we have to do? So like we have to continue to break down the potential of an array, or an array itself, to figure
out what all is possible with one. So like we need to know whether CRUD is the limit in terms of what you need to do with each
array element/etc., stuff like that. So freaking ok, get to crackin'!

Ok, so let's get down to business. Freaking we take an array, and we run it through the mill. So what is the extent of the
syntax that we can use with an array? Or what? Like what you need to do is touch down in these terms to figure this out, so
like you figure out one thing about an array, and it all comes blasting through. So freaking ok, umm...the syntax above looks
pretty good, and I mean this would work in terms of...freaking umm...so like if we have some syntax...ok if we take the syntax
above and we extrapolate it, what do we get? Or I mean are we good with it? Is that enough?

So we create inputs, then what? Then we like create front- and backend with those inputs, so like umm...we freaking...we AT
LEAST code this thing, but I mean to save us time and energy we like plan this thing out before we code it, so like ok, umm...
or should we just code the thing? FINALLY? Freaking a dude...no idea. So ok you have a couple of options, either you code the
syntax and find out if it has integrity, or you, I dunno, flounder around and see if anything comes up? Freaking a. Code some
syntax?

So ok lets say the code above creates some inputs, now what? Now we like summon them up on the front- and backend and
freaking...output controls and stuff, like on the backend we would output controls, and on the front we would output the actual
data itself gathered from the inputs. So like freaking ok, umm...so ok we like know that our input will be string, when it
finally gets to the server, so then what? So like aside from that, anything goes. So we can have any interface for dealing with
these strings, any peripheral. So like the peripheral, this is peripheral...damned peripheral...ok so the peripheral deals with
(at least) string, so freaking then what? I mean then we code it and that's it. Freaking it has infinite potential...like
fucking pure potential. So freaking ok, umm...on the bright side dude you're totally chiseling this thing out of solid rock.
This is fucking bad dude. So freaking ok, umm...

So what's the next step dude? Just like sitting here burning time, what do we do? Get some Brent.

Ok man, freaking like what this is is...ok so if we "sketch a circle" in code, freaking lets say we have an array with I/O.
What does it have and what does it lack? Freaking umm...

Freaking ok dude, so here's what we do: we keep doing random acts of kindness for NO REASON, I emphasize NO REASON because
otherwise the thing will backfire and fail. As long as it's pure, though, it's all good! So freaking get busy with it dude!

Otherwise, so ok here's what I figure: we code this bad boy and just keep chugging until we hit static 'crete, and just
bulldoze the thing! Freaking either that or we keep planning in here.

So like ok, I'm going to keep planning for now, so ok, we have something like an array, then we have input/output for that
array (for all of it's elements/etc.), and what that is is completely extensible, so like...ok the thing at this point is there
are only so many types to deal with! Beyond that freaking there's nothing there, it's circular. So ok, umm...so what we do
is...freaking...ok so what if we just code this thing, and freaking get there dude. Like all we have to do...I would love to,
just I don't, I totally don't, want to waste time coding. I don't want to code the thing, then find out it's fundamentally
flawed, then freaking recode the WHOLE damned thing. I want to just make one clean sweep of it and be done with it. So freaking
ok, umm...

Ok so like we would have an array with I/O, so we would indicate an element, then we would write/read that element, so we would
either add, edit, delete, or read that element. So freaking ok, that's what that is, is there is the array, there is a
"pointer", and then there is an action (read, edit, add, delete). So freaking ok, so like we fundamentally point at array
elements, then what? Then we either set or unset them, then freaking...so like that is at least what that is. So what we have
so far is:

array
	element
		read
		edit
		add
		delete

So freaking ok, umm...so then we can "point" at an array element, and then do whatever we want with that element, so in syntax
what this is is:

<?php

$array = [0, 1];
read($array[0]);

?>

Or somesuch. So freaking ok, umm...like yea this makes sense, then we have an array and some peripheral, so this is AT LEAST
consistent, coupled with a static view. So freaking ok, umm...dude I think this is going to work! It makes perfect sense! Fuck
yea dude! So like freaking ok, umm...so ok, then you have:

array
	element
		input
			add
			edit
			delete
		output
			read

So freaking ok, umm...that defines like the core of the thing, then from there we freaking add all the bells and whistles...so
like ok, now the thing to remember here is that THIS SATISFIES THE THING WHEN IT'S BASED ON AN ARRAY, NOT JUST PLAIN! So
freaking ok, like it could be anything, it could be a system without any values, without any variables. Freaking a!

So ok let's figure some stuff out, I think. If we don't have any variables, do we have any programming? Ok first this:

array
	element
		storage
			input
				filtration
					add
					edit
				delete
			output
				read

So freaking ok, umm...so like array, element, and storage would all be one thing:

array (element) (storage)
	input
		filtration
			add
			edit
		delete
	output (read)

So like output and read would be one thing too...anyways...so freaking ok, umm...now from here what do we have? Filtered input,
output, freaking slap some priveleges in there and stuff and we're good, or just keep it within wordpress and it's all good. So
freaking ok, umm...ok so like in terms of syntax, freaking this works. We reference the array, then we reference the array
element, then we do stuff with that array element (with some syntax). So like freaking ok, umm...freaking ok, umm...so like
what we freaking do is...like...I dunno man, what do we do? Ok so we have some syntax, so far it's working, so like what do we
want to do with this array from this point on? So freaking ok, umm...so freaking from this point on, that's what that is. We
have an array with some filtered crud. Hah. :) Yea that's what that is. So freaking ok, umm...then what? Then we freaking have
everything up and running...so like that is what that is. Now, this doesn't explain the entire workings of a website. What if
we have to account for user priveleges/etc.? Then the thing, once again, has infinite potential, so like how do we deal with
that? What we do is like come up with a circle, a sphere, that represents infinity, and is of finite size, and work with that.
So like what this is is...we have to figure out where the point is beyond which things become redundant, and work within that
point. So like freaking ok, umm...lets say we add user priveleges, and what else? So like the thing would need to work
standalone as well as fully integrated into a privelege-system. So freaking ok, umm...what else though? Just so we don't have
to keep coming back to this point...so like ok, now that I think about it, wouldn't user priveleges be considered filtration?
Yea that makes sense, AT LEAST. So freaking ok, umm...so like what we would have (without redundancies) is:

input
	filtration
		add
		edit
	delete
output

So freaking ok, umm...so lets run a potential website through here:

index.php
wordpress installation (authentication/etc.)
input (installed as wordpress plug-in)
	filtration (regular expressions, php code itself, etc.)
		add
		edit
	delete
output

So like ok, umm, that shortly runs down what a website would be doing when we do this...now, what if we zoom in on this thing a
little bit, on the beginning of the thing: so at first it would check GET/POST variables to see what to do, so like first it
would...ok so with a wordpress installation it wouldn't check whether to load the front- or backend, since they would be two
entirely different things, so like ok, umm...so there is a seperation of the two, constantly, so as to whether or not the two
should be considered one thing, they would be considered two things. So freaking that's what that is. So ok, from this point...
freaking where do we go? Like ok, so we have complete control over our array at this point, I'm PRETTY sure, so we SHOULD be
able to advance past this point, but I mean just to be sure, so we can add elements, so ok how do we do this...so like we would
add either with an element reference or not, basically with one, then like...we would freaking...ok so like whether we're
reading, editing, adding, or deleting, we (effectively) use an element reference, so like freaking...:

<?php

$array = [];
$array[0] = "Hello world";
$array[0] = "An edit!";
echo $array[0];
unset($array[0]);

?>

So like freaking ok, umm...so we would freaking have...so yea, in SOME WAY SHAPE OR FORM, we would reference an array element
when we read, edited, added, or deleted that element. So freaking ok, umm...so we are talking about AT LEAST the VALUE of the
element, no matter what, so freaking ok, we double up on this by the element reference, so AT LEAST THE VALUE OF THE ELEMENT!
So freaking ok, umm...so if we can read, edit, add, or delete that value we're doing everything we can possibly do with that
value. If we're not right, we can always come back and fix it! So freaking carrying on...

So ok, now what all do we need to do with these things? So we need to filter them when they are added/edited, and otherwise we
just straight up delete or read them. So freaking ok, we would need to have priveleges at this point, to determine whether we
can even do this stuff or not, so we end up with every possible combination of a four-bit sequence, "READ". I'm pretty darn
sure that is what the sequence would be, regardless of whether I think input would come before output or not. So freaking ok,
umm...huh...ok so we can figure out what sequence these come in down the line...:

<?php

// so we like READ the "new mysqli" into the "$mysqli" variable...
$mysqli = new mysqli("localhost", "Cinder", "****", "myDB");


?>

...so like freaking I, one thing, would WRITE the php code, which would then be READ by php, which would then WRITE the "new
mysqli", which would then be READ as the "$mysqli" variable, or somesuch...if nothing else we just reassign one of them and
the other one is the opposite of whatever that one is, so it's a quick fix. There's only one possibility for the second one at
any given point in time, so we only have to be right about one thing.

So freaking moving on, umm...so like ok everything is freaking hard-wired beyond this point, completely solid-state. So
freaking ok, umm...so like THAT'S what that is, is freaking...like yea we extend a line, then spin it in a 3d circle, and come
up with a sphere (of a finite size). So freaking from that point on, everything is finite. Everything is represented in finite
terms. Freaking a. I'ma smoke one real quick.

Ok, so we freaking have the starts of an absolute website. Fucking bad dude. Freaking ok, umm...so like from there we freaking
build a website or what? Time to actually lay some shit down or what? Umm...ok so from that point on what would we have? So we
have a freaking array...is this even possible? Like does this make sense or is it redundant? We'll figure that out. So
freaking ok, what we have is an array with some filtered crud, so freaking ok, umm, then we...huh...so like I figure I should
note that if the value is something other than an array, we have read and edit, no add or delete. Still input/output though.
So freaking ok, umm...umm...freaking a...10,000 lines of writing dude lol. :)

So freaking ok, umm...now what? So ok man, lets call it for the day. Freaking take tomorrow off if you want, therefore. Good
times bro.

Freaking ok man, so we're back at it. So you have a freaking array, with some crud, so then what? Then like we build this
thing. Freaking it has an array with some crud...ok...so like what we'll need is storage for the array...we'll need a way to
reference array elements...then we'll need...user priveleges/authentication...what is the end of it? Like ok next we would
need user authentication, so...freaking...like ok, once the user is authenticated to edit the array that's like the end of it.
So yea the user WOULD need authentication along the lines of editing the array, then we have a two-way circuit to editing the
array. Then we need like a two-way circuit for everything before that, so the...so like before user-authentication we fire the
index.php file, so at that point we need a fork of some sort. Like basically umm...no idea what that would be. So like maybe
it would be a thing...ok moving on, from the point that we have user-authentication...what else do we need?

So freaking ok, umm...

Freaking umm...ok so freaking...like...freaking...there's a freaking...fire inside...so fricking a dude, umm...ok so like then
we have to figure: how do we freaking generate filters and stuff like that? How does THAT work? Freaking umm...so where do we
go from here? Freaking once we get there, then what? Bleh.

Ok freaking a dude. So like freaking we make this thing, and then what? We build a system that builds stuff, we do ALL the
work, freaking ALL the work, and then what? I mean before we start building we really have to get a grip on what we're doing
so we're not doing redundant stuff like freaking crazy. Like freaking a dude, umm...so ok, how would we build this thing? We
would like go ok...dude take the day off man lol...aright im'a work a little bit and we'll see what we get. So like we build
this thing, ok so how do we build it...so we like lay out some syntax that controls this thing, and what that does is...yea
how would that go?

So like freaking ok, the syntax would...create inputs and stuff...or what? Like ok we would make an instance of Cinder, or
whatever it was called, and then we would create inputs...so like do we just create these inputs once or what? Not important?
Yea I mean that's all just technicality...the only thing is it would help us lay this thing out, as opposed to just sitting
here banging our heads against a wall. So freaking ok, umm...basically, what I'm getting at is I don't know how else to
approach this thing except to build it up and then analyze it for inconsistencies that need to be fixed and stuff like that.
Basically, what's happening is I'm building this thing in pseudo, then refining it as I cruise along...so like freaking ok,
what we would do is create webpages, then create structures for those webpages that would...like then we create array
structures for those webpages that would define, basically, tables that we would use to store data on that "webpage". So what
is happening here is we're calling a "webpage" a collection of data, and then we're creating multiple webpages. So freaking
ok, umm...what if we want to like extend one of these data as though it were a webpage or something? Or like what if we want
to create a website, not just a webpage? Dude this is fucking so interesting...I mean to a web designer this is like freaking
golden as gold...ok so like if you make a website, and not just a webpage, it's basically the same thing...so like what we
would have, more fundamentally, is our array with our crud. So freaking then like the website IS the array, and so on, so even
beyond that point there could be like freaking all this data and stuff...freak yea dude...

Ok so freaking ok, umm...so what we need is like a way flexible system...what are these things, if not simply array elements?
Input's, right? Yea, they are AT LEAST inputs. So freaking ok, then what? Or ok so these elements are values, or rather, point
to values, so freaking...freaking like...freaking ok, what these things are is freaking elements, so like what that means is
like we can have any values...is this the way to do this? Freaking ok so we have like a value, so is THAT the way to do this?
Freaking umm, hmm...so like lets assume we use an array...well...ok if we code this thing, our code itself could be what this
thing is, and we ARE inside of php, so I mean that is "like" what that is, so freaking a...freaking umm...I have got to stop
saying "freaking". :)

Ok, so...freaking...there I said it again...freaking freaking freaking...freaking so what would this thing be? It would be
php, we've so decided, but I mean is that really what that is? That's totally not what that is. Freaking it works though. So
like ok, what do we do from this point? Umm...ok so IF there's no difference...big if dude...like freaking ok, indifference
permeates everything...this is going to work dude. Just hang in there. Don't drop your lighter. :) Freaking ok man, umm...
so...so lets say we have an array, so like we're going to store data in this array, any old data. Is this going to work? Can
we store any and all of our data in this array? Or are we better off with a number or something? I THINK it's an array we're
looking for, so I'm going to go with it, and as always we can always change it in the future if we need to.

So ok, we have an array, now, we store all of our data, like freaking ALL of our data, in this array. So freaking ok, we have
an array loaded with data, then what? So like generally speaking we need an "element" class or something to make everything
consistent. If we don't have this, we straight up have to do all this other stuff to deal with our elements. So like ok, what
an element would have is filtration and read, edit, add and delete functions. So freaking ok, umm...also this array has users
and user authentication, so only priveleged users can do stuff with it. So freaking ok, umm...basically, though, we just have
an array. From that point on everything is all hard-wiring. So freaking ok, umm...then what? Ok, so first off this array would
have basic READ functionality, so like each element would be referenced, and then there would be READ associated with that
element. So that's the basic skeleton of the thing. So freaking ok, umm...freaking a...so like thats what that would be, is an
array and a bunch of hard-wiring. Ok, so lets assume this thing works, then what? Then we generate these things like crazy,
the only problem being we have to manually program these things.

Ok so ideally we wouldn't have to do ANYTHING for this thing to work. That's ultimately what I'm going for. This is not just
so one can be "lazy", it's also because then we have a way back up from anywhere. That way the way back up isn't only for
those who possess the "key". It's like a freaking keyless door into heaven. So freaking ok, umm...like the only way to do this
is to freaking assume it works and dig our heels in...unless we sit here and map it all out and figure out whether it actually
works or not...

Freaking ok, umm...so how can we prove that this thing works? Or otherwise figure out whether it works or not? I figure if
there's no difference, we're good, because then there's no difference between using a qi to do the trick or using cold, hard
labor. So freaking ok, all we have to do then is prove that there is no difference. Now, I figure that there is no difference
because of what indifference IS, that there is no difference because we're already "inside" of indifference, because of the
nature of what it is. So freaking ok, this makes sense! You should like totally leave it at that...freaking play some FoE or
what? Naa...doesn't sound fun. Freaking a. Fuck, fuckedy fuck. Ok man! It freaking works dude! I mean are you SURE it works?
You are fucking grade a positive? IF that is what indifference is, it works.

So freaking ok, umm...like what this is is...so we either drill down until we hit bedrock or what? Like I figure if I figure
out how this thing would work if it went all the way there in terms of arrays, we would be closer to our goal. Like so what I
mean is ok, so beyond websites, what is an array? What is the universal definition of an array?

So freaking ok, umm...so what would this thing be...or what? So like yea, what would this thing be if we deepened our
definition of array? So like we have an array, beyond websites, so what is that? Beyond websites, all the way up. Freaking
umm...like what this is is...so like we would have the same thing. It would be at least the same thing. Yea, because we're
accounting for filtration, which doesn't necessarily need to be there.

So freaking ok, umm...so freaking ok, umm...how do we do this? Like ok are you SURE there's no difference between the two
arrays? That's at least what that is, so lets assume we're good and move forward.

Ok, so freaking now what? Now we have like a freaking rock-solid unit to work with. It's an array, and that's about it, so
like freaking what we do is...code the thing? Finally lay down some code? Yea I mean that's about what that is. Ok, so what
else? Is there anything else we can cover before we start? Ok, so like how is this thing going to automatically work...ok so
like from this point, freaking what we have is...a system that can handle...any data, so like websites, webpages, so on and
so forth. Templates, loose data, etc. So freaking ok, umm...

So like should we start coding the thing? Or freaking what? Ok, so like this is fucking hard- fucking core, but like ideally
what this thing is is a qi, or the tiniest point, and everything is generated from that point, so are you SURE you don't want
to go that route? I mean it's freaking beautiful dude, no work, no nothing, just sitting there letting the qi do the work.
Freaking a dude. That sounds pretty fucking good right about now. Lets fucking do it.

Ok man, so I'm just sitting here freaking doing nothing. I figure I might as well work or something. So freaking ok, umm, if
we have a freaking array with some crud, I mean that's basically what that is...should we program the thing? Instead of just
like sitting here running in circles? Or what? Well, it isn't fully automatic at this point, so it doesn't exactly work, so
you should probably keep hammering away at it until you get there...what is that though? What is a freaking thing that is
completely automatic? Freaking umm...this is badass though dude, we're totally at this point. Ok, so like...

Ok, so if we had an array with some crud, we would like need an interface for dealing with this thing. Like we would need an
interface for input, and like we would need an interface, the same interface in fact, I think, for output as well. So freaking
ok, umm, should we build this thing? I freaking hate to keep asking, just I'm freaking EXCITED! Like what if this freaking
works and we're like freaking billion-, trillionaires? Freak yea dude! That would be SO fucking bad. Like we could totally
take all the time we wanted off and just chill and chill, riding the rock.

So freaking what should we do dude? Get hot and heavy with the details? Ok, what would this thing be in pseudo? Freaking
umm...:

index.php
check desired action
on input, authenticate user
filter
store new/delete data
output

So in detail:

index.php (or default file)
	check SESSION variables for valid user credentials
		'$_SESSION["user"]["logged-in"]':boolean (or int (0 or 1)?)
	check GET/POST variables
		attempt to authenticate user if not authenticated
			ignore otherwise
...

So like freaking ok, in syntax what we would have is an opening tag and a closing tag, and anything else. So like "everything
else" would be escaped and then we would have our opening and closing tags. So freaking ok, umm...so from that point on it's
all one thing. So freaking ok, umm...in that way a string is an array. So freaking ok, umm...so like should we interpret this
as a string or what? Well ok, so like the important part at that point is that we have multiple things, so from there we just
reduce to one thing and let it rip. So basically we have a string, either way. Or what? Like we would have anything but an
array, and we certainly wouldn't have like a resource or anything that is inherently one thing. Well, we would, just like that
isn't what we're looking for, we have to break everything down to one thing. Ok so relatively speaking we know how to do that
(in php). So we break it all down, then what? Ok so like lets continue to lay everything out in pseudo:

index.php (or default file)
	check SESSION variables for valid user credentials
		'$_SESSION["user"]["logged-in"]':boolean (or int (0 or 1)?)
	check GET/POST variables
		attempt to authenticate user if not authenticated
			ignore otherwise
		check for input
			$_GET/$_POST["action"]?
				filter input
					store input
					display error message on failure
	output
		"logged-in"?
			display admin controls
			output straight read-only site

Ok, so what if we used a cascading-logic system for doing this so that when we check a certain condtiion we only do it once?
Like so we check user credentials, then we never do it again? Then we freaking...yea this like makes sense...ok man, I'm just
about shot? Get started programming, or what? Freaking umm...yea I guess.

Is this even going to work? So we program an array with some crud...I mean so what? Like what the hell is THAT? Freaking
umm...hmm...freaking ummmmm...something will surface dude...so lets say you code this thing, so you freaking program a user-
authentication unit for the thing, then you will need like priveleges, and for like every single element in the array. So
then, roughly, what you do is...you program an array...so like what this thing is, on the outside, is an array with some
filtration, so user-authentication, custom input filters, so on and so forth. So like ok, umm...so you log in, then you...CRUD
the array. So like ok, you would log in, then it would take you to the screen where you would modify the array, and
freaking...what would happen is...you could add elements to the array, navigate to elements of the array, edit elements of the
array, and delete elements of the array, and of course view the array. So like there would be a view of the array (elements),
and not the children of each element, so like we would draw a distinction between strings and arrays...and numbers and
stuff...so like we would have an array...ok so like this makes sense...so we would have an array and we would freaking input/
output that array...ok so then lets say we add an element or something, what deteremines...like the filtration of that
element? We would have to like hard-code these things in there. So like you create an element, and then freaking...like...ok
so bottom line you would have an array, and like that is it. So like the way you would CRUD this array is to directly deal
with it in a text-editor. So freaking ok, umm...beyond that though, into the world of the living, how do we freaking do this?
Like freaking ok, umm...so we have an array, then we have CRUD for that array, or READ, and like ok, what we do is we view
this thing in the browser, then there's a button to add an array element, then there's an option to set this element to a
value of some sort (string or array?), and freaking ok so we set it to a string or an array...so like ok, now what about
naming the element? So lets say we put a name field in there...what about a description? Any other information about this
array element? Like this wouldn't make sense, because...umm...ok so if we break this thing up into single steps, so like we
have a view that displays all the elements of the array on the screen. Now, umm...ok so is there a point to naming these
elements and stuff like that, or what? Like ok it makes certain sense to do that, just...how will they know which elements are
which? Ok so lets say we carry on, so we have elements, either strings or arrays, and freaking you can click on one of these
arrays to view its children, and otherwise it simply displays the string in the browser, so like freaking ok, umm...so we have
some really basic data going on. A straight array. So then we have to figure out like what is a value of an array element? Or
something like that, lost my train of thought...so ok like what we would have is mariadb tables for "things" in a backend
system, where like...we would have, say, screenshots, that would have paths to thumb- and full-sized images, so like there is
a certain amount of organization going on...so freaking like ok, umm...what we have to do is bridge the gap between the two
until we get there. So freaking ok, umm...now if data is tabular, we should just be able to come up with columns and then
rows.

Freaking ok, so umm...so like any element could have any amount of data associated with it, so like an array of data along
with it. So freaking ok, umm...hmm...so like freaking...yea I mean that's totally what that is. So freaking then we have an
array like:

$array
	element
		name
		description
		etc.
	element
...

So freaking ok, umm...so like what we would have is:

$array
	element
		value
		extra information
			name
			description
			etc.

So freaking ok, then we have like a full-bodied array...so like that's what an element of this array would be. So freaking ok,
umm, what we would have is:

$array
	element
		value
		extra information
			element
			element
			...

So freaking that's what that is. Ok, so now you just need a system for building all this stuff, so like what we would have
is...ok what if an element had more than a value? Would that be listed under extra information? Or I mean do we just list all
this information under one table? The only problem with that is then we have a reserved string, so to open it up we use the
extra information table. Freaking ok, now, like what this is is...lets say we wanted to build something out of this now:

Cinder
	websites
		website
			name
				Cinder
			description
				Cinder website 2021...
		website

So freaking ok, I'm pretty sure it fits...so like we would go:

Cinder
	value
		websites
			value
				website
					"http://cinderproject.000webhostapp.com" (url as value?)
					extra information
						name
							"Cinder"
						description
							"The 2021 Cinder website..."
				website
					...
			extra information
				description
					"Websites made by Cinder..."
	extra information
		"Cinder array..."

So yea that's like what that is. So freaking ok, umm...it like fits dude. Then we like freaking output this data and...what
do we end up with?:

Cinder
	websites
		website
			Cinder
			The 2021 Cinder website...
			http://cinderproject.000webhostapp.com

Yea dude...that's like totally what that is. So freaking then we wrench the backend in there, build the frontend...and it all
fits. Now, what if we want to do something like build a completely custom thing out of this? So like we translate columns to
columns and rows to rows and freaking...it's all string, baby. Freak yea. Take the rest of the day off? Naa...or like take the
rest of the day off and get heavy into it tomorrow? Or what? The thing is we could just whop it tomorrow and have a three-day
weekend. Freak yea dude.

So freaking ok, umm...what if this thing gets BIG? Does it work? Umm it's recursive...should we like build one of these
elements or something? Umm...yea sure. Ok so freaking how are we going to handle filters on these things? Like we can't just
embed...actually we could do that...ok so like what do we get out of coding this thing? Freaking we should totally like just
stomach just sitting here...take a week off dude. Fuck it. I mean other than that, what the hell? Freaking like what is the
fucking POINT lol. :) Freaking ok man, fuck it, I'm out, at least for the night.

Ok I'm back dude. Gonna stick it out until I'm done. So freaking ok, I was thinking you know what we need to do is freaking
figure out what this array is. By that I mean lay out every little detail about how it's structured, so like how "extras" are
laid out, along with values. So freaking ok, what I mean is like basically in syntax lay this stuff out, so we would have
something like:

<?php

$array = [
	[
		"value" => "Some value",
		"extras" => [
			[
				"name" => "name",
				"value" => "some name"
			],
			[
				"name" => "description",
				"value" => "some description"
			]
		]
	],
	[
		"value" => [
			[
				"value" => "Some value",
				"extras" => [
					[
						"name" => "name",
						"value" => "some name"
					],
					[
						"name" => "description",
						"value" => "some description"
					]
				]
			]
		],
		"extras" => [
			[
				"name" => "name",
				"value" => "some name"
			]
		]
	]
];

?>

So freaking ok, umm...it APPEARS to work, so lets move ahead from this point and if we need to we can always come back and fix
it. So freaking ok, now what do we do with this thing? So ok from this point we can like generate freaking huge structures,
huge data structures, so like what we do is start generating? What else? So like ideally this thing would automatically
generate websites and stuff, I have no idea how this would work but that's what I want. So freaking ok, like reading my mind
and all. It's lofty, but it's possible. So freaking ok, umm...hmm...no idea what to do here...freaking umm...like...get
heavy into this tomorrow? Not moving like anywhere tonight. Yea sure.

So freaking ok, umm...so like everything is somewhat up, so what we have to do at this point is...hard-wire everything. So
freaking ok, umm...so now we start hard-wiring the thing. So freaking ok, what we do is...if we were to build these things,
what we would do is...have an array structure definition, so like we still need to be able to define structure within the
array, repeating patterns and stuff like that. Columns. We still need to be able to define columns for the array. As well as
table relationships. So like ok, umm...so like what we would have is something like a "template", and umm...so like what if we
just jump right to it and define some syntax for this thing?:

<?php

include("Cinder.php");

$Cinder = new Cinder();
$Cinder->createTemplate(
	
);

?>
...

Or ok, I'm not really in the mood, so what if we just map this thing out. So freaking ok, we would have some syntax
describing the array, and what this would do is...define the templating of the array...and like that's it. So then what we
would do is go ok, we CAN create a template for an array element, and then what we do is...we go...ok so what we have is:

array
	templates
	elements
	extended data for elements
...

So like freaking then we can do ANYTHING with some data...ANYthing? Freaking umm...just about anything. ANYthing though?
Umm...hmm...so like what we want is the ability to create templates for data, so data has to conform to a certain format, then
we also want to be able to extend that data so that if there is anything a user wants to add to that data, aside from the
templated data, they can do so, so on a per-element basis. So freaking ok, what we have is an array, which mind you is a
template...so like do we have to work it down until it isn't a template anymore? Or what? Anything outside the range of a qi
is a template...and a qi is a template, just it also isn't a template...so like ok, if we have a +1 for something and a +1 for
something else, what does that mean? That means that there is an order of precedence, where one thing logically comes before
another. So like if we had a +1 for 0, and a +1 for 1, we would have a +1 for 1, if nothing else simply because 1 is greater
than 0. So freaking this defines a couple things: just because something has a +1 for something doesn't mean that's the end of
the line, so freaking we land on a 1 then. Or up. Or whatever. So freaking ok, umm...like ok so in syntax this is something
like what we would have:

<?php

include ("Cinder.php");

$Cinder = new Cinder();
$Cinder->createTemplate("value", [
	"multiple" => 2000,
	"filters" => [
		"eval",
		"custom" => "custom.php"
	]
	"columns" => [
		"id" => [
			"type" => "int",
			"arguments" => 8
		],
		"value" => [
			"type" => "varchar",
			"arguments" => 2000
		],
		"children" => [
			"children"
		]
	]
]);

?>
...

Ok so like what we would have is templated data, then we would have...freaking...like then we would have...ok so WOULD we have
templated data? Or, basically, would templated data come BEFORE custom data? So we would think that custom data would come
first, just in case we wanted like a single element without any formatting. However, is this TRULY the case? Either way it's
only a little syntax. So freaking ok, umm...so freaking like...we freaking...do something...so like we would put the custom
data BEFORE the templated data, just in case we didn't want any templated data. Does this really make sense, though? Will we
ever want data without any templating? The thing is, you're like convoluting MariaDB by limiting how many elements can go in a
table and stuff like that, so the question becomes larger than MariaDB. So if you have an array, then what? Then that becomes
the template. Ok, also, so we have an array, that is one thing...so freaking ok without an element there's no difference,
other than whether there is an array or not, and we are assuming an array, so like then we need an element. So freaking ok,
umm, how do we advance past this point? So then we have an element, and that element can be an array, so as to create a
recursive structure, so like...then what? Or ok, how do we just plain get a grip on this thing?

So like we assume we have an array, do we? IF we have multiple things, we basically have an array. It COULD be an object, but
like then we couldn't modify the contents of the object after that object was instantiated, so like it's MORE an array than an
object. So we have an array at that point, then the question becomes: do we have multiple things? If we have multiple websites
we have multiple things. At least. We at least have multiple things. So freaking then we figure we can reduce to one (greatly)
by representing this array with string, with string-formatting, so like ok, then what? Then we freaking go ok, umm...so lets
revisit some stuff:

boolean - as is
integer - <=0 = false, >0 = true
double - same as integer
string - empty string = false, otherwise = true
array - true
object - true
resource - true
resource (closed) - true
NULL - true
unknown type - true

So freaking ok, now if this is consistent...we SHOULD be able to come up with something...or like should we? Basically what we
have is "1" or "11", so like if we come up with something that is bigger than "1" we have to like freaking interlace the
freaking whole thing and everything, like it instantly becomes hell of complicated, because the slightest change (from "1")
and suddenly the thing isn't fundamental anymore. So freaking first things first, we don't want to do that, we want to keep it
down ("1"). Or do we? "1" or "11", wouldn't it be "11"? Yea, because "11" is greater than "1". So freaking that's what that
is. So then what? So then we just work it down and bridge the gap between the two, and it should be a working thing. A
completely solid thing. So freaking ok, umm...so if we have an array, umm...then we have some crud for this array, now how do
we display this array? Like array by array, with non-array (string) elements being directly displayed on the screen inside of
div's. So then like, ok, we have like different flavors of string: paths, string itself, etc. So freaking ok, umm...do you
EVEN feel like doing this dude, lol.

Ok, so lets get heavy into it. We have 8+ hours to go. So freaking ok, umm...hmm...so IF we had a working array, which we
might as well, it's just a matter of coding it, then what? So like it becomes a question of what we have at that point, what
we actually HAVE. So like we have an array with some crud, what else do you need to know about it? So freaking ok, umm...so we
have an array with some crud, umm...so freaking ok, umm...freaking ok, umm...what we have is an array with some crud...yea we
already know that. So freaking ok, umm...so like I kind of feel like we should go ahead and code this thing...lets write out
some pseudo:

array
custom
template
crud

Ok so the thing is, we don't yet know what this thing is. We know, like, hypothetically, what it is, but we don't just plain
know what it is. So freaking ok, umm...so it's like an array, we know that, now, going straight at the point, what do we do?
So like freaking ok, umm...fang qi and hold on tight. :) Freaking umm...ok, umm...so we like...so we freaking have an array,
then what? That's like it dude...so ok like AT LEAST what we would have is a table (columns) because if we had one column we
would still have a table. Or like if we had a single column we could define an array, so like that's AT LEAST what it takes to
build this thing. So freaking ok, umm...then what? This is fucking so badass dude...so ok like we would tailor the tables to
the array, so that is what that is. That is how the two of those relate. So freaking ok, umm...so then it becomes a matter of
how we want this thing to work. So like, ok, what it is is...tables of data...so like structured data with columns and
everything, and freaking...what we have is...so like effectively what every array in the array, including the array itself, is
is a MariaDB table. So we have arrays and strings, arrays being constructed as tables, and strings being values of rows in
those tables. So freaking ok, umm...now we wouldn't have loose data in this array because that data is unique, and not
tabular, so to speak, or roundabouts, so like we wouldn't use a loop or some programmatic process to deal with this data. It
would be hard-wired into the website or whatever. Ok, umm...like even so, it would be a row because it would have columns, and
basically the only thing with columns is a table. So freaking ok, umm...ok so I think dude we're on our way to figuring this
out, because we're weeding everything out of there with cascading logic, and freaking it's all coming out. Like now this would
be a table or an array, then then it would be whatever that is or something else (something smaller), and finally it would be
a "1". So freaking ok, smoke one man.

Ok dude, freaking a! Freaking is this thing a table, or is it an array? It IS an array. But lets run it through the battery
just to be sure. So freaking if it's a table, we're like limited to...we have to define columns, if it's an array, we don't.
So it's like an array. So freaking then what? So then like we have array values determined by statements, function returns,
straight statements, etc. It would be at least a straight statement because then we don't need to predefine a function (which
takes another line of syntax, or just plain more syntax). So freaking ok, umm...so we would have something like:

<?php

$var = 0 || 1;

?>

! Freaking a dude! Ok man, and how does it go down from here? So we have a freaking array, not a table, so we would AT LEAST
have to define tables and stuff like that based on the array, but like what we would do is define the array...we would define
this array, so like ok...umm...we would have a freaking array, then what? Then like we have some crud for this array, so we
ALMOST just have an array, except for filtration and stuff like that. So like basically what we would have is an array, and
filtration/etc. would be peripheral of the array. This is basically what this is because we have an array, so like array-in
array-out. So freaking ok, umm...ok so carrying on, so we have an array, and not a table or something like that, then what? So
ok, it seems like this thing SHOULD lend itself to revealing how to build this thing in terms of full-automation and
everything, it just seems so far out. The thing is, though, dude, that freaking like it's totally possible. If data really is
static, from here up is freaking stone dude, pure earth, and all you have to do is trace it with your fingers until you fully
understand how this thing works. The stone is definitely there, though, dude! If data is static the stone is definitely there.
Freaking a. Ok, so like the value of an array element is of a type, so like freaking ok, umm...if it's not we can fix it. So
freaking ok, umm...so like freaking ok, umm...dude I think this is going to fucking work! Array in, apparently, array out! So
then what you do is just define the peripheral of the array and you're done! Fuck yea! Fuck yea. Fucking a! Dude that's
totally what that IS! You're just programming peripheral...what if you chalk the peripheral? Fuck the outside world! Array and
nothing else! Fuck yea! Fuck you! Hahahaha! J/k. :) Fuck yea though dude...

Ok man! Fucking a! So like freaking what we do is...code the peripheral? The peripheral of this thing is constant. So like you
freaking hard-wire all this stuff and that is it. That is the bitter end of it! Freaking a! You like could call it for the
day, too. Not even down though dude, I want to get this thing DONE! DONE! DONE DONE DONE! So we code the peripheral of this
thing, so like we have crud and user authentication and filtration for our array, like ok, umm...so then like if our data is a
path or something we freaking "detect" that and deal with it accordingly. It should ALL be laid out in string. So freaking ok,
umm...

So freaking build this bad-boy or what? Does this even make sense? Umm...ok so at some point we have to figure out whether it
even makes sense to build this thing, or if it's less efficient than just hand-coding static html pages. So freaking ok,
umm...

So freaking ok, build it or pseudo-code it? Let's keep writing pseudo for now...or what? Umm...so like freaking ok, umm...what
do we get if we code this thing? Then we have an array-based system for storing data and stuff, so like ok, umm, then we can
store all of our website data, client data, etc., on our sandbox/server, and freaking then we like have a major system going
on. So freaking what does this do for global warming, and real shit? Umm...we still have 5 1/2 hours to get deep into this
stuff, more than half our day, or like even like freaking 9 2/3 hours, so like what is the deal? Freaking should we code this
thing or freaking what? It'll be rock solid. Like what is this thing, anyways? It's an array with some crud and storage and
stuff. So like ok, umm...basically we translate the array to string and save it to a file, that's a thing, and freaking ok,
umm...

So freaking ok, IF we were to build this thing, what we would have is an array, then some peripheral. Now, I'm going to do is
smatter it with everything and then tinker it into place, so like there would be the array itself, then filtration at some
point, as well as crud, an HTML view, and like that's it. So freaking we would view the thing with html, via php, so like...we
would have the array, then we would have the view, then we would have the controls for the crud and stuff, so like just start
coding the view? Yea I mean I guess. At some point this thing would become so sophisticated that it would handle full-
automation? I guess? That's the intention?

Ok, so we code the array, then we, shortly, code the view, which is just a print_r of the array inside of a pre element. So
freaking then we have a view, however primitive it is, and...then we need filtration, basically. So what THIS is is...a thing
that points to specific array elements and filters those elements with given filters, so like what THAT is is...:

<?php

$array = [];
function filter($input) {
	
	return $input;
	
}
function set($index, $value) {
	
	global $array;
	
	$array[$index] = filter($value);
	
}
function get($index) {
	
	global $array;
	
	return $array[$index];
	
}
function view() {
	
	global $array;
	
	echo "<pre>";
	print_r($array);
	echo "</pre>";
	
}

set(0, "Hello world");
set(1, "Goodbye universe");
view();

?>

So like this is a basic, php-based system, where you have to code the input. It works, though. So like everything about this
thing would be an extension of this code. So the freaking filtration, everything, would be an extension of this code. Freaking
umm...so like ok, umm...code this bad boy? Freaking umm...:

<?php

class Cinder {
	
	private $filters = [];
	private $value = [];
	
	public function set($indexes, $newValue) {
		
		if (!count($indexes) || !isset($newValue))
			return 0;
		
		$index = array_shift($indexes);
		$value = &$this->value[$index];
		
		function seekElement($indexes) {
			
			if (count($indexes)) {
				
				
				
			} else
				return 0;
			
		}
		
		if (!isset($value)) {
			
			if (count($indexes)) {
				
				$value = [];
				// recurse
				
			} else
				$value = $newValue;
			
		}
		
	}
	public function view() {
		
		echo "<pre>";
		print_r($this->value);
		echo "</pre>";
		
	}
	
}

?>
...

Or like what we do is freaking ok, everything returns 0 or 1...then if something otherwise returns 0 or 1, freaking we have to
account for that in all the logic, and it all wrenches itself into place. So like ok, what if we create an instance where this
is the case and go from there? So like umm...so we have an array function or something, "count", that returns a number
representing the number of elements in an array, then we go ok, if this count is 0, or if it's 1, we do something...so like
then what we do is introduce a logical fork, so like a function that returns a 1 or a 0 based on the return of count, so like
something that returns 1 if there is a count greater than 0, and 0 if there is a count less than or equal to 0, so freaking
ok, umm...what is something we would have to do like that? Check to see if there are any elements in an array. Then we somehow
generate an array with an element and the thing goes in a circle. Freaking ok, so how do we generate these array elements? so
like we go 0 || 1, then we arbitrarily assign that many elements to the array, and we have an array with a single element.
Fucking a. So ok, then what? What is THAT? Ok so you SOMEWHAT have what you're looking for. Now you just need to fill it all
out and be done with it. So freaking ok, umm...:

<?php

class Cinder {
	
	private $filters = [];
	private $value = [];
	
	public function set($indexes, $value) {
		
		if (!count($indexes))
			return 0;
		
		function assignValue($indexes, $elementRef) {
			
			$index = array_shift($indexes);
			$elementRef = &$elementRef[$index];
			
			if (count($indexes))
				assignValue($indexes, $elementRef);
			else
				$elementRef[$index] = $value;
			
		}
		
		assignValue($indexes, $this->value);
		
	}
	public function view() {
		
		echo "<pre>";
		print_r($this->value);
		echo "</pre>";
		
	}
	
}

?>

So like ok should we test it? Or I mean, at SOME point, we have to work this thing down until it gets there, so like what is
THAT? Freaking like ok, umm...so like in pseudo:

array
	crud
		filtration on add/edit

...so like thats what that is...lol. :) Freaking yea, three, little, lines of pseudo. Ok, umm...so like what this thing is
going to do is...its an array, then...like...there's freaking some crud on this array, and like...umm...so ok, first off we
just have an array, then we have an array with some organized crud, so like filtration, basically...then we have an array with
filtration and a view...then like that's it. That's like the end of it. So freaking ok, get filters installed on this thing
and stuff...freaking umm...ok...ok so like you need to figure some stuff out: exactly what kind of peripheral do you want for
this thing? What kind of storage do you want to use? Should you use?

Umm...yea why would we use MariaDB for this? And what else? What all do we want this thing to do? Can we just build along as
we go? Or I mean what? Like if we directly have to edit the code we have to like weld and re-weld the thing over and over
again every time we freaking change the thing...so like ok, umm...hah...yea that's like what that is dude! Freaking a. Umm...
ok so like, I guess we just code the thing...freaking like that's what that is, there's like no way around that. So freaking
ok, umm...lets keep coding it...shit yea, how do you store this stuff? A big fat mariadb table...? Ok like you could store
non-sensitive data in the form of files...that cuts down on size quite a bit...freaking umm...

So like freaking ok, umm...hmm...so like...umm...so like freaking it takes LESS code to code a single function to use twice
than to code the same thing twice, so like that's what THAT is...is like it SHOULD make sense to do this, since that is the
case. So freaking ok, umm...so like this thing works? It is like tiered correctly and everything, so like it's as efficient as
it's going to get at that point? So freaking ok, umm...dude just freaking chill! Ok man! Freaking a! So like how do we
freaking do this?! Freak yea!

Freaking ok man, freak! Freaking freakedy freak! Freaking a!

Ok anyways, so like how do we want to store stuff on here? In mariadb with file references? Freaking ok man, umm...so like
freaking ok, umm...who cares? I mean ok, like, what's the easiest way to do this? Just have huge database rows? Freaking or
what? Freaking umm...so like freaking umm...umm umm umm...so just start building or what?

Ok so like I was thinking, and like I was drawing a blank, and what I think is we need to be consistent and work this thing
down, even though we have an array in and an array out. Like I'm not sure if we've passed the point of hypothesis (and we
shouldn't!) so we need to keep it consistent and keep working it down.

So freaking ok, what we have is an array, and we need to figure out stuff like storage, filtration, everything. So basically,
a full-bodied array is an array with crud and filtration. From that point on...ok so like code THAT.

Ok freaking a, like...umm...so like we have some stuff to figure out. We have to figure out whether we can take a qi to
heaven, and we need to figure out WHEN we can take a qi to heaven, so like it's full "worth", like what all it is capable of:
can we use it now or only when we're dead, do we just hang on to it and sit tight, etc? So freaking ok, umm...then there's the
possibility of just sitting there, doing little or nothing, letting things happen. Does that work? I mean if it does freaking
hell yea dude we could just sit there and sit there. Not many people can do that. So freaking ok, umm...

So like otherwise, where are we here? Freaking we have an array, and that array has some crud and stuff...or does it? How does
all this stuff break down to tiny little bits and pieces? Freaking like, if you make it a fine enough consistency you'll be
able to build anything out of that, and that freaking totally means sutomation and stuff like that. So freaking ok, how do we
do this? Freaking so we have an array, then we have...then we have crud and stuff, but is it the point to start doing all this
other stuff or what? Like we have an array, then ok, so that's one thing, then like...what exactly IS an array, so we can
connect everything else to it? Or is that the question to ask? I mean like ok, so we have an array, so then like, pretty much,
what is the SYNTAX that we use to do stuff with that array?:

<?php

// array
$array = [];

// add element
$array[] = "Hello world";

// read element
echo $array[0];

// edit element
$array[0] = "Goodbye world";

// delete element
unset($array[0]);

?>

So like freaking ok, there is syntax to do all this stuff, so then we just attach everything to that syntax and we're done. So
freaking ok, like...so we have CRUD, so like freaking what that is is we have functions for doing stuff with the array, and
like so we do that, then we go ok, we need to store this data as well, so it's persistent, so freaking ok...so then we have to
design a storage system. Freaking a. Then...then we have to...then we need filtration...so like that's what THAT is, and
freaking ok, umm...then we need like...then we need a view of the thing...so freaking there's kind of a lot of stuff to figure
out. The main question though: is this going to work? I mean hypothetically it works...like what we'll have to do is freaking
design this thing...hmm...so like it needs to be pixel-perfect, so like every bit of code, everything, to a point. So freaking
ok, umm...can we do this? I THINK, I seem to think, we totally can. Just put your nose to the grinder and freaking get
cracking. I mean ok, umm...the thing is, no matter what this thing becomes in freaking bulk-code, it's totally all string.
It's all code. So freaking ok, how far can you go with a tiny little bit of code? Freaking umm...so like should I just start
coding or what?

Ok, so what if we code a freaking thing that is freaking completely granular, so every bit of code is a little granule...so
like at a point what these would be is characters of string, and at another what these would be is if/else statements/etc. So
freaking ok, umm...

Or like what? Like do we want to build this thing or what? Freaking ok, so like it would be cool if this thing were integrated
into a completely automatic system, so we need a way of like detecting this system. So freaking ok, there's no difference, so
I mean it's there, umm...freaking ok, umm...so you're ABSOLUTELY SURE it's there? Freaking like if you step on this thing and
it freaking breaks that's what you get! So freaking make sure dude!

Freaking ok man, it is the nature of indifference that it flows through everything, so freaking what that means is one thing
is indifferent and two things are indifferent. Therefore indifference.

Yea, there's no difference between one thing and another, and we're somewhere in there, therefore indifference. Also,
therefore we can just chill and wait for it to come to us, or whatever we want.

Freaking ok, so I'm gonna chase it down with some freaking code and hopefully I get there. So, fundamentally what this is is
very simple. So like freaking ok, umm...lets fucking code.

Ok man! So I mean if we freaking code this thing we MAY be like prematurely ejaculating. So freaking ok, we need to like plan
this thing out TO A DOT before we code it, so it doesn't become a thing that we freaking program over and over again. What's
the fucking point of doing it over and over more than once?

Ok, so it's an array, and it works, so like...doesn't that mean code it? Doesn't it mean, if we hit the bottom, that we're
ready to go and start coding? Freaking umm...hmm...I THINK that's what that means, but I'm not positive...so like freaking ok,
umm, hmm...IS it freaking time to code this thing? Or not?

Freaking good question. So freaking ok, umm...so like there's...ok so freaking umm...we have this thing all broken down, don't
we? Dude this could be freaking so badass lol. :) If this EVEN goes through dude we're like bashaw! And people are like holy
fucking shit...and we're like ca-caw! Ca-caw! :)

Ok dude! Freaking a. So like ok, we have this thing broken down to the point that what we're saying we want is going through,
so like isn't the next step, naturally, to code the thing? Freaking umm...hmm...so like freaking ok, umm...hmm...so freaking
ok, umm...how do we figure this out? So like freaking ok, we have an array, that we input, and freaking...everything AROUND
that array is code, or string, or what we want (everything is string, everything comes down to an array, etc.), and like...
umm...so freaking ok, umm...so like we have a freaking...array...ok so we worked this thing down, and we have an array, or
like what we have is a bunch of string that is an array, or like what we have is what we're going for, so like an array, that
is some string, so on and so forth. So freaking ok, umm...so like keep it consistent and keep hypothesizing about it until you
get it down. Freaking ok, umm...so ok like the thing is we SHOULD be able to break the thing down to some freaking way
fundamental stuff, in terms of automation and the like, because we have everything broken down. So ok, if it isn't time to
code, what time is it? Freaking a dude...umm...hmm...

Well the good thing is either way you're burning time, so you're definitely working, just now you need to freaking focus it
like a laser-beam and get it done. Freaking a dude. Umm...hmm...freaking umm...hmm...

Hmm...freaking ok man, lets figure this out. So if you freaking keep coding, you like move nearer and nearer a focal point,
such that finally you get there and the thing is focused, and freaking everything is working and this thing, actually, works!
I think! I think this is what happens. Is it, though? Umm...so ok you figure that if one keeps coding, one reaches the point
where...ok so like I'm thinking that there are two converging lines that finally meet, so like if one just focuses enough one
gets to that point, just how does one focus? Like things are fundamental, so technically speaking we could get this thing, and
therefore everything, done in like half an hour, just...does that really make sense? Or like I mean CAN we ACTUALLY do that?
Or is it like a pipe-dream or something?

Ok, so I figure, along the lines of working with infinity, that infinity isn't possible, or at least cannot be "worked with".
This is because if we try to convert infinity to numbers or something we end up with a number that we can not count up to or
down from, so like...basically, oddly enough, we cannot translate infinity into finite terms. So what this means is we can't
actually "code" infinity, as in real, actual code inside of the real, finite universe. Basically you can see what I'm saying.
So like ok, umm...hmm...so freaking ok, umm...

So freaking ok, what we have is like some potential code...so ok the thing is this thing is all string. Now we just need to
figure out how to reduce all of that string to a point so the thing is as efficient as possible. So freaking ok, umm...like
what that means is we have to reduce that string to certain terms, so like...ok umm...

Freaking umm...ok, umm...so like keep it consistent, so keep hypothesizing in here about it.

So like ok, we have a freaking array, so like we code crud for this array, with built-in filtration and storage, and like
we're done. That's like all you can do with an array.

So ok, lets say you code this thing, at this point, what do you have? You have like an array with some crud. You basically
have an array.

Is this what you want?

Umm...freaking umm...hmm...well I mean as long as the thing works...what is the bitter-end of it, though? Freaking umm...
like...so ok, at this point we would have an array with some crud and a view and everything, but like then we have to figure
out...ok if everything is hard-wired, shouldn't that mean we can code everything once and be done with it? Umm...huh...so like
generally speaking what we would have is say, like, elements, either of an array or of html, and like what we do with those
elements is generally...crud? Crud is about all we CAN do with them, so like what then? And like ok, umm...

So ok, lets say we build this thing at this point, what do we have? We have an array with some crud, basically. So like what
this means is we have a thing we can update our website with, easily, and like that's it. The rest you're still going to have
to code manually. Not too shabby, not that great.

It needs to be better, dude. Freaking umm...I think you're like over-thinking it man. There's a certain extent of coding that
needs to be done with this, so like I think you might want to just code the thing at this point.

So we code this thing, then we have a way of generating websites and CMS stuff rather quickly (should be VERY quick, in fact)
then what? So like that handles the backend, so like then we have to code the frontend and stuff. This is freaking such a pain
in the ass. Dude then we have to code everything for freaking multiple browsers and stuff and freaking that's just plain what
that is. No grace whatsoever. Fucking a.

So like freaking ok, umm...so like is it REALLY time to code or what? Has this thing even been built before? Umm...freaking
umm...hmm...like it would be the perfect time to start coding. You need to get some shit done! You need to make some fucking
legit money dude! You need to get a move on! Or what dude?! Fucking a!

Umm ok, so like lets hook all this stuff together...lets write some pseudo:

index.php
check GET/POST
element id
	filter
		write
			add
			edit
			delete
	read
...

Ok so lets run this over. So freaking we load index.php, or whatever (index.php because it's the default (so like 
"http://www.cinder.com")), and then we write before we read, so that when we read all of the data is up-to-date. So freaking
ok, umm...so when we write we either add, edit, or delete. When we add or edit we filter, and when we edit, delete, or read...
do we need an ID when we read? If we're going to read a specific element then yes we need an id. So freaking ok, when we edit,
delete, or read, we need an id. We don't need an id when we add. So the thing is there is no overlap...between when we...ok so
like we need...like we filter before we add or edit, so we filter before we have ID's. So freaking ok, umm...then what we have
is:

index.php
check GET/POST
filter
	write
		add
			ID
				edit
				delete
				read

or

index.php
check GET/POST
filter
write
add
ID
edit
delete
read

So freaking ok, that's what that is. Ok so finally:

index.php
check GET/POST
filter
add
ID
edit
delete
read

Like the only thing is that this thing is becoming like way tight. That's way tight. Like everything has to be in a single
line, already. So like freaking umm...on the bright side though then you can write a single line of code to code this thing,
so like it's all laid out to freaking code...:

index.php
check SESSION
	$_SESSION["user"]["logged-in"] ? authenticated() : logIn();
check GET/POST
	$_POST["username"] && $_POST["password"]
authenticate
filter
add
edit
delete
read
...

Ok lets just code this thing dude! It's only going to take like a week, and after that you can totally get deep into laying
some real shit down. You can get your portfolio and everything done, and get yourself all ready for production. Fucking a. Is
this going to work?

So like you keep asking: is this going to work? So freaking ok, lets figure out whether it's going to work or not.

To start, we hypothesize that there is no difference. So whether good or bad, either way, there is no difference. So what this
means, what the reality of this is, is that in a good way there is no difference and in a bad way there is no difference. So
what that means is that if it works, good for you, there's no difference, if it doesn't, you're freaking screwed, and poop on
you, it didn't work. So the thing is there's no difference, either way, so like...so if you commit to this idea, in an outward
way, there is no difference, so whatever happens is, at least, hypothetically indifferent. The only thing I can think of,
quickly, is that due to the nature of indifference there is, in fact, no difference, because hypothetically there is no
difference, which means either way, potential or impotential, there is no difference. So hypothetically there is 100% no
difference, whatever that means. :)

index.php
SESSION
	user
GET
	page
POST
	if not SESSION, user
	filter
		add
		ID
			edit
			delete
read
...

So like what this is is we need a short-circuit for users to combine SESSION and POST user checks into one, so like what we do
is create an instance of a "User" class, or somesuch, when we (successfully) check the SESSION variables, or like so we have
one stored in the session data, yea that's AT LEAST what we would do because then we can use the SESSION data at all to check
for user existence, which is necessary, so like...ok so what if we made this thing break ALL the way down, I mean ALL THE WAY
DOWN? Like we break it into tiny little tidbits...freaking a dude, so freaking hard. So fucking hard. This thing is getting
fucking rock hard, this is badass.:

index.php
	SESSION
		user
	GET
		page
	POST
		!SESSION, user
		filter
			add
			id
				edit
				delete
	read
...

index.php
	SESSION
	GET
		page
	POST
		!SESSION["user"] ? user
		filter
			add
			id
				edit
				delete
	read
...

Ok so like the thing is we need to work everything through everything, so like priveleges need to be worked all the way
through the thing, and stuff like that. So freaking when we read the page, we need to check priveleges to see if the client
can even read the page, and so on and so forth:

index.php
	priveleges
		SESSION
		GET
			page
		POST
			$_SESSION["user"] ? $_SESSION["user"] : $_POST["user"];
			filter
				add
				id
					edit
					delete
		read
...

So like ok, there...you would need to check priveleges before you loaded index.php, so that's what that is...and then like you
would need to check priveleges to do whatever that is, so that's what THAT is...and so on, so freaking umm...so freaking how
do we control the priveleges of index.php? .htaccess? Yea, something like that. So freaking ok, umm...hmm...so there would be
the base privelege of 0 ("output"), so freaking ok, umm...so in that way, we read before we write.

Freaking ok man, fuck yea. It's business time. Freaking 16 hour days all the way down the line. Freaking ok, umm...what the
hell do we do here, dude? We need to, somehow, figure out how to put ALL this stuff together into one great structure. So
freaking ok, what is THAT? Umm...

Ok so how do you build priveleges into this thing? Furthermore, how do you build EVERYTHING into this thing? So like you would
"read", so like you would load the index.php file, and that would be consistent with the way it handles priveleges, so like
first you need to be able to load the index.php file, so...so we're assuming index.php. What if we don't assume? Ok so like
we're still inside of php, so we operate within, in fact, the index.php file. So freaking ok, from there...from there we
control everything, so like ok, all of the directories/etc. from that point on are protected by an index.php file, so
freaking whenever, whatever we do, we do it from the main index.php file, and that file reflects these changes by adding
index.php files to subdirectories/etc. protecting everything. Fucking a. So ok, then what? Thus we control the priveleges of
everything, even from WITHIN php, so freaking that's what that is. Sounds good. Ok so then everything points to index.php, so
that's what THAT is, so we're inside of index.php, one thing, and what? So then we control priveleges with "users", or so I
think, so umm...:

index.php
	place "index.php" pointing here in every subdirectory of root
		priveleges
			SESSION
			GET
				"page"
			POST
				$_SESSION["user"] ? $_SESSION["user"] : $_POST["user"];
				filter
					add
					id
						edit
						delete
			read
...

Or all in all:

index.php
	index.php in all subdir's
		priveleges
			$_SESSION
			$_GET
				"page"
			$_POST
				$_SESSION["user"] ? $_SESSION["user"] : $_POST["user"];
				filter
					add
					id
						edit
						delete
			read
				script
					noscript
						output admin controls
						output the rest of the site
...

DUDE! Freaking ok man! So like the way this thing would work, at least, is that it would divide by numbers that didn't result
in infinite numbers! So freaking something like 1, 2, 4, 5, and 8. Fuck yea dude!

Freaking a dude! So like what does this mean? What does it MEAN though?! Fucking ok, umm...so we would have to translate
numbers to other stuff, like string and stuff, so the way we do that is that anything less than or equal to zero is zero, and
anything greater than zero is one ("0" and "1"), so umm...freaking ok, how do we do this dude? I'm freaking ALL fired up.
Fucking umm, no idea...all I know is that's how the numbers work. So fucking ok, what we need to do then is translate
everything to numbers...or what? Just keep chugging along dude.

Ok man, I have no idea how to translate to numbers, so like what I'm gonna do is...what if we translate to booleans? They
would all be true because they are all positive. So freaking ok, umm...well one way or the other you have to work all this
stuff out, so now what?

So like ok these numbers represent a certain pattern, so...ok so first things first, if there's no difference does that mean
it's a good thing or a bad thing? Potentially it's either, so like...ok simply 1 or 0 we get 1. So it's a positive thing. And
a positive thing is a good thing. So that's what that is!

Ok, so do we advance past that point or what? We should, simply because we should continue to be productive and stuff: keep it
constant. So freaking ok, umm...so like what do we do? We freaking go ok, umm...ok this is badass though dude, we totally have
an idea of how the hell to do this! Freaking take the day off in celebration? Hell no, dude! Hell no!

Ok so how do we do this then? How do we approach it? How do we just plain do it? Or what? Freaking shit man...like you totally
have to freaking either go for it or slave all day long. Slaving is no good, because it takes longer: it takes longer to
figure out what something is than it does to translate what something is. Fucking a.

So like fucking a dude, umm...fuck. How do we get this thing down? Fuck dude. So near but so far.

So like ok, umm...so there would be a pattern...the division of two numbers would represent...freaking...so ok like the thing
is that what results from this division is finite numbers, and numbers with precision, even on THIS box. So freaking ok, what
this means is we can actually, yes ACTUALLY, USE these numbers to do stuff, on HERE, on THIS BOX! Yea, that's what that is. So
freaking ok, how do these numbers relate? Umm...

0001
0010
0100
0101
1000

So freaking ok...like those are the numbers, in binary, of freaking like...the numbers that divide with precision. So freaking
ok, umm...so like there's a pattern with these numbers against any number, so what that pattern is is...like ok, there's a
pattern, like there's a pattern in which these numbers occur, so like what is that pattern? Like the reason these numbers work
is because they result in numbers, when you divide a number with them, that is precise. So like ok, umm...freaking...umm...so
every so often one of these numbers occurs, and like predominantly  between 1 and 9, and like...ok so it wouldn't be 10,
because that's a repitition of the pattern, and it wouldn't be 0, because you can't divide by 0, and like it would be an
integer...so ok you PREPOSTERATE that it would be an integer. Would it really be one? This is smaller than using, say, decimal
numbers (less syntax). So like freaking ok, umm...so we have a number between 1 and 9 that divides another number into a
precision decimal number, so like umm...freaking...so 1, 2, 4, 5, or 8...ok, now...what we need is like a way to detect a
number that will result in a precision decimal number when another number is divided by it, so like what we're trying to do is
translate this into code and other stuff like that. We need a way to get this down on the ground. So what I'm figuring is that
we can translate the pattern that these numbers occur in into some code, or whatever we want, by tracing the pattern and such.

So freaking ok, umm...ok so hypothetically we can come up with this code simply by coding. All we have to do is run a function
against some numbers and see what we get. So like ok, umm...so otherwise we end up with...ok why not 0?

Ok so freaking what this is is we need to plan this thing out then execute. So like ok, what this is is...we have to figure
out how these numbers come about, so like we need a way of telling when a number is divisible by another number. So like what
we do is...like make the number we are dividing big enough to handle division...ok so like what we do is loop through numbers
and go ok, when we hit a number that is divisible by both numbers we have a match, or that number can be divided by the other
number with precision. So ok, umm...so what we do to limit the loop, so it doesn't just go on forever if there is no match, is
we go ok...so we take a number we want to divide and a number we want to divide with and go ok...

Ok, so like 1 / 3 results in 0.3, then 0.33, then 0.333, and so on, and that's how we know 1 isn't divisible by 3. So freaking
ok, we make a thing that detects this and then what? Then we can tell whether a number is divisible by another number or not.
So freaking ok, then we go ok, in a base-10 number system, we divide a number by a number that is not redundant (one numeral),
and is valid division (non-zero). So freaking ok, umm...so I'm pretty sure that's what that is. So freaking ok, umm...so like
what we do is divide the numbers and we go ok...so ok lets say we divide 1 by 3. So we initially just divide 1 by 3, so we go
ok, we (at least) end up with 0.3. So how do we do this? Freaking umm...hmm...ok so there is a way to do this. What we do is
like figure...we do some binary division...ok so the problem is when we end up with a number that is...beyond the precision we
can handle. So it doesn't matter what the technical...dude why not just 1 and 0? Lol! :) Holy shit! That's totally what that
is! So freaking ok, umm...so like freaking ok, what we do is...freaking...ok so we take a number and divide it by another
number, so the precision is arbitrary...so like we have to assume...like ok if we don't make it within precision...so what we
do is...damn dude...ok so you take the result and multiply it by the divider and if it doesn't come out correct you're
freaking screwed.

Ok so freaking I don't think there's really a way to do this. Freaking like ok, umm...you have to...so like freaking there's
no way to do certain math with limited precision, so I mean...? Like how do we tell if something goes on forever? Like, for
instance, how do we tell that 1 / 3 goes on forever? We would have to measure forever to figure that out. Freaking a. At
least, potentially, this is what this is. So freaking ok, umm...freaking a.

So freaking ok, umm...so like we have some numbers...so how do we get this down on the ground? We like start doing math along
these lines. Take the day off or what? What. Fuck taking the day off.

Ok, so freaking what we do is like just keep working it down. We have to connect the two, your blueprint of a perfect website
and these numbers, together. So freaking ok, umm...what we do is...just keep hammering away at a perfect website? I mean it
WILL come to a point where it won't go any further...we have to reach that point. This totally does not sound like fun right
now but I mean that's what that is. So freaking take it or leave it.

Ok, so fundamentally there is a way to do this. There is a way to quickly put the two of these together and be done with it.
So freaking what is that? What is that way? Freaking umm...yea that's what that is, is fundamentally there's a way to do
everything, and it's FASTER to take the fundamental route than otherwise, so like that's what we do is seek the fundamental.

So freaking ok, how do we do this? Just keep hammering away at it until we get there or what?

Ok, so like what happens is we write some php, then we read that php with php, so like our output is some php code, and our
input is the output of php having parsed that code (and the input of php is the php code we output, and the output of php is
that code, parsed). So freaking ok, like the thing is dude, it's a freaking fundamental puzzle, and that's it! All you have to
do is put togehter a puzzle to get this thing done. Like that's freaking it! That's IT! So freaking what you do is just get
fundamental with that thing and whop it. Ok, so what happens is we have our output, which is some php code, and what is
happening in that code is we write some stuff to our database, then we read that stuff (and more) from the database to the
actual view of the website. Now, what happens is we output some php code, so that's one thing, and ALL of WHATEVER it is is
that one thing from that point on. So then what we do is our OUTPUT, the PHP CODE, INPUTS (writes) stuff to our database, then
our OUTPUT OUTPUTS stuff to the VIEW. So like ok, what I'm noticing though is that there is an alternation happening...ok so
we fire up a website, we read from the server, the server reads an index.php file, the php READS GET/POST variables to see
what to do (read/write), then, depending on what we have, we either INPUT or OUTPUT to or from our database. So freaking like
see what's happening is there is an alternation when we initially check the GET/POST variables, then there is ANOTHER
alternation...ok so like if we output there is no alternation.:

index.php
	check GET/POST variables for what to do (php's output, otherwise php's input)
		input?
			write to db
		output
			read from db
...

Ok so like it's not that complicated...ok so like the thing is that php's output is one thing, so then we have OUR output, so
either way we have output, so that's good, so ok then our OUTPUT is PHP's INPUT, so freaking...so that delineates the OUTPUT
and INPUT of PHP. So freaking ok, umm...so lets take something simple, like reading GET/POST data, so like PHP's OUTPUT would
include this GET/POST data, and PHP's INPUT would tell PHP to OUTPUT it's INPUT (the GET/POST data), so freaking...so that is
what PHP's INPUT and OUTPUT are. Fucking a. Ok, umm...ok so like then we would have PHP's OUTPUT, and OUR OUTPUT. So all
output! One, consistent, thing. Fucking a. Ok, umm...so then like what is happening is...:

index.php (O)
	check GET/POST (I)
		input? (I)
			write to db (O)
		output (O)
			read from db (O)
...

So freaking ok, umm...so like what we're doing is freaking solely making up our minds about what input and output is. So
freaking make up your mind dude. If you can figure one of these out you're like done.

So ok, checking GET/POST would be input because...because we're checking PHP's input. GET/POST would constantly be PHP's
input. If we're wrong we just swap the two out. Freaking ok, umm...ok now CHECKING GET/POST, would be input or output? It
would like primarily be output because it's parsed PHP, so like ok...umm...:

<?php // index.php

if (isset($_POST["login"]) && $_POST["login"]) {
	
	// ...
	
}

?>

Ok, so like freaking umm...so '$_POST["login"]' would definitely be input. Then...freaking...so is checking whether something
is set or not input or output? Or what? Somehow you have to work this stuff down. Ok so like one of two things is WAY
fundamental, second to fundamental, so don't be surprised if you have just about as hard of a time figuring that out. So
freaking ok, umm...so like it would alternate, "isset" would be output, as '$_POST["login"]' would be input...and then
"index.php" would be output. So freaking ok...well ok "index.php" would be input, and then "isset" would be output, as
'$_POST["login"]' would be input. So like we have to figure out a way of making the whole thing one consistent hing: input. So
how do we do that? Ok so like all of the php would be input. They would be input of PHP itself. So like that is what that is.

Umm ok, hmm...how do we...ok so even if it's output, it's one consistent thing. That's for sure. So we've reduced it to a
single thing, pure php. A blank php file. And we're inside of php.

Ok, now what? Ok so the thing is, fundamentally you're right on time. Why you don't want it faster than this, I do not know,
but fundamentally you're making just as good of time as you would be otherwise, so that's what that is. So freaking how do you
want to approach this? Kick back and let it come to you? Try to hammer it out? You're like freaking there dude, you know what
that IS! You just have to translate it all. Now the question becomes: which path do we take? Do we use our minds, do we ditch
the thing altogether because it's fundamentally faulty, so we try to grind it out in php?

Fucking a.

Umm...try to hit it right on the mark. The closer you get the better. Ok so fundamentally there's no difference, so what we
need to do is...just hack at it dude. Freaking put your hockey mask on, BE red, and fire up your chainsaw.

Ok, umm...:

<?php

if (isset($_POST["username"]) && isset($_POST["password"])) {
	
	$Cinder->login($_POST["username"], $_POST["password"]);
	
}

?>
...

Ok so at this point we'd want to use WordPress. So that's what that is. So then we need to...extend wordpress with plug-in's
and stuff like that...ok...also we don't want to use wordpress...so we need to figure that out as well. Damnit dude. So
badass. Ok man, fucking a.

So lets get down to business, what do we need to do here? We need to find out way down, which I believe we have already done
by figuring out those numbers, so like now we need to build the thing up. So how we do this is like freaking critical: it MUST
be efficient otherwise we're like totally wasting our time. Or I mean what's the point? Why not just sit there and let it come
to you in your mind? You want to use your mind anyways, it's more central to the core. So we're done here then? Yep.

So freaking a dude, here we go.

Ok, so I figure if this thing is an array there is only a bunch of syntax between me and my goal, so like umm...I'm like ok, umm,
the way we do this is just to work it down. So like freaking code it already dude! Freaking umm...like...I guess I'll code the
thing, I mean I really don't know like what else to do?

So ok, lets code this thing in pseudo:

index.php
	check priveleges
		check GET/POST
			input
				store
					use specified indexes (or equivalent)
						filter
							add
							edit
						delete
			output
				array element at specified indexes (or equivalent)
...

Ok fuck it lets just code the thing.

Ok man, first things first: we need to organize all this stuff to a point before we code, otherwise we're just going to stumble
over ourselves while we figure it all out and like recode the thing over and over again until we get it. So freaking ok, the thing
is, how does this thing start? It checks priveleges...ok it starts with index.php, and we're inside of php, so we're INSIDE of
"index.php". So freaking then we have to like check priveleges, so if the user has no priveleges this can do whatever you want...
so like ok, it could like refuse to display ANYTHING, not even a default view to the client, or whatever you specify. So
freaking ok, umm...lets see...so lets say we have a bottom-line privelege, and what that privelege does is allow us to view the
site...ok so like how these priveleges would work would be cascading, so we would start with the least of them and work our way
up, so like that's what that is. So freaking ok, umm...so lets say we manually define priveleges, this will have to make sense!
Quite fundamentally what you have is a two-way circuit where users either do or do not have "a" privelege. The only thing,
though, is that in order for this to work elegantly the bottom line privelege would have to like display the public site to the
client. Otherwise there's no way in, no way out, and users have to explicitly define priveleges, in logical cascading order, to
so much as allow a random visitor to view their site! Fuckin' a!

Ok here's what we do, so we come up with a working version of this thing, so a working test-case, and go ok, so lets say there
is the bottom-line privelege, viewing the site, and another privelege, admin control. So freaking ok, then lets say we are
unpriveleged, so we view the site. The thing reads GET/POST variables for what to view and displays the site accordingly. Ok so
like at this point it helps to divide the priveleges into two categories: read would be output ("O"), and add, edit, and delete
would be input ("I"). So then we just define two priveleges, O and I, 0 and 1, so on and so forth, and these stack, so numbers
would work great (0 would be O and 1 would be I, or, therefore, OI). So freaking ok, umm...so we define these priveleges in
logical order...so ok, umm...so what we have is basically what this would be is 0 would be read and 1 would be write, and this
SHOULD be consistent, but what we'll need to do anyways is work this all the way down until we hit the bottom, and we're done!

So freaking now the question becomes: do you sit here and work on this or let it ride? Which do you WANT to do? Ok so like I
would LIKE to like do whatever I want, whether I want to just sit around or whatever, so like fucking a that's what that is.

Ok so I was thinking and pretty much we aren't done with this project, so are we done with our project notes? Like no we're not.
We kind of are because we got it to the point that it is finite, but I mean does that mean we're done with THOSE notes? I kind
of want those notes to be about how to get anything on the ground, but I mean I dunno, does that make sense? Both. Anyways we
can always fix it in the future so lets just keep chugging along.

So freaking ok, we have an array...fucking a I am so fucking excited...dude if this freaking works...we're gonna be like fucking
public fucking heros dude. Fucking a.

Ok, so we have an array, then what? So like what we have to do is map out everything about what we have, then drill down
further, so that everything is accounted for and we progress towards our goal, at the same time. So ok we have an array, and
like some CRUD. Now, the array and the CRUD are two different things, so like we can build these as two seperate units. So like
what we do is go ok, we have an input and an output, so a two-way circuit, and what we do is go ok, when we input what we do is
change a value, so freaking...so ok we have one value, and then like what we do is...ok so lets say we have a count, and we loop
so many times as that count, and we go ok, so like then we do something each time we loop, like set a value to true. So if we
don't ever loop, we have (otherwise) a false value. So that is what that is.

So freaking ok, umm...so if we don't loop through the array we never have a true value, at least, or the boolean value of an
array is exactly equal to the boolean value of the count of that array (at least). So freaking ok, umm...so then what? Then like
we know that an empty array is false and an array with at least a count of 1 is true. Ok so if we go one step further, lets say
an array with a count of 1 is false and an array with a count of 2 is true. Then we have to draw a difference between the values
of said array elements to demarcate the boolean value of the array instead of simply using the boolean value of the count of
said array as the boolean value of the array itself. So freaking ok, what this means is that...like the secondary and boolean
value of an array is dependent on the values of its elements, and the primary boolean value is equal to the boolean value of the
count of said array. Freaking a. Ok, now...ok, so like if we DON'T use the boolean value of the count of the array as the
boolean value of the array itself, and we instead compare array element values to determine the boolean value of said array, we
end up with a consistent boolean value representing the array itself. However, there is like no point to this, at this point,
because we can convert count to boolean just like we can convert element value to boolean. Might as well.

Oh freaking kay, then what? Ok so like the boolean value of the count of the array is roughly what we want, because it is
consistent to say that if we loop something at least once we potentially get a true value. So freaking ok, umm...

Ok so I have to put this in here somewhere: a freaking qi is the way to go because a number is equal to the sum of its parts
(which can be integers, and each the integer "1"), so a qi is the smallest (at least) number a number can be, which is
"omnipresent". Fuck yea dude.

So freaking anyways, umm...ok so like the current-working translation of numbers to booleans sayeth: any number greater than 0
is true. So freaking ok, umm...so like if we're wrong we can always fix it.

Ok, so freaking now what? Ok so like how do you know that 1 is true and 0 is false? 1 is something, whereas 0 is not, therefore
1 is true (something), whereas 0 is false (nothing). If we're wrong we can fix it.

Ok, so freaking now what? Umm...hmm...umm...so like I'm sitting here staring at the screen so hard:) Freaking ok, umm...so like
what this is is we come up with something then break it down...so like this thing is an array, in and out. So freaking ok, I
hypothesize that it's an array with some crud (including permissions, filtration, and storage) and like that's it. So freaking
ok, it COULD just be a hard-wired array and that's it. It's faster, for instance, to have it as such than to hard-code
html. Freaking a. So freaking ok, umm...so lets say we have an array:

array
	"Hello world"
	"Goodbye universe"

So we can read the array just fine from that point on, and that's all there is is reading (unless we manually edit the array,
the code, itself). So freaking ok, umm...so like what we do is...so ok lets say we read the array, we output it to some html and
we're done. Works. Now, if we want to add, edit, or delete elements from this array...:

array
	element
		read
		edit
		add
		delete

So what we have is a super-structure defining our array. What I mean is we don't just "have" an array with some elements and
stuff and that's that, we have some functions (READ) that define what we can and cannot do with that array, or in other words we
simply don't take anything for granted. So freaking ok, umm...so we have an array, inside of php. Now, we can either stop there
or define the grounds for the array, inside of php. So like freaking we simply stop there...what comes beore an array? A boolean
is simpler than an array...boolean fits rather well too because of our "practical numbers" (1, 2, 4, 5, and 8, as mentioned
earlier). So freaking ok, I guess just run with a boolean? A qi fits perfectly under all conditions...freaking a dude yea, what
is that anyways? It's a qi. At least. So freaking ok, umm...

Now what? Now we like extrude a qi until we get where we want to go. So like the thing is this is insecure. It has to be a qi to
work properly. Fuck dude so like you're done already! You're done! Done!

Freaking ok so lets get heavy into this, what do we need to do? So like ok, we need to map out our "practical numbers" such
that: we can tell what intervals these numbers occur at...so like since there's so few of them...

So they occur every 10 digits, since we're using a base-10 system...? Or like ok, umm...naa this doesn't make sense, because if
we have a decimal number...there's no difference between having a decimal number and having an integer. So freaking ok, umm...ok
so like even if, the systems are compatible, so what we observe has nothing to do with what system we're using. So freaking ok,
umm...so like what if we translate to a unary system and then to data objects and the like? Or I mean basically how do we go
from numbers to data objects? Or, how do we translate from division by these "practical numbers" to data objects and the like?
Umm...freaking umm...yea that's tough dude. You have to find some kind of numbers in what you have, element indexes or array
count or something, and work with it. Freaking ok, so lets say we have an array count and we divide it by one of these numbers,
where does that get us? Well, at least, on the view we would have a well-organized view. AND that's the view, so I mean that's
at least what that is.

Freaking ok, where do we go from here? Umm...ok so like what is happening is we're at the top, and we work our way down, and all
the way there the correct one of the two of them (if there are two of them) is up, so when we get to the point where there are
two, and only two, of them, we have like a conundrum where there are two, and from there down there are two. The thing is,
however, simply that the correct one is up. So we advance past that point (based on logic).

Freaking a. Umm...so I really don't know what to do! Like I figure I just come up with something and see how it works out, trial
and error all the way there, kinda thing. So freaking ok, umm...I mean I THINK that's what I've been doing is I'll come up with
something, then I'll contrast what I have with what I've come up with, then I'll draw some conclusions about what lies beneath.

Anyways lets do it. So freaking ok, umm...so there's like...so we have an array, what we want is an array...or is it? Like ok so
we hyperpostulate that what we want in the end is an array, BECAUSE we want a system that handles multiples. So freaking that's
AT LEAST what that is, as far as that is concerned. When the time comes we'll simply dig down a little deeper if we're not
right. The only thing about this, though, is it takes LONGER to do if we don't get it right now, because it isn't as sharp. So
freaking that's what that is. Fucking a dude.

Ok so like lets say we divide by 16, so 8 times 2, we get an acceptable number...so like what these "practical numbers" are is
freaking...numbers that...ok I think we have it right...we're right about SOMEthing. Fucking a dude if we're not just plain
right we are so fucked. I mean so far it works. So it IS consistent, so it IS WORKING! So fuck yea dude that's what that is...so
like what we do is hang on to a qi and that is what! And then we are sitting here and we have no idea...no fucking idea what its
like to be sitting there with a qi, hoping it ACTUALLY works, instead of going to dogshit hell. And that's what that is!

Ok man, fucking a! What do we do here? So like we go ok, we fucking...we fucking take an array and we go ok, if we have an array
in a vacuum, then what? So like what we have is:

<?php

$array = [
	"Hello world",
	"Goodbye universe"
];

?>

And like that's it. So the thing here is our view, therefore, doesn't alternate, it doesn't change, it's the same as what we get
if we just don't code anything, an empty browser window. So fucking ok, umm...what do we do? Ok so if it's an empty browser
window, then what? So it's the same as doing nothing, in a way, so like that's what that is. Ok so then lets say we have our
array in a vacuum...ok so at this point if we don't have any code we get the same, empty, browser window (view). So like ok,
that is a thing. Anyways, umm...so we have an array in a vacuum, umm...so like we have to read the array to the view. So
freaking ok, umm...what we do is...or do we? Like we have the array in the code, and like is that enough? That's a view. It's
not the view of the output of php itself, so...so it's "like" not the output of php, it's the input of php. And what we want at
this point is the output, so we go with it. So freaking ok, we need a way to output our array to the view, so what we do is (at
least):

<?php

$array = [
	"Hello world",
	"Goodbye universe"
];
echo join($array, "<br>");

?>

Voila! Now, that is the "output". Then we have the input, where we can mess with our array. So freaking ok, umm...then what we
would have is...ok I'm not going to write this because I don't want to, but like what we would have is...we would basically, at
least, rewrite the php file itself to reflect the changes to the array, so rewrite the array hard-wiring, in terms of editing,
adding, and deleting array elements. So freaking ok, umm...so what are we getting at here? This isn't fundamental enough! We
need a qi! And we have one! But does it work?

Freaking umm...well dude we have to like carry on. Lets do this:

Ok so now these notes are inside here, so that's what that is. One big, long pile of notes. So freaking ok, how do we do this
bad boy? Freaking umm...so we have an array...then what? So ok like all I can think about is we need to run the array through
a battery to figure out what to do with it. So like ok, umm...

So carrying on from where we were before, lets say we had an array in a vacuum, and like...so we have like an array, just it
doesn't like do anything. By the standards of the view in the browser, it doesn't do anything. Or, just simply, it doesn't do
anything: it's an array in a vacuum, nothing is done with the array, it isn't stored anywhere (in files, mariadb, etc.), and
thus there is like no point. So there is at least no point. We can fix it if we need to in the future. So freaking ok, umm...
so we have an array, then like we need to actually do stuff with the array. So freaking ok, what comes to mind first is that
we have to do the same thing over and over again, READ each element of the array, and so like what that is is an alternative
model to READ the array. So freaking ok, umm...what we do is freaking...so like we have to READ each element of the array. We
don't have to READ the array itself (this makes little sense as the array itself equals one and only one thing). So like ok,
AT LEAST what we do is READ the array elements, so we chug through one element at a time and READ, so like this is consistent
with the view: we read the element into the view, and with it it's UI controls (edit, add, and delete, and like ordering stuff
as well...). So freaking we would have to account for ordering as well, so like what we would have is...umm...so like ok we
COULD have any number of controls and stuff, and "stuff" associated with this array, so like the question becomes how the hell
do you do THAT? Freaking a dude. How do we freaking do this? So ok one limit with arrays is ordering. Once you order the
elements you deal with the indexes of the elements. From there we have values, so like then we just need to add, edit, and
delete. And of course we need to read. So freaking a dude, is that it? I think that's it. What if you wanted to do something
else to an element, something weird, like use it in a calculation or something? Then you would have to account for stuff going
on INSIDE of php. Fucking a. So ok, if our elements are all string, because php code itself is string, or if nothing else
because that is what we're going for, umm...freaking umm like all we would have is like filtration and storage. So like
freaking ok, umm...so what we would have is...:

index.php
	storage
		ordering
			filtration
				read
				add
				edit
			delete

...

index.php
storage
filtration
ordering
read
add
edit
delete

So freaking ok, umm...like that's at least what that is. The thing is though, it like doesn't go beyond that point. There is
only so much you can do with an array. Filtration accounts for different string values of the elements...yea thats what that
is, there's like nothing to it. So freaking ok, do we FINALLY build this thing or what? Freaking umm...hmm...so ok like what
we have in syntax is:

<?php

$array = [0, 1];
echo $array[0];

?>

Where we have an emphasis on selecting an element of the array. So like in syntax...ok so there is so much consistency in
syntax...like we have to specify an element, so then we have direct reference or left-hand assignment. So freaking ok, umm...
is this really a reliable way to do things though? No. Because we COULD have a system that only directly references the array
(a system wherein things are highly automated) to reference elements of the array and the array itself. So freaking ok, then
we have two, the array itself as well as elements of the array...so like we have to resolve some stuff...if we use a single
seperator, we have a one-dimensional array, if we use a single seperator and coupled seperators ("[" and "]", for example) we
have a multi-dimensional array. This then accounts for the entire potential of an array...and then we have an array itself. So
freaking ok, we go the route of a multi-dimensional array. So freaking ok, umm...hmm...ok like then we have to...so when we
store data, we have syntax that deals with this storage, and that syntax would be peppered into the code...:

<?php

$mysqli = ...;
$mysqli->query("INSERT...");
$mysqli->query("SELECT...");

?>

So like ok, umm...so like what we would need to do is translate an array into mariadb, filesystem, etc, such that we have one
consistent mechanism for our stored data within php itself. Then what we do is we hook this mechanism up to mariadb/the 
filesystem/etc., and we have a layer of abstraction between php and our storage device, uniting all storage devices. From
there we filter data/etc., then store it, and we have stored data. Then we read and write accordingly. Ok, so how would we do
this? Translate everything into an array in php? Yea that makes a lot of sense...then we just reference the array...ok so like
when we read we would do this, because what we would do is, say, query the server from javascript to read out a section of
that array, so we would need to return all of the relevant (selected) data of that section of the array. So then...ok so like
consider if we have one and two seperators, so like then we have an array, so like what we do from that point on is assign
associative array elements, so like something might have an element called "name" that would be it's name...so like then we
end up with...ok so like if we have a class that represents the array, we can carefully control the value of that array. So
like get/set methods, etc. control the value of the array. So that's at least what we do. So freaking ok, umm...so like this
array would be a part of Cinder...since Cinder is what we want this array to be, a "central hub" of data and everything, so
like umm...so like each element would have a filter and a value, and...like that's about what that is...so like ok then we
would filter...lets say one of these elements was an array, it's filter would filter a number of elements in that array, at
least, to restrict the number of elements that array could hold, and like that's it. That's AT LEAST what that is. So freaking
ok, umm...so like the syntax between an array and one of it's elements demarcates a difference. So then we have two things. So
freaking ok, then we have one thing, because one is ever-present, so like...umm...so like then we have the array and the
element. Freaking ok, umm...so two things, array and element. So an array is an array, and an element can be anything, any
value, so freaking another array, a string, etc. So that accounts for everything down to the syntax. So freaking ok, umm...
then we have to like put everything together in terms of functions handling the array and array elements and such, so like...
so then we have some functions, so umm...so like we either call a function with the array as an argument of the function, or
we assign the return of a function to the array...or rather to an array element. Unless the return of that function is an
array (and one that fits our structure). So freaking ok, there's two things there, output (passing the array as an argument of
a function) and input (assignment of the array...)...so ok, umm if we assign the array we effectively return the array...it's
simply assignment of the array, or input, then passing the array to a function is output, so that's input and output, syntax
and all. Fucking a. So like what this looks like is:

<?php

$array = [0, 1];
echo join($array, ", ");

?>

at least in very basic format. Fucking a. Ok, umm...so ok that accounts for any syntax, therefore, as well. So anything we can
code. Any code, itself. Fuck yea. Damn that's bad dude. So like ok, if we represent everything with 1's and 11's, everything
is a 1, but not everything is an 11, and an 11 is two 1's, or two of anything, so like two data objects, two characters of
syntax...so we simply have to outline what a 1 is, and thus what an 11 is.

Fucking a. Ok so directly what if we want to loop through functions in php? So like what we do is...we have to have an array
of function names and then loop through the names, then call the functions. So there's no other way of doing that. That's what
that is. Fucking a. Ok, umm...so lets try this: if we have an array with two elements, each element is, at least, a 1. So two
array elements, an 11. So freaking ok, then what is an array element? A value. Ok, umm...so then a value is a value of a
certain type, of course, and so on...so like that is what an 11 is.

So NOW code it?!

Ok so I figure that everything is an error, a 1, but not everything is a success, an 11. So like this is consistent with 0 and
1, just I'm not absolutely sure...is everything a success or an error? Everything is true...but what is not everything? So
like ok all is one, at least potentially, now what if all is two? So then we have like two paths, and if the ball is not on
the right path we're fucked, so then we choose the right path, or two is the right path AND the wrong path, or "1 && 0", or 0,
and one is "1". So that's, at least, what that is. So then a 1 is true, and an 11 is false. Or like it doesn't even matter
what something is when there's no difference, because there is no difference, and an 11 is "1 && 0", or 0. So THAT is what
that is. Fuck yea dude.

So NOW what?

So like ok, umm...:

0 || 1
0 && 1

...thats what you have to work with. :)

Ok, so we start off with a 1, and build up from there, and if we ever have anything greater than a 1 we have an error. So then
what we do is go ok, we fire up the system, it instantiates Cinder, it checks for GET/POST variables telling it what to do,
then it does whatever it's supposed to.

Ok so now like coding this thing we have a couple problems. We need a system that codes html and stuff. It needs to code
everything efficiently, and what it does is code the freaking html and stuff that we actually send to the browser, so like it
doesn't need to be pretty or anything, but it needs to work. What's happening is I'm going ok in php the function that codes
the view directly outputs the html, and that output needs to be formatted and stuff, to a point. So what we do is...we back up
Cinder one and go ok, it's a factory that programs stuff, so like...then what we do is...dude this is going to be fucking hell
almighty. Code this thing dude. Right here, right now. So maybe what we'll do is get heavy into it this next week and freaking
get cracking on all this stuff. It's gonna be hard, but it's gonna be good. What we should do, what we will do, is code a
system that's all-inclusive, so that accounts for every little bit of everything in terms of coding and stuff, so like all of
the pre-processing and all that sort of stuff. This should be badass though, dude. Fucking a.

So ok what we do is...we like get chopping coding this thing and that is what. Fucking a dude this is going to be SO hard. Ok,
so we need a system that codes php (and html, AND css, AND js). So like this is going to be a doosy. Freaking ok, then like
what we want is to account for any kind of code, so any programming language, so like what we have is a layer where we code
the thing and then it codes the php, html, etc. So freaking ok, once we get THIS done, then what? Then we code Fractal, or
whatever we're going to call our CMS, and that is what. So freaking ok, umm...so do we build this thing or what? Freaking like
ok, umm...so if we code this thing, like ok, if we need to code a freaking 'nother thing...like this thing is going to work,
right? I mean actually work? Or what? Like ok, umm...so like we would have...a freaking...this thing would code the thing...so
like ok, what it would do is...freaking...code...ok so what else do we need to do? So this thing codes the code so that it's
efficient and everything, then...ok so thats the code, and we ARE inside of php, so like that's that, so...so like what we
REALLY need is a system that just freaking rips it, like something that automatically codes everything and freaking
everything. Like a fucking homewrecker assed freaking system. Fully automatic. Or the more the merrier. This way we just tell
the thing some stuff and ALL this stuff pops out, freaking ALL of it. Yea, that's what that is. So how do we code THAT? So
like then we get into the range of macro programming, where we're telling php (or whatever) to code stuff based on a pattern
or something like that, so like freaking ok, umm...THIS is nuts. That was nuts, THIS is OFFICIALLY nuts. So like freaking ok,
umm...what we do is...fuck. What we do is fuck, cumfuck, to be exact, and double-whammy all of our problems all at once. Yay!
Ok so anyways, umm, like what we do is...freaking...so we code a thing that codes a thing dude, you better get busy! You've
totally got all this work to do, hopefully you can stay on top of it all. So like ok, umm...ummmm...we like freaking go ok,
umm...so IF we did code the thing that codes the code, then where are we at? Where are we at in terms of getting this whole
thing done? So then we have a system that we can successfully code our CMS with, so thats good...then we code the thing...so
like we code the thing without it being efficient and stuff? Yea that's basically it...so ok we code this thing, so...

Ok, so we have a system that loads and what it does is read the GET/POST variables for what to do. So if nothing is specified
in the GET/POST, if the user is not logged in it takes them to the login screen, and if they are it loads the UI for editing
content (unless we have to deal with otherwise displaying the site itself, like if the UI for editing is built into that). So
like ok, lets say we hit the login screen, so we log in, then we load the index.php file again (or something like that) and go
ok, so if they successfully log in they are taken to the...main screen of the CMS, or if it's built into the view of the site
it loads the site with all of the admin controls. Freaking ok, umm...so then we need like a login mechanism for the admin
either free-standing or (somehow) built into the site itself. So freaking ok, then, beyond that point, what we do is...
freaking...edit the contents of the site at will, so ok lets say we edit something: we enter the new data and send it, and
then the server receives the data and goes ok, it checks...ok so BEFORE the data is received by the server, we have completely
formatted php (and beyond), and then what happens is php loads the html (and beyond), and freaking if there's JS the JS
filters the input, amongst other things. So like ok, umm...so like ok everything is up, so there's all this stuff doing all
this stuff (automatically), so like input is being filtered, output is being displayed, so on and so forth. So what we're
going to have to do is come up with ALL this stuff to do this stuff, there's no easy route about it. Or, there IS an easy way
about it, and we take THAT path instead of the hard route. So freaking ok, umm...or like just code the freaking preprocessor
and call it a day. Fucking a. Fuck. Fuck fuckedy fuck. Ok so lets say we get ALL this shit done, then what? Then we go ok, we
have completely presentable code, completely presentable output, so then we just keep a close eye on our input and make sure
everything comes out correct. Fucking a. So freaking like ok, umm...so we have everything done...then we just run everything
and it's all automated and we just sit there and collect a paycheck. Sounds good to me. Ok, so like umm...ok so like what we
do is code a thing that takes php and formats it, so removes comments/whitespace and renames variables. Yea. Fockin' a. So
like then we just feed it any old php (which is also what we want) and we remove the bulk of having a layer of custom code
that codes everything. If we really need that (for whatever reason), we can always add that on top of what's already there 
(the PHP preprocessor). So that makes a lot of beautiful sense. Fucking a.

Ok, so we code this thing, then what? Then we start chopping...freaking umm...Ummmm...so basically we're at the same point
that we're already at, like substantially. So we need to figure out how to code this thing. Freaking umm...fuckin' a. So like
we code this thing...hmm:

index.php
	instantiate Fractal
		__construct
			$_GET/$_POST["logged-in"]:boolean?
				load main view ($_GET["section"]:string)
					users ($_GET["user_id"]:integer)
						add
						edit
						delete
					pages ($_GET["page_id"]:integer)
						add
						edit
						delete
				log in
					input: $_POST["username"]:string
					input: $_POST["password"]:string
...

Ok so like the trick is in generalizing what a user and a page is. They both have the same functionality (add, edit, and
delete), so what we do is generalize them into one thing and we SHOULD be good. So fucking a dude.

Ok, so a user consists of a username and a password. Both are string. A page consists of something like an id, a parent id, an
order id, and like that is it. All string. So freaking ok, it's working out! Now we just connect all the dots and the whole
thing works, baby! Ok! So, we have:

index.php
users
pages
add
edit
delete

Freaking ok man! NOW what? NOW we like code the thing. THAT is what that is. Ok I'm out for the day dude, we'll get heavy into
this tomorrow.

Freaking ok it's tomorrow. So like what we do is code the users/pages as one array, so like then we can READ the array, just
then we also need user authentication associated with the users array, so like umm...so we like subjectively patch the system
thus...how do we otherwise do it? We have to somehow figure this out, we MUST figure this out, fucking a dude. If we don't, we
are like fucking so fucking screwed.

So fucking a dude, umm...ok so:

index.php
	array
		read
			edit
				add
					delete
						users
						pages
...

Ok so like my first preliminary assessment of this is that we would have...priveleges and the like altogether before pages, so
like every granule of data could be altered by users, and that's how the system goes. This makes a lot of sense...so like what
we would have is tables of data, and then users either could or couldn't edit the columns of the rows of the table, so like
there is a direct one-to-one relationship of everything going on: without priveleges, users can't edit columns of rows, with
permissions they can. And this trend follows all throughout the system, and thus we have like flexible numbers and stuff. So
ok, umm...:

index.php
array
read
edit
add
delete
users
pages

So like ok, umm...what we would have is...wow dude I think it's somewhat working! So like if we had a general process for
doing stuff...so first we would run index.php, then we would...authenticate the user, then we would display the array...so
like ok, first things first, we would need a way to make sure users were priveleged to READ certain elements, so like ok, lets
say, off the top, we put the files on the server, then we run index.php, then we run the installer, and like we install the
thing, so we install...storage...and everything, and then we go ok, umm...we install...ok so then we actually load the thing,
at which point we authenticate the user, then, depending on that users priveleges, we READ stuff, so like the base-user would
have full-priveleges, and so then we read everything into the view (users/pages/everything). So then when we go to READ users/
etc. we do so, and we're good! Then, ok, umm...so lets say we were going to edit something: if we have priveleges we can edit
it. If we don't we can't. So freaking ok, umm...so that's what that is. That simply is what that is. There is a way to do
that, fundamentally, so that simply is what that is. Fucking a. Ok, umm...so like we can READ, then what? Then we output the
frontend of the site and we're done!

Fucking ok, build this thing? Fuckin' a. Fuck fuckedy fuck. I mean ok where do we get if we build this thing? What good does
it do us? Yea for reals. What is that? How the hell do we do this dude? How do we break this thing all the way down...ok so
like things would be up, and not down, so like things would be 1 and not 0, or 11 and not 1. So ok, umm...then we just like
build the thing. I mean ok then you break everything down, bottom to top. Or top to bottom? And like what is, how do we break
this thing down?

So like ok, we go umm...so fundamentally we would have two things, still: 0 and 1. So 0 is an error...why? We have to know why
0 is an error to get that far. Either that or we have to assume what 0 is and go the route of creatively producing it's logic.
So like basically it just comes down to which you want to do. There is no difference. Well, there's a difference...ok so like
the reason things are up instead of down is because up is greater than down. So then we have to figure out what it is for
something to be greater than something else, to figure out how to do this. Fucking a. Straight up, most literally, fucking a.

Ok man, so what do we do? I figure that everything works, because if it doesn't and something works it doesn't work, and if it
doesn't work then it doesn't work, so it doesn't work, or it can't EVER work, so therefore things work, because I have seen
something "work" (the results were acceptable as "working"). So freaking ok, umm...now like we need to get busy coding and
stuff, we need to make some serious headway...

So freaking ok, umm...so I figure that what this is is...like ok, there's a billionaire out there who is making thousands of
times more money than me without moving any faster, literally. So like the numbers add up such that we can use a small point
to do things in a medium of many points (up). So freaking ok, that's what we do.

So freaking ok, umm...I figure that what I need to do is get this thing down...I have no idea how to do it, not like even the
slightest. I tried my system of scouring everything and then drilling deeper, so as to cover everything that is already there
(to a point), and then broadening what I have, and like it didn't do what I thought it would. So freaking ok, I have no idea
how to do this in terms of process, the process of moving from unknowing to knowing, so like what I figure is I just "figure
it out" and that's how the process works and stuff. Like what I hypothesize is that we're in a medium of indifference...would
we be in one, like phenomenally? So like if you described that in those terms...yea THAT makes sense, so like we're ALSO
HYPOTHETICALLY in a medium of indifference like phenomenally, and due to the nature of indifference everything is
indifferent...

So like freaking ok, umm...fucking a. The thing is like solid concrete and I'm sitting here bare-handed. Yea that's what that
is. Ok, umm...ok I'm drawing some serious blanks. Ok think about it man, if you pointillated an image...ok so if we use 1's
and 11's, 1 is failure and 11 is success...? But if I have 1 I have 1, and if I have "1 && 0" I have 0...? Ok so if I have 1
I have 1, and if I have "1 && 1" I have 1...so it's not the fact that you have a number, it's what number you have. So ok, I
hyperpostulate that 0 is the beginning of non-positive, or "negative" numbers, and anything greater than that is a positive
number. So that is consistent...that defines the two poles of numbers...and the thing is numbers go all the way down! So THAT
is what that is, what we have is a number...or do numbers go all the way down? Ok so like true and false demarcate a
difference, and a difference is (at least) a number, so then we have a number...ok OR we have a number, or two numbers, and
let's say one is greater than the other...the QUANTITY of the numbers is what we use to check whether one number is greater
than the other or not. So then we use a binary thing to check whether a number is greater than another number or not...so like
we break it all down to binary (binary code). Umm ok...then we have two. Then what? Then we need to break it down to one, so
what if we narrow it down to two...ok so two or greater are greater than one, or just anything greater than one...ok so like a
number is equal to itself...that is like how we tell what a number is. Ok so like what we need is we go ok, we hyperpostulate
that we have a number, and that we have numbers, one greater than the other, and so on and so forth, but we do not HAVE a
number. We do not yet HAVE a number, for sure. So what we have to do is come up with a number. So shortly what a number is is
AT LEAST two of something with equal values, or just two of something. So two rocks, two cups...so then what we have is one of
something, and what we need is two of something...consistently, such that one is down and two is (ever so slightly) up. So ok,
then we go one step further...then we digest this into the fact that one, two, there is no difference, and there is no
difference because we have access, access to the other things that exist, access to two pixels on this screen, or rather we
have one and we have a theory of two, and not the other way around. So then what we have to do is PROVE indifference to get
from one to two. Ok then. So shortly, it doesn't work to demarcate a difference. So we have indifference, because...
hypothetically we have indifference. Shortly, we hypothesize that there is no difference because we can dream of two,
something we can only do with indifference, because otherwise there is no way to access, to explain accessing, more than one
thing. Both functional and hypothetical. Safe and sound.

Then, what we need to do is work along the same lines, along the lines of "x === y", and so I figure what we do is have a
smattering of stuff, diving in head-first, just the amount of time until one is completely submerged is short, moreso what we
have is, well, water. It is as if we are swimming across the ocean: we, at some point, finally dive in; the swim is what takes
the time. Therefore, what we do is develop some sort of protocol: we move from the top down, from the broad, the diverse, from
strings and numbers and what have you, to two points, 0 and 1, false and true, and then one. So what we need to do is develop
generalities.

Somewhere inside of the thick of this is the relative bottom of it, if 0 is otherwise equal to false, and 1 true, and any
other value otherwise equal to the others, things are relatively stable. Relativity in, relativity out. It is therefore simply
a matter of organization, of sorting relativity, to achieve our goal.

So let us begin.

So what is a function? What IS a function? It's return? It is AT LEAST it's return, which is, it should be noted, a value. So
ok like fundamentally what we have here is something is either equal to something else or not. It isn't, relatively speaking,
at this point, a matter of what something is, but what something is equal, or not equal, to. So we hyperpostulate that things
are true instead of false, because things "work" as opposed to "not work", but we have no proven our point, we have not
brought our point to a point. So what we do is simply relatively work things out until we reach the bottom of it, just like we
proposed earlier. Ok, so lets say we have a number, 0 or 1, and we theorize that 0 is equal to false, and 1 is equal to true,
and so on. What if we had the opposite, if 0 was equal to true and 1 was equal to false? Then, if the numbers don't add up,
things don't work, so we have to figure out why a number greater than 0 is true and a number less than or equal to 0 is false,
at this point. Ok so 0 is false and 1 is true because 0 is a less quantity than 1, but then why is 0 false, as opposed to 1
being false, 1 or 2? Because it is a negative (non-positive) number. Ok so outside the realm of computers, what do we use for
a bi-polar system? The same thing twice, so there is only one thing? Ok so there would hypothetically be no difference, which
means everything is the same thing, or all is one thing, and one is a quantity, and a quantity is a number. Basically, we use
numbers to represent differences because otherwise there is hypothetically no difference. So like then we loop through numbers
until we hit a positive or negative number, and hit 1 and 0, respectively.

Ok, so now like we start to build. We would have at least one user, which is 1 and not 0, true and not false, success and not
failure, and then...ok so like what if...ok what if we use numbers to build this thing, so it's consistent all throughout,
and...so lets say this thing ran, it would check for GET/POST variables, so then it would go...ok so it would check to see
whether the user was logged in or not, or rather it would check user priveleges, so like it would see...so it would check to
see whether the user was logged in BEFORE it displayed the view...ok so it would output, php would fire up, then it would
input, write all the data to the server, then it would output again, read all the data from the server and display it on the
page. So freaking that's what that is. So index.php would fire off, then it would read input, whether the user was logged in/
etc., so then it would go ok if the user is logged in display the admin controls, and...do any input we need to do, so like
store data accordingly, ...ok so like what if we make an all-around system for coding stuff? We go ok, we have something like
a static system that goes ok, if there's an error trip a switch, and then from that point on everything is erroneous, so like
you have to correct the error or something, and it doesn't (necessarily) crash the system, yea that is AT LEAST what that is.
So then ok, umm...so then we have error, and otherwise what we would call it is success, so like...or like what we do is just
start coding, and when we encounter one of something we work EVERYTHING out until it's all represented by quantities, and thus
numbers, so translate everything to numbers. Now, we shouldn't have much work to do if we're right (everything will already be
numbers). So freaking ok, lets say we fire the thing up, it reads the site. What it does is...like read the pages of the site,
therefore construct the nav, and (potentially) load multiple things into the view. So what we have is:

index.php
	users
	pages
		page
			load multiple into view

So like what that is is...things. A collection of things: users, pages, so on and so forth. So like what we do is we translate
everything into universal stuff, so numbers to booleans and whatnot universally, and then handle these things with the system.
What should result should be highly logical and highly functional. So yea that's consistent...this IS beautiful though, it's
totally crystallizing before my very eyes.

Ok so lets run this thing a little bit and see what we get:

index.php
	check whether user logged in or not
		display backend
			loop through sections
				display section
					a section is an array of data
						loop through section and display elements
							example
								users
									display
										add
										user
											edit
											delete
							example
								pages
									display
										add
										page
											re-order
											edit
											delete
		send to login
...

So like ok we would have sections, which would be arrays, and...so we can add, edit, delete, and re-order elements of the
array. Then, we can turn on/off ordering of the array, and of anything else (add/edit/delete). So freaking ok, this is
perfectly inline with our privelege system...so then what we would do is a user would have permissions, and...lets say they
had 0 priveleges, they have the read (0utput) privelege, and they can view the site, but they have no backend priveleges.
Then lets say, ok so this is what I'm getting at, if...ok so like which is faster, explaining this stuff or coding it? Like
coding it. Fricking ok, umm...:

index.php
Cinder
filter
storage
element
user
page
add
re-order
edit
delete
output
...

Code this bad boy?

Ok so the thing needs to be completely granular. I'm coding this thing and I'm going ok, so when we actually build this thing
on the view, we have to switch between static html and js modes, so right then and there the thing is forked at the very top
of the view. So like what we need to do is account for forking all throughout the structure, so like what we do is define
forks or something...well the thing is I have no idea what to do off the top, therefore I'll figure it out by coding the
thing.

Ok. So like what we're going to do is use the DOMDocument class in php to code our websites, then we're simply going to create
like a class that represents the website, then inside that class we create the DOMDocument, then everything goes from there.
Beautiful. So freaking ok, umm...then we just have to format the php, js, and css and we're all good. So freaking ok, umm...

So like the thing about this at this point is it will (definitely) go all the way down, so you can do one of two things:
either just start coding, or continue to plan this bad boy out. If you code it you get the best of both worlds, where you can
actually get some work done while you build the thing.

So what'll it be?

Umm I guess lets like code the thing...unless you have some better idea? Ok so how would we make this thing out of sheer
indifference? We know that it would be numbers...should we just code the thing? Is it coding time? It seems well laid out and
everything...yea lets code it. Let's just go for it and see what we get, if it isn't going anywhere we'll come back to writing
notes about it.

Ok yea lets do it.

Ok so what's happened is we have to code a thing to format PHP/MariaDB/HTML/CSS/JS into the leanest, meanest version of the
code possible. So like ok, umm...so what do we logically have to do beyond this point? Like where does it end, so we can start
from there? It's all numbers, so like it's just a matter of mapping it all out. So ok, in the end we have a website, the
Cinder website (for example), so the actual output needs to be lean, mean code. The only thing is it also needs to account for
other stuff, like projects and stuff that don't necessarily fall under the title "website", or just anything, if at all
possible, so like then what? So ok if everything is string, basically what we have is some XML or a PHP array or something
like that, so like umm...basically what's happening is I'm coding and re-coding everything, so I need to just get to the
bottom of it to kill it all in one fell swoop, off with it's head!

Ok, umm...so we would have a project, then we would have Cinder. Then we would have anything, not just a project, so like we
revert to straight string (XML/PHP/etc.), so then we just convert string to whatever we're trying to build and whatnot and
that's the end of it. So how do we do that? Ok so the point of string is that everything works in string, or basically that
all PHP is code written in string. So freaking ok, whatever we can code inside of php we can represent in string, so what else
do we want beyond that point? Wouldn't that mean that string is what we use? I mean it's a mean point, but isn't that what
that is? Coffee...

Ok, so we freaking code some stuff...like ok, umm...we have some string. And like that's it. So then we need to regularly
express, basically, to deal with that string. So like ok, umm...what we freaking do is...code the thing. We just plain code
the thing.

So ok, what is this thing? It's some string, technically speaking, in purely technical terms, it's php code, like simply
because we're inside of php. So ok, we have some php, so what is this php? Any php? It's purely php, so any php. Ok, so in php
we have things, which translate to numbers, so like what you need to do is figure out what a "thing" is in php.

So like a thing is a unit of string, or a character, otherwise there's no change in php. So then we have things like variable
and function names, and so on. So like either way you begin your journey of learning php to a point. TO A POINT! Meaning all
function names, all constructs, every tiny little thing. Fucking a. Ok man, is there ANY way around this? This is going to be
some seriously exhausting work, I think, so is there any way to do this more quickly, to work our way around this and still
get to our point? Is there even a point to this, or are we better off going with something like Divi or somesuch? Is there
still a point to coding stuff by hand? Both. Ok, so like what we need to do is make our minds up about an interfacial coding
framework, kinda thing, so like ok, umm...ok so like our system is made of string, not php, at least before it hits php...it's
numbers. It is Number. So ok, we need to figure out how to come up with numbers to do everything. So freaking if everything is
either a 0 or a 1 we get a little, or rather a lot, further along. So then ok, how do we code everything from that point on?
It like really is just a matter of coding the thing...so you code a system that refines code, then what? Then you code
something. Then you code, like, your Cinder website. Ok, umm...so then we have some code, some well-refined code, and...
like...then we post our site on the internet. That's like freaking it. So freaking ok, umm...so generalize the whole process,
run it over one more time.

So we have some string, and like ok, umm...so the thing is we're running in php, but like we can still have any string (we can
just define a string in php), so like we can have XML etc., which is then dealt with by php, so then what we do is write some
php to interpret this string, or, fundamentally, just write some php, and we interpret this string...so ok, going from 0 to
a full-blown website (1), what we do is...:

code
	frontend
		backend
			php
				array
					users
						username (unique)
						password (strong)
					pages
						id
						parent_id
						order_id
			mariadb
			html
			css
			js
...

So ok, now, generally what is happening? So like we have an array of stuff we need to do, then like...:

frontend
backend
php
mariadb
html
css
js
array
users
pages

Ok so like we just plain need to start coding this thing. We need to code the...ok we need to code the code refiner, and the
only thing I can think of is that we need to figure out errors and stuff like that, I don't really know what to do without
getting in there and coding the thing: we need to figure out like what the refiner is made of to figure out how to generalize
things past that point. Basically it would have errors and successes, but like we need to define what these are. So let's get
to it.

Ok what if we do this: we are using numbers, so we need to define what a number is, what one of something is. So like it's at
least an array element...yea that's what that is. Freaking ok, umm...so an array element...so it can be a string, a boolean...
then we translate those values to numbers, so lets say 1 or 0, so we would have:

boolean - true == 1, false == 0
integer - > 0 == 1, <= 0 == 0
double - same as integer
string - empty string == 0, otherwise == 1
array - 1
object - 1
resource - 1
resource (closed) - 1
NULL - 1
unknown type - 1

So even if we're not right, we can run with it until we get there and fix it at that point, so like now everything is
numbers...so like ok integers and doubles we would leave as is, and everything else we would convert as it says. So like then
ok, umm...so booleans would be a simple one or the other, so yea false == 0 and true == 1, so integers and doubles we would
leave alone, strings we would (at least) measure by string length, and then the same as integers/doubles, and then what we
would do is measure the character code of each of the characters of the string to figure out what each character of the string
was as a number, at least, and then the value of the string as a whole would be equal to all of these numbers added together,
at least. I don't really know what else we would do here, but that gets us a whole lot further along...array would be the sum
of all of the array elements, object would be...the sum of all of it's parts, at least, so like we would convert its
properties and the returns of its functions to numbers and add them together, resources...ok so resources would be kind of
tricky, we would have to detect what to do with the resource and then convert everything to numbers...is this overkill? So
lets say we have a number, 1 or 0...what we need is a real-world, working example to run this stuff through. Or what? Or we
could like come up with something...so basically what we need to do is broaden everything at this point, just like everything
before this point, and then deepen, and then broaden, and then deepen, all the way until we get there. So like that's what
that is. So ok like if we code this thing what we'll have is, at least, loops and forks, and then those are made out of some
stuff: they would need the ability to generate errors, and then like they would need to...they would be made out of code, so
like at that point you would need to like relate everything to a particular programming language, and so on and so forth. So
like what we end up with is an all-purpose programming language that we configure to output to a certain programming language,
and the thing runs, refines the code, and outputs the results to a file, or a set of files. So this system WOULD need to be
able to generate errors, and it would need to be able to do some stuff...it would need the ability to fork, to do one of
multiple things based on a value, and like that's it. We can loop and stuff by recursive functions and the like and like
that's it. So freaking ok, umm...so beyond that point there would be no forking, so what we would have is straight stuff, like
straight data or whatever. So freaking ok, umm...this is really interesting because it makes for a VERY simple thing. So like
ok, umm...so we would have straight data, straight html and css, no forking:

Cinder
	php
		css
		html
		fork
			mariadb
			js
...

Something like that. CSS would not be any forking? Like it wouldn't be a fork to assert:

div < .myClass

? It WOULD, because it's selecting one of two things...like it's using binary logic to do that, which is two-way logic, which
is fork...so like ok, lets go like this: lets assume it does, to be safe, and we'll go from there. So that's what that is, is
when we're not sure we assume true, or 1, since we're using numbers, and go from there until we hit a hard spot. So freaking
what we have is:

Cinder
	php (fork)
...

So basically everything has a fork in it. Ok so lets say php without any forks:

Cinder
php
no forks
forks
mariadb
html
css
js
...

So ok, like is there any point to JS with no forks? Like no there isn't, just like there isn't any point to PHP without any
forks:

<?php

$myVar = "Hello world";
echo $myVar;

?>

As opposed to just writing:

Hello world

In a php or html file, so no forking, so no php, effectively, even though it should be noted that it COULD still be php, but
no php then, so html, then "Hello world" in an html file. So then what we have is:

Cinder
html
php
...

So freaking ok, umm...so then what we have is like a logical stack...based on whether we have any forking or not. So html
doesn't have any forking? script/noscript tags. So no script, "noscript"...then we just have straight markup...or one thing?
Then we have...lets say we have the following html:

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Cinder</title>
	</head>
	<body>
		Hello world
	</body>
</html>

There's like no forking going on. There's like nothing conditional happening. There's no "one of two things happening", or
1/2, there's only 1/1. So we call 1/2 "fork", what do we call 1/1? What is the one word we call 1/1? Anything that denotes
something like indifference will work, so "indifference", "one", "One", so on and so forth. So let's say "indifference" or
"fork"...so like ok, two things: one, we have a constant (and not variable) name, two we have a constant value, defined by, at
least, a fork. So ok we could define our constant name by a fork, too. So like there's no fork until there's input, at least
(output before input). 'Cause then like we don't have any unknowns to deal with. Like even if the data is already in the
database, because then we just read the database (it's already been filtered and everything). So like that's at LEAST what
that is. Fucking a. Ok, umm...yea like ok, with no input there's no reason not to just have a static html site. Which is
definitely 1/1, or output (and not input). So then we would have output, then input, or a stack: 1/2 == output, 2/2 == input
(output + input). So like yea that's what that is...to a point.

So freaking ok, umm...:

Cinder
storage
output
filtration
input
...

So like that's what that is. Fucking a. So like I'm cooked for the day. I have no idea what to do with the amount of time left
(there's only 1 2/3 hours left in the day). Not sure if I want to just call it or what. So like freaking ok, so that's what a
fork is...and by the way, therefore 1/2 would be "output", and 2/2 would be "input".

So freaking ok, umm, I'm back again. So what to do here...ok so just plain 1 would be "output" and just plain 2 would be
"input", or 0 and 1, or whatever, the lesser being output and the greater being input. So then 0 would be output because...
because it's the first negative number we encounter on the way down. Really there's a better reason than that for it, but that
is AT LEAST what that is. So fucking ok, umm...

Ok so what if we do this...ok so like basically values would convert to numbers, and then that's string (inside of php, or
index.php, or a php file), and then we're inside of php. So freaking ok, umm...

So ok quick note, what I figure is that what we'll have in the end, in like the very end, is a custom programming language
that runs this whole thing so every unit of string is accounted for, or so we have units of string. I don't think you can do
that with an existing programming language...that's AT LEAST what that is.

Anyways...

Ok so freaking umm...so like now what we do is run everything through a battery where everything is a number...so we have some
string, some code, and what we do is go ok, umm...so like we have to define what every single thing is, so we define what like
"if" is, AFTER we define what "i" and "f" is, and freaking so on and so forth. Then the thing is broken up into single little
characters, and then single character codes, which are numbers, and everything is hypothetically a number because...? Because,
AT LEAST, there's no other way to explain everything. So that's what you have to run with.

Ok, umm...so then we have to define...ok so if this is all numbers, then like what we do is go ok, just run it in circles
until you get all the numbers mapped out. What you're shooting for is like a number-map, or a map! Mmk, umm...ok so lets do
this: lets run a little program that writes a file, and figure out how everything is a number:

<?php

$contents = "Hello world";
$file = "hello.world.txt";

function write($contents, $file) {
	
	if ($fh = fopen($file, "w")) {
		
		return fwrite($fh, $contents) ? 1 : 0;
		
	} else
		return 0;
	
}

echo (write($contents, $file) ? 1 : 0);

?>

So ok, "$contents" is one thing, AT LEAST, because it has a value, and that value converts to a number...same with file, both
are strings...then the function "write" is AT LEAST a number because of it's return (0 or 1), so then inside of that function
we have "fopen", which returns a file handler on success or false on failure, so we could call, would call a file handler 1
and false 0, by our conversion table, so freaking ok, umm...ok so like what if we bottleneck it a little bit or so, by going
ok, if we have "if", then we have 1 or 0 as it's comparitor, it works! So freaking then we have an if statement, or input, and
then what? Then we have the whole thing connected to numbers, so then what? So ok, then our syntax breaks. Writing something
like "if" is not as efficient as something else, I'm hypothesizing a number (some binary). So freaking ok, umm...so like ok,
what this would be is there would be either 1 thing, "1", or two things, an if statement, or "10", or a switch statement
("101"). So freaking that's what you have to work with...why is an if statement two? Because it denotes programming, or non-
static programming, so logic, so input, so 2. Ok then it should be noted that if we have anything, anything but, strictly
speaking, one thing, we have logic. Then it just runs through the whole thing and the whole thing is logic. So freaking pick
one, logic or no-logic? Fuckin' a:

000
001
010
011
100
101
110
111

So ok, 1 is "1", 2 is "10", and 5 is "101", which is half-way through a three-bit sequence. So that's what that is...and two
is half-way through a two-bit sequence, and 1 is 1, division by 1 doesn't change anything, so umm...so ok just connect the
fucking dots and you're done dude. Freaking ok, how do we do this quickly? If there's no difference, so hypothetically there
is no difference, so there is only one thing going on, so like that's it! Freaking a. So now we just map everything out and
freaking get it done! Get it fucking done dude! Done! Done done done! DONE!

Ok so like what would we have here? We would have some users, some pages, and like that's it. So we have a number of users,
and a number of pages, and then what we do is...display the thing. There's not that much to it. So freaking ok, umm...so like
ok, the only thing I can think of is everything SHOULD work out when you wrench it all into place, so just get started
working dude!

Ok man, what would be the point of having a programming language of your own at the top of this thing? It centralizes
everything, but is it necessary? Can we just code the thing in php, or something like that? Ok so like the thing is, if we use
php we have to write code that is strictly php...if we write our own programming language...so like we do both...so what is
the end of all this nonsense?

So like ok, lets say we program an "if". We write a simple "Cinder" file, parse it with the Cinder parser, and it outputs the
conditional output. So like what we do here is...we are designating some stuff, we are designating that "if" means one of two
things, so a fork (where a fork can have more than one prong). So freaking ok, all we need then is switch, and then all we
need is function, and we have conditional, recursive code. So how do we reduce it to one thing? We can have a function without
a switch, but can we have a switch without a function? Switch is two, whereas function would, therefore, be one. So we need
functions...we have function, then we have switch. Ok. So where are we here? We need a code minifier for integrated php, html,
css and js. In that order. So then like what this becomes is kind of a mess: we would have a php file, the minifier, that
would summon up the code to minify, so like then one has to wonder, what is the most efficient way to handle the minifier? So
ok if we just chug along the answer to this question should surface. So freaking ok, what's next?

So after minification we have completely worthy code. Then we're done. So freaking ok, umm...so we code a website, we minify
the code, and we're done? Is there ANYthing else we need to do? So I'm thinking ok, the way this would work, when it REALLY
comes down to it, like screaming hot and all, almost as hot as it gets, is there would be a single 1 or 0 that would drive the
whole thing, so it could effectively be completely turned on or off with this number. The point of this would also be
minification, where it is less to have a single 1, and that is it, and then a bunch of code running off of that 1 and so on.
So fundamentally, 1 or 0, at least, everything would be a 1, so I figure there's a 1 at the core of this thing, and then
everything runs off of that 1, so like...then we have a bunch of processes that define what that 1, broadly, does. So ok,
umm...so immediately following the 1 would be a 0, so "10", or 2, which would mean if, switch, etc. So freaking ok, umm...so
we have a 1, then we would have a two-way circuit, "0" or "1", 0 or 1, output and/or input, so then like...this all adds up
beautifully in stack. Ok, umm...ok so like generally speaking what would you need in your system, if you were to create like
a programming language or something like that? I would need like a way to store data...ok so without input this is all
freaking golden glory. What we have already works. Introduce input and things become a little more risque. So like ok, umm...
why would we want our own programming language? #1 it would just be badass to have your own programming language, lol. #2...ok
so like one has to wonder, if I make my own programming language I have a limit on what I can do with the programming
language, unless I do it exactly right: there is only so much code that can be coded before minification and everything adds
up to something inefficient. So like ok, umm...we have to do this exactly right then.

Ok, so lets say there is one thing, first, just output. So the thing needs to be able to access data and output that data to
the screen. So what we do is break everything up into single pieces, so data access would be via something like mysqli, with
credentials, so like...umm...so we would have a point where we would start to generalize all this stuff, so lets say like we
have a data object, and that data object is like simply an object...beyond that point it would have to be...umm...so like ok,
umm...we would have a data object, and that object would be...

Ok so it just dawned on me that what I'm doing is I'm finally building this thing, so cheers! :)

Ok! So we would have like a number, or something...what is this thing? It's a system that does everything! It generates data,
etc., does everything so much as automatically. So freaking ok, how do we do this dude? How does this thing work?

So like at some point it would fork data, it would use logical stuff to deal with data, so like "if" statements, "switch",
that kind of thing. So beyond that point it would simply output data...so there is a disjunction between output and input. The
output would be hard-wired, technically speaking (after input), so without input there would be no reason to have anything but
like a straight static website and such. So what this is is...like...simply a file with some stuff, otherwise an html file
with some static html (no JS, either). So freaking ok, umm...so for example:

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Cinder</title>
	</head>
	<body>
		Hello world!
	</body>
</html>

So like ok, what we have is a really simple thing, just some html. Freaking beautiful. So ok, now lets go one step further, we
can always come back and fix it if needbe, and go ok, so then we have input.

So our input would be variable because it's coming from a variable source: our users don't necessarily know how to program
html, don't necessarily have access to the server, and therefore need some sort of interface to input data. So what we have is
the beginning of a "fork", a fork in logic. So freaking ok, umm...basically we have to filter input before we store it on the
server. That's the difference between input and output. So freaking ok, umm...so like should we filter output too? Yea, we're
accounting for that by filtering on input, since after that the data cannot (does not) change. So freaking ok, umm...so we
have a fork, so a switch statement, at most...so yea we have a switch statement (you can do something like "0 > 1" with a
switch statement), so like ok, umm...what we do is...ok so that handles forking in the data. Then we need functions, for
recursion, so we have functions, and then we have full-bodied code and all. Quick n' dirty. Now, does this work:

array = [
	"Hello world",
	[
		"Hello, again",
		"Goodbye universe"
	]
];
function recurse(array, index = 0) {
	
	switch (array[index]) {
		
		case true:
			switch (type(array[index])) {
				
				case "array":
					recurse(array[index]);
					break;
				case "string":
					output(array[index]);
					index++;
					break;
				
			}
			break;
		
	}
	
}
recurse(array);
...

Ok yea appears to be working. Freaking a. Ok, umm...ok so like what we're doing is...lets say we have some data, and...like...
we want to conditionally deal with that data, so we want to account for variability in that data, so like what we do is we
"program" that data, we run it through a battery of conditions and do stuff with it accordingly. So freaking ok, umm...so then
the question becomes: do we build this thing? Like a master system? Or what? Like far too vast a question to answer at this
point, although it is making sense: efficient, non-redundant code is what we want. Non-redundant inside and out. So freaking
ok, umm...so then we have things, one or more things, then we...like organize these things and stuff like that. We need to
figure out, still, STILL, what one of these things is at some point. So freaking ok, umm...it's a number, that is for sure.
Then, from there, it is bipolar, so either positive or negative, so freaking ok, umm...then we just spread everything out and
it all works. So how far does the rabbit hole go? Yea, that's what that is.

Freaking ok, umm...so how do we figure this out? What if it's a collection of things, so two things? Then we need to like loop
through those things and do stuff with them. So we have some sort of loop, and some sort of fork. So we have the data itself,
a value, and then we have a fork and a loop, and we freaking go for it. Fucking a dude. Yea ok, so we still need like the same
stuff...that's what that is dude, it all comes together at a point. So we need storage, filtration, input, output...:

Cinder
	storage
		filtration
			input
				variables
	output
...

So like that's what that is. Freaking ok, umm...wow that's what that is...we're inside of php. So then we build everything out
of this stuff...yea yea yea! Ok so write this bad boy? Or what? Do it in php? Ok so you code this thing, then what? Fucking a.
So like ok, umm...so then we have our code that we wrote before, with the recurse function, so like then what? Then we write
some freaking code. Ok, umm...so I guess like lets code this thing...

Serious brain fart. Freaking a. Ok, umm...so like what we do is...I have no idea what to do. I mean ok, so like off the top,
we have a system that...is made of numbers...so like ok, then we have our data itself, then we have a fork and a loop. Ok,
then we freaking...

So ok, we have to program this thing, from the ground up. How do we do it? Freaking umm...so like lets circle around and see
what kind of stuff we see, like basically just start hacking away at it. I project that this shouldn't be TOO difficult,
though. All we have to do is lay everything out, then look for like "weak spots", and then drill down on those spots until we
hit the bottom of it all. So like ok, umm...so what this thing is is at least a CMS, I know it sounds a little nuts, but its a
start (I'm totally sitting here staring at the screen), so what we have is frontend, backend...:

Cinder
	storage
		backend
			filtration
				input
		frontend
...

Cinder
	storage
		output
		input
			filtration
				variables
...

Ok so like basically what I'm looking for is redundancy in syntax (oversized variable/function names) and redundancy in
semantic, so like...then there's like ok, what if...like if we go so far as to minify our code, what if we go so far as to
just whop it? Like so we build a thing that builds stuff, and freaking build massive, fucking potentially MASSIVE, stuff in
like seconds...in a very small fraction of the time it would otherwise take to build this stuff...with the aim of going all
the way there? Yea I mean that's what that is...so...the thing is, everything is fit to the minified code, so you just work
from there out, or like from the point that everything is a number, or both.

Anyways ok, umm, what we do is...so ok, hypothetically, purely hypothetically, how would you translate numbers to everything
else? Just look something up and go ok, whatever that is, translate to a number and you're good. You're even relatively
good...so freaking just translate to numbers, even if those numbers are somewhat whack (so relatively speaking in php, you
just translate to number...). From there you go ok, what do you NEED to do...so how does everything in php translate to
numbers?

Ok so zoom in on something and focus.

Ok what about this: in a unary versus a binary system, how much syntactic repitition is going on? Freaking umm...:

Unary		Binary
1			1
11			10
111			11
1111		100
11111		101
111111		110
1111111		111
11111111	1000

So the amount of syntax is...equal to (where x is the number of unary syntax and y is the number of binary syntax):

x = 2 ** y

Or something like that. So what is the point? Why binary instead of unary? It takes up less space, but it takes up even less
space to use trinary or something like that...so then what? Ok so we could code the relationship between unary and binary:...
or like ok, umm...so unary would go 1, then twice that (in syntax and all), and so on...:

<?php

$number = 10;
function unary($number) {
	
	for ($i = 0; $i < $number; $i++) {
		
		echo "1";
		
	}
	
}

?>
...

Or something like that...nothing to it. Then we translate to binary, or code the binary equivalent, and then what happens is
we have a huge step we have to take in terms of syntax, so like...so basically it's more fundamental to use a unary system, so
like ok whatever the number is it's just a...repitition of "1"...which is what we want, the same thing over and over again. So
like ok, umm...so ok, we figure out what one of these is by translating binary to unary...just code it dude it will only take
you like 15 minutes, even if it doesn't work in the end. Looks, simply, something like:

<?php

$number = 5;
echo decbin($number) . "<br>" . str_repeat(1, $number);

?>
...

So freaking ok, umm...now what is one of these things in binary? One of these is the same in unary and binary. Now the thing
is we have to translate to binary, because we're inside php, which means binary. So freaking ok, umm...ok dude I think you
MIGHT have figured this thing out...

Ok so if we have a number, lets say that number is 1, so our binary would be 1. So then if we have 2 as our number, then our
binary is equal to "1" + the decimal of 2 / 2. So if we have 3 as our number, our binary is equal to "1" + the decimal of
3 / 2, rounded (or something like that), so rounded fits. Then if our number is 4, our binary is equal to "1" + the rounded
decimal of 4 / 2, + the decimal of the integer of 4 / 2 / 2, which is "100" which is correct. So if our number is 5, our
binary is equal to "1" + the rounded decimal of 5 / 2, which is correct...no actually that's not correct, thats "1" and not
"0", and 5 in binary is "101", so we need a 0 at that point, not a 1. So if it's equal to 0 if the decimal is less than or
equal to 0.5, and 1 if the decimal is > 0.5, then it fits there...ok but it doesn't fit with 3 as our number. So freaking ok,
umm...god this is simple dude, what the hell is a number that is...so we just count binary, 1, 2, 3, 4, 1, 10, 11, 100, and
freaking that's what that is in binary. So ok, how many bits we have is equal to how many times we divide by 2 until we have
a result that is less than 1, so:

5 / 2 = 2.5, 1 division, 2.5 / 2 = 1.25, 2 divisions, 1.25 / 2 = 0.75, 3 divisions, so 3 bits, which is accurate...yea that's
what that is. Now, to figure out what these bits are equal to (1 or 0), what do we do?

1000

8 / 2 = 4.0
4 / 2 = 2.0
2 / 2 = 1.0
leading 1 because the number is greater than 0

1001

9 . 2 = 4.5
4.5 / 2 = 2.25
2.25 / 2 = 1.125
1.125 / 2 = 0.5625

round the decimal to find the bit! Ok...ok man, freaking ok, so a number would be equal to...so the magnitude of a bit would
be equal to...ok so you take a number, 9, and you divide it by 2 over and over again until you get a number smaller than 1, so
4.5, 2.25, 1.125, 0.5625, then you go ok...ok so here's what you do: lets say you take 10 and you subtract 8 from it, because
8 is the nearest multiple of 2, and then you take that number and...do the same thing with it, you get the binary form of 10.
Lets code this.

Ok so freaking coded a thing that translates numbers to binary. Now we just need to like translate binary to unary, then we
have all the pieces up to the point of just doing the same thing over and over again, so like then we reduce to one thing...
fuckin' a dude.

Fucking a dude. So like ok, now we have everything broken down in terms of translating stuff to binary, so what about from
binary to something else? Or what? Ok so we translate to/from unary, then what? Then we like figure out what one of these
things is and replicate them like hell. How do we do it though? What is one of these things? You're like asking way too
fundamental a question: you have no idea how things in general translate to numbers, and therefore you do not know your way
up. You have to go UP from this point, because you're at the point at which everything is fundamental, everything is the same
thing, everything is numbers, which is down, and therefore you only have one place else to go: up. So freaking ok, how do we
do it? So ok I was thinking and every so often in binary we encounter a 0 (1 or 0, could just as soon be a 1), so like the
pattern that we encounter 1's and 0's in describes what a 1 or 0 IS. Furthermore, effectively what you have to do is start
with "1" and bust everything out from that point, so if you just start programming you'll become aware of what you need to do.

So freaking ok, umm...so lets say we have a "1", then we go ok, 1 or 0 the thing runs, so if it DOES run it has to do stuff
like read and store values, so we need some sort of storage...it needs to store stuff because potentially that's what that is,
so purely in terms of potential that's what that is. So freaking ok, potentially we need storage, so we can store values, and
then we need filtration, just like we had before. Then we need input/output, so a GUI or whatever for doing input/output, so
like at this point we could reduce everything to string, so we just have string input/output...so like ok lets say we take
some input, we filter it and store it if it filters, and otherwise display an error message, and we also display an error
message if it fails trying to store it. So we have errors, storage, filters, input and output. Freaking ok, umm...like what is
the potential of this thing? This is really interesting. So like potentially it can take numbers and stuff and crunch them and
stuff, so like that's what that is, so we would need some memory to store the numbers/etc., then we would need number/etc.
functions, then...so this is inside the range of everything being string, so we convert to string then we do everything we can
with string. So we can search string for whatever we want, so like we totally have access. So like that's what that is...so we
translate everything to string and we're good...? Umm...but yea the thing is you need to span from one end of that thing to
the other. So freaking ok, umm...so we translate to string, then we have a pure string system, and like so everything in php
is represented with string, every value we could put in it we would do so with string, so freaking ok, umm...so yea that's
like what you have on your plate is you have to translate everything to the same thing. So like you have to figure out how far
the thing stretches, then you have to like translate numbers to everything else. Basically, ok, if you translate numbers to
something correctly...so like booleans, false is 0 and true is 1. Ok, so then what? So like then we build this thing. So then
we need to translate numbers...do we need absolutes? Or like what is the fastest way of going about this?

Well well...so we finally tipper tapper up to there with it. So what is this thing? It's numbers, so then what if we
translate...freaking ok, so like we only have to translate types...I think...yea that's what that is. So freaking ok, umm...
how do we translate everything to numbers? So a string...or ok how do we translate numbers to everything, coming more
fundamentally from the point?

So freaking ok, we...translate numbers directly to string, as in they convert in perfect form, then when we convert numbers to
integers/doubles, so if we convert a double to an integer we just get rid of the decimal, and if we convert...IS that how you
do that? So we would convert...I think something like -0.5 would be -1 in integer, because...actually no it wouldn't, it would
be 0, because we round to the right, so 0.5 would be 1. So freaking ok, umm...then when we convert to double we already have
double, so when we convert to boolean 0 is false, 1 is true, when we convert to a resource...how do we convert to a resource?
Why the conversion, anyways? Why not just do everything purely in numbers? One has to wonder...

Ok, so like we need to make sure we're getting this down mentally, or however we need to do this, to do this right. If it's
not right we have to come back and do it all over again. Freaking a. So ok technically, hypothetically, you just convert
numbers to mental units and you're good. But I mean are you SURE, you're 100% SURE that's how you do that? 100% numbers...ok
so lets continue under the hypothesis that that is what that is. 

Freaking a. Ok. Umm...so like I was thinking and I was like ok, so if we translate everything to code and stuff, what we do is
we start with a "1" then work from there up, so like what we do is...translate a "1" to everything else. Freaking a. So like
what is the point of translating? Yea there's like no point. I mean fundamentally that's what that is, is translating a "1" to
code, but then fundamentally we can just take a "1" all the way there. So that's what that is then, dude! You've finally
cornered it. Then you have to wonder, why not just get fundamental with the whole damned thing, with the whole damned
universe, and corner it? Then freaking ask it some questions. :)

So ok, if we DID translate a "1" to code, what would we get? So lets say we had a "1", then a CMS. So freaking ok, umm...the
parts of the CMS would represent the "1" in that form, so like a switch would be a "1" in "switch" form. Just to be brief
about it. So freaking ok, umm...or what? How do we more fundamentally, more quickly, strike the point? How do we make quick
work of this? We get fundamental with it. Ok what if you translate a simple fork to binary?:

<?php

if ($_GET["logged-in"]) {
	
	if ($fh = fopen("filename.txt", "r")) {
		
		$result = 1;
		
	} else
		$result = 0;
	
} else
	$result = 0;

?>
...

So like that's completely binary. So then we read the contents of "filename.txt", and if those contents are binary ("0" or
"1"), we just translate directly to binary and we're all good. What if it's something else? Then it's some other string, other
than "0" or "1", but the important fact here is that it's still string, it's one thing, the contents of the file are one
thing, string, either way. So then we just translate string to numbers and we've connected the heavens and the earth. Fucking
ok man, that may actually be it! Freaking what if the string is something like...ok so you have to translate...ok dude so
freaking the encoding for "0" tends to be 0, and the encoding for "1" tends to be 1. So freaking ok man, fucking a dude!
That's two! Ok so we can represent everything in code, which is string (or highly transmissible as string, transmissible as
string with 100% fidelity)...ok so php is written in string, or a php file is readable as string, and that string has an
encoding, so the question isn't whether we can represent php code as string, it's what encoding we're using to do so. Yea,
THAT is what that is. So it definitely has an encoding, and therefore definitely can be represented as a string, so fucking
THAT is what that is. Just fucking force your way through there dude.

Ok man, so this is what we do: we convert character codes (of the encoding) to binary, then we average the binary, then we
round that number to find the overall binary of that string. And thus we convert string to a single bit. So freaking then we
reverse the process...what this is dude is freaking so big that it's THAT big. If something is that big...

110001

So freaking that's a 1 in binary, in whatever encoding that is...I think it's UTF-16...I dunno. But ok, so the average rounded
bit is 1, so freaking...so then the position of the bits is what defines the data, beyond that point. So freaking the bits are
ordered in terms of magnitude...so like there's a correlation between the average rounded bit and the magnitude of the number
itself. At least now there is. What if we use some kind of wierd encoding? Yea if we can't use an encoding independently...can
we use our encoding reliably? Relatively speaking, yes. Does that work? This is all dependent on the encoding. So fucking then
what? What if we have an empty file, an empty string? Ok so the thing is, the way we convert THIS encoding is by like
translating what a string "1" and "0" are in binary to numbers. What if they are flipped, though? Then we like break the
encoding. Or I mean relatively speaking the thing still has integrity, so everything comes to a fundamental point...at
least...fundamentally there aren't two, there is only one. This is merely consistent. So this simply states that there is more
than one way to do one thing. Ok like if we translate string to numbers in such a way that they directly translate, we have to
have an encoding that abides by certain rules. If we don't, we don't.

Ok lets look at it this way: we either figure this out, or we map out every possibility in php, so every possible bit of code
that we could come up with, so we can plot the whole thing out and code "everything". Ok so "like" if there are two things we
have to choose one, and if there is one thing we don't. So that is "like" what I mean.

Ok, so if we freaking mapped out everything from "1" to some php code, we would have some forks...so like we would definitely
have a fork, lets say "switch"...or like we would have forks, ...so like basically we would have forks and then we would have
the mechanism for looping and recursion.

So freaking ok, umm...how do we do this? I mean ok, whether we do this fundamentally or not, like what we have to do is get to
the point where we have an encoding and like some other stuff...like either way we still have to do the same thing, is
basically what I'm saying. So freaking ok, umm...like what we do is...yea I mean what is that if it's like the same thing
either way? It means that like either way we have to figure out...we have to like come up with an encoding, then we have to
come up with some code, with a difference, something other than sheer indifference. So like what I mean is that there is a
single point all things have in common, and other than that...IS that what that is? Or like ok, so fundamentally everything is
the same thing, like over and over again, so like ok, umm...so like lets say we have an "11", so like what this is is when the
freaking binary converter hits three...so every so often this thing hits a number that is all 1's, that is directly compatible
with the unary system. So freaking ok, umm...I mean it's a way we COULD do this...so like every so often we have one of these
things, so like...:

1
10
11
100
101
110
111
1000
1001
1010
1011
1100
1101
1110
1111

So freaking ok, every 1, 3, 7, and so on...or landing on the first, the seventh, the 15th (or something like that), and so on.
So ok, what does it mean if this pattern doesn't have a one-to-one ratio? Like if we're skipping more and more as we go along,
there isn't a linear pattern going on? It means we have to break it down to a pattern, to know how these things behave, so
like what is happening is what we have coded (the 10- to 2-base converter), so that explains generally how things convert to
binary, so like then what is happening is...every so often these things occur, so they occur with less and less frequency, so
like what one of these is is a thing that...ok so like every so often there are two unary versions of these that line up in
certain ways, like the binary "11" and "111" would line up with the unary "11" and "1111111", so like...the thing is the
intervals at which these occur are like multiples of 2, so like x = 2 ** y...so freaking ok, umm...ooo dude...so like we would
have:

x = number of unary units
y = number of binary units
y = x sqrt 2

So ok x would equal 4 when y equaled 2...makes no sense in terms of x = y, so that isn't it. So freaking ok, umm...ok so like:

see above...

So freaking ok, yea like y equals the x square root of 2 or something like that. The square root of x with such and such a
number delimiting the square rooting or whatever, like how you put the number in there to denote what power you're using to do
the square root...anyways, so like that describes the relationship between unary and binary syntax, so like...in between
freaking...binary versions of these unary numbers we would have other numbers, and those numbers would involve zeros, so like
umm...freaking a. I'm out for the day.

Ok so freaking these numbers would be like...the thing is, they are numbers, so like x doesn't equal y, because whenever the
SYNTAX lines up with the two they are two different numbers, except when they are "1". So freaking ok, umm...so like this
doesn't make any sense, LIKE this doesn't make any sense. It makes sense, just not in the way you would like expect. Ok so
like actually what this would be is:

x = x
y = 2 ** x

Where x is the number of unary units and y is the number of binary units. I'm pretty sure that's right. Yea that's right. I'm
pretty sure. If we're not right we can fix it. And like even if I'm not right you see what I'm getting at. So like what we do
is relate these two systems, thus, and freaking...freaking ok so it's more efficient to use a unary system...no it's not, it's
more efficient to use a binary system. The only thing is that...so ok that describes like how they fundamentally relate, what
else? Or what? Or freaking just work this thing up from the bottom...isn't it the same thing either way? So like ok, umm...so
what is this thing at the top? Or what? So this thing is up, so then what we do is use it's functionality, directly use it, to
work with it, as opposed to building it and then using it. So freaking ok, umm...

Ok off the top. So we have a freaking thing that...we have a programming language...or ok we have a thing that IS a computer
program that is as efficient as possible, so freaking ok, umm...then we have...then what do we have? So ok technically
speaking a two in unary is "11" and in binary is "10", so like there's not even a correlation between the two in terms of
syntax, at least along the lines of value. So freaking ok, umm...there IS a correlation...there IS this correlation...so
freaking like there IS a correlation, fundamentally, between this and that, it's just a matter of how accurate it is in terms
of our goal. Does it have anything to do with it? So freaking ok, the nearer the center, the less of a difference, loosely
speaking, so we go all the way to the top and work from there? So like we skim the surface for clues and stuff. Or what, man?
Freaking ok, umm...so we know that, fundamentally, between two number systems x still equals y because both are numbers, and
both are the same numbers...ok so beyond the syntax is the number itself, so we just translate bases...and then we get exactly
the same number, both in syntax and semantic. So that's what that is then, is base and base conversion and related stuff.
Freaking a. So like that isn't the VALUE of the thing, so what about when we approach the VALUE of it?

Or like what man? This is like going nowhere...ok so this comes down to two things, broadly it comes down to two things...:

<?php

$array = [0, 1];

?>

So freaking ok, then what? Then like what is the full extent of how we can handle those two things? We can loop through them,
we can compare them...are they unique? They are unique, as in we have to have unique syntax to access each of them, otherwise
we have no way of doing so. This is AT LEAST what this is. So freaking ok, umm...:

<?php

$array = [0, 1];
$myVar = [];
$myVar[0] = $array[0];
$myVar[1] = $array[1];

?>

or just

<?php

$array = [0, 1];
$myVar = $array;

?>

or just

<?php

$array = [0, 1];

?>

So like freaking ok, we definitely need unique syntax to ACCESS each of these array elements, thus we have a unique number
identifying each of the array elements...or like basically, everything stacks up, it may be a little complex or whatever, but
everything stacks up resulting in one big thing. So freaking ok, umm...

Ok so look at it this way: two different values can either be the same thing ("1", for instance) or not, so they are at least
two different things. So then we reference these things, in the context of the above code, with unique element references.
That is, therefore, AT LEAST what that is. So we have one unique element identifier per element. Yea like that's what that is.
That's at least what that is.

Ok so like there's a dislocation between syntax and semantic when we, for instance, come up with something like an "if"
statement: we have the syntax, "if", and the semantic, what that "if" statement does. This can be somewhat elaborated with
functions: functions can be assigned arbitrary names. So freaking what this means is the syntax doesn't necessarily equal the
semantic, until we get down to the very nitty gritty of it. And what that is is like the fact that things are unique, and like
two of the same thing...means slight non-uniqueness, so that there are two things going on, one of them, then two of them.
They are still, rather fundamentally, the same thing, but they aren't: there are two of them (AT LEAST).

Ok, lets do this:

<?php

$array = [false, true];
$false = $array[0];
$true = $array[1];

?>

Which is the access of boolean values like such:

<?php

$array = [false, true];
if ($array[0] === false) {
	// do something
}

?>
...

Where there is, at all, directly syntax for doing so. Therefore...ok so the value of something is one thing (at least), so if
that value is true/false/etc., if it's true or false, that's a boolean, which has two settings, so that's a fork, whereas with
something like null, there is only one setting, whether that setting equates to true or false. So freaking ok, umm...so
something like an array, an object, etc., is one thing! So then we just translate one ("1") to boolean and that's what that
is, or simply "0 || 1" we get "1". So freaking that's what that is. Ok, so now things roughly translate, so now what? So
freaking ok, umm...so relatively speaking we have numbers, at least, so the thing therefore relatively works! Dude what if you
get this thing working to the point that it works with something like a qi? Like all of a sudden we're just omnipotent because
the thing "fits"?

Ok lets do this: what if we break down the whole process of building a website? So like we code the website, then we feed it
through our code refiner, then we have a completely production-quality website, ready to roll. So freaking ok, we'll have to
address media as well, so like reduction in quality/etc. for filesize, etc., so like ok...

Ok so I figure lets just code the thing and see what we get. We still haven't tried doing this so like it's totally on the
plate at this point. Lets do it.

So freaking ok, what we need at this point is a thing that: codes php, and everything beyond that point, so the maria, css,
etc. So what we need is...so like what is happening is we are using DOMDocument, in php, for our html, so like what we need to
figure out is what we need to use other than this, or how to integrate this...so what is happening is we have multiples in our
html, redundancies, so we need a thing that refines our html, as well as our js, css, etc. So freaking ok, what we do is
freaking make something! So lets say we build these things, then we have our php, and our php is refined by this thing as
well, then what? Then we like, finally, build a website.

So freaking ok, umm...call it for the day and get heavy into this tomorrow? Or freaking get heavy into now and have a huge
assed day? Ok lets try coding this thing, even like just some imaginary code to see what we get:

<?php

include ("Cinder.php");
$Cinder = new Cinder();

?>
...

Ok so how do we generalize things, to a point? TO A POINT? Like before we build a website, then what? Then we have something
like a project, which can be anything (not even php). It could be a painting, a song, working in the garden, that kind of
thing: anything. So freaking ok, umm...how does this apply to what's going on inside of here, inside of php? We could
catalog these things, for whatever reason...you could like then put them on your resume or something...so freaking ok, umm...
lets just get heavy into it tomorrow or something, we only have 2 2/3 hours left in the day, it's all good.

Fucking a dude! Ok man! How do you do this thing?! We're running out of time! We can sit in here all we want and work on this,
but the longer it takes the longer it takes! We're not really running out of time, but like we sort of are. Life is passing by
as we are working on this thing. So freaking ok, how do we do this bad boy?

Freaking ok man, so like I propose that we run this thing down, top to bottom, if nothing else. So like what we do is go ok,
so the refinery is like the last thing that we hit before we publish something, so like what else? What else do we need before
we GET THERE? Like freaking ok, we need, at least, a thing that handles multiples, so like for instance a thing that builds
things, our plug-in generator. So like at some point we're going to need our plug-in generator to generate webpages with
templated, multiple data. So like then what we have to wonder is what else we'll be doing more than once. The beauty of this
is that in the end it's one of two things (0 or 1), and then one thing (0 or 1), so like...so ok so we have something like our
plug-in generator, which handles multiples (gracefully), so like ok at the top we have our plug-in generator...so like what we
have is a single thing and multiples at the very top. So what we have to do is generalize the process of handling multiples,
so we go ok we put together our plug-in generator and our general multiple handler and we get...so like lets say we have our
plug-in generator (at the top!), so what we do is go ok, umm...so ok then we have an array with some templating and
filtration, and like I think that's it. So effectively what we have is a single thing, then our plug-in generator, at the very
top.

So we have an array. So AT LEAST what we have is an array.

So like ok, we have an array, and it's elements are filterable per type, or soemthing like that. Like so you wouldn't filter a
string the same way you would filter a resource, so filtration isn't applicable at this point. So we have an array, at most.

Perfecto!

What's next?

So ok, everything is decoupled and everything, so we start actually laying this thing down. So freaking ok, umm...so like what
we have is...some input...so ok either there is input or not, and if there isn't everything is simply hard-wired, although we
COULD still have filtration (filter naughty words out of output, for example), so that's something to consider. So freaking
ok, umm...so we have some syntax defining values of types, or just values. So freaking ok, umm...how do we do this...ok so
lets say we have a value...

Ok so if there's no pattern to something, there aren't two things. So if there's no pattern to a naughty word, there's no
naughty word. So freaking ok, umm...damn dude that's what that is. So if we have a naughty word, "fuck", we have a sequence of
characters, units of string, and then what we do is go ok, if we find other units of string in between these units of string,
if they don't follow a pattern (so many of them, etc.), then...there is no naughty word? So freaking ok, umm...:

f|u|c|k

Says...ok there's a pattern to it. If there's no pattern to it, there's no naughty word. So the pattern is describable by a
loop...so if there's no loop, there's no naughty word. So if we have:

f|u@c^k

There's no naughty word? Dude that is freaking brilliant! Ok what if we have the following sequence of characters:

1 5 2 6 3 7 4

There's a pattern...there IS a pattern, but like...there isn't...so if there is no pattern, there is no naughty word. If the
subject doesn't match the pattern, there is no match. Freaking a...ok so if there is no repitition in the sequence, there is
no repitition in the sequence, so like:

f|u|c|k

has the repitition of "|" between the letters, the characters, "fuck", so we have a form of "fuck" (just like we have "^"
between the characters, in micro). If we have...:

1 2 3 4

We have a form of repitition...there is a pattern...ok so if there is NO pattern...:

f|u@c|k@i|n@g

ok there is a pattern. There IS a pattern. So whatever it takes to not create a pattern...so freaking ok, we code a pattern...
so if we can figure this out, we can figure out what it takes to create meaningful string...! We can figure out like what a
meaningful string is made of, what pattern and such...so we translate to numbers, then we analyze those numbers for patterns,
and if we don't get any patterns we have a unique string, or no naughty word. Freaking ok, makes sense...so lets say we take:

fuck

and we go ok, we have four character codes:

1 2 3 4

Those aren't the real character codes, but for the purposes of this demonstration they will work. So freaking ok, now if there
isn't any pattern...so lets say we have a seperator:

1 2 4 3 5

1 3 2 3 1

1 @ 2 # 3 @ 4 # 5

So we have an alternation in the seperator value, then we have an "alternation", or a pattern, in the value itself:

1 @ 2 # 1 @ 2 # 1

So we have two alternations, or one alternation:

1 2 1 2

Then

1 2

Then an alternation of 1. So:

1 2 1 2

or

1 2 3 2 1

or

1 2 3 4

Or somesuch. So freaking ok, umm...so we filter out any patterns in the data. So ok:

1 2 4 3

Wouldn't have a pattern...or rather:

1 2 6 4

Wouldn't have a pattern...or:

1 2 3 1 3 2

Wouldn't have a pattern...so ok in order for there to be a match we need to have a pattern, so lets say the pattern is:

1 2 3

We have a match at first, then we don't. So then:

f|u|c|k

Would be filtered against "fuck", whereas:

f!u#c@k

Wouldn't. AT LEAST.

So ok we would define a pattern as a single value or set of values...actually ok a pattern would be a formula...so anything
that fits that formula...yea THAT'S what that is! So freaking ok, we look for a pattern:

f|u|c|k

We have the characters of the string "fuck" seperated by "|" characters, so we have a match...yea that's what that is. Fucking
a. Otherwise there is no way to freaking come up with something that breaks the rules...

So ok then what? Or like how do we work our way down to a point? How does everything come to a point? So we have an array, and
everything in the array is created by...a generalized process, so like we define the element characteristics, filtration,
etc., so freaking ok we have a whole layer of stuff, and then we have...

So we have an array. I was thinking and I thought, you know what, we have an array. Like I was thinking ok so there are
generalities going on here, where we have, for instance, our plug-in generator, then what we have is a structured array, so
more fundamentally what we have is, simply, an array. We have an array with some rules defined about it, with a special way of
handling it...generally speaking everything is generalized, so like what you need to figure out is...ok so we have an array,
then what? Or DO we have an array? Ok so what we have is something broad, not narrow, because it is beyond the point of type,
where it is an array. What we need is something that is a value, or somesuch...what we are looking for is, at least, a value.
So we have a value...why a value? A value because that is, at least, what a function returns. So we have a value, so WITHOUT a
value...so if we have a value we have, at least, something like a variable that we can pass to a function and the like...so
like roughly thats what that is, so freaking ok umm...

So then what? So then we level the freaking playing field, freaking ok man, you have to code your way all the way from there
to oblivion, you have to code everything from there to your plug-in generator and beyond. Lots of code. Lots and lots of code.

So freaking ok, umm...so like we would have a blank screen, then we would have something...the start of something...we would
have like an array...so ok the way we take advantage of this is to...

Ok so we would have a variable, so some sort of value, and assignment, and input and all that, or IF we had input we would
then have some sort of variable, and if we didn't, if we only had output, we would have a constant. And from that point on
everything is constant, there's no programming it or anything. So THAT is what that is. So freaking that is what that is. A
truly blank screen.

Ok, so then, what we are doing is programming the input. So freaking what we do is...ok so lets break it all down. We are
sitting here with a blank screen, and then there is genesis. We come up with some sort of "thing", some code or something,
that is the process of all of this generalization. So freaking ok, umm...so we map out everything from that point on so we can
generalize it all as much as possible. So freaking ok, umm...now, what if we run the thing off of constants so there is no
programming it, there is no change? If we don't, if we can't, change anything, we're at least good. Interesting thought.

So freaking ok, we have nothing, and then we have something. We have a value, of a type, so like...or how do we do this?

Freaking ok, umm...like at this point dude you have to be like freaking absolutely sure you're right before you advance. If
you don't do this right, you'll go careening off into the freaking darkness, into a land of redundancy and freaking a complete
mess.

So freaking ok, you have a constant, or everything is constant, or at the point at which you have no input you have no input,
so like not even input into php, not even some code, just a blank php file running in php. Whatever that means. So freaking
ok, umm...

So like we totally have time to get heavy into it. So freaking ok, lets say we have like, freaking...so we have one thing, and
where do we go from here? So ok, lets take our break down and smash it up into little bits.

Freaking ok, so we have our plug-in generator, and what this does is...takes some syntax and creates tables and stuff based on
that syntax, so what we can come up with is templated array elements. So what one of these is is a value that has a filter on
it, so what THAT is is a value, and then a filter. Filter first. So fundamentally we have a value, like floating in our
constants we have a potential value, so freaking ok, umm...

So freaking ok, what this thing is is a value. It's AT LEAST a value. It's like freaking...so it's a value, that we could pass
to freaking php, that we could pass through php, so...AT LEAST. Like I don't know what else we could possibly have...:

<?php

$value = "Hello world";

?>
...

Yea like that makes sense. PHP revolves around a single value. So freaking ok man, what we do is freaking build...type stuff,
"typology", that would define like filters and stuff for each of the types. So like we could have range filtration on numbers,
regular expression filtration on strings, and so on and so forth...so like...that's what that is. Plain and simple. Freaking
ok, umm...so like from that point we build...so ok how do we build this thing, therefore? Or like what is the difference,
where do we get from knowing that that is a value? Freaking a.

So like ok, build this bad boy? So freaking ok, umm...so what we need to do is plan this thing out, so like we need filtration
and stuff unilaterally, so what you need to do is figure that out and go from there.

Call it for the night and hit it hard tomorrow? Or what? It would be good to keep going, freaking a. Like freaking what this
thing is is...ok so lets say we build our plug-in generator with this thing. We have filters for each type, then...so like we
are going to build this thing, or what?:

Cinder
	output
		actual output to the browser
		saving to files
		any other form of output
	input
		input from the browser
		any other form of input

So ok, lets say you build this thing, so you build filters for all of the types, then you have filtered data. So freaking ok,
umm...so then we go ok, I guess build the damned plug-in generator? Or like we need to go one step further and go ok, we need
to be able to build anything, ANYTHING, with filtration and everything. So like ok, umm...so fucking code it dude, like what
all do you need?

So you have some data, some value, then you have a filter. Then like that's it! Filtered data. That's it. From that point on
you're good for freaking saving data to the server and everything. You can build the freaking thing from that point. Then it's
all string, code, and from there you just plug everything in and it's good. So ok let's build this thing.

Ok so freaking are we SURE that that is what that is? Freaking I don't want to have to come back and fix the thing or recode
everything, so freaking...umm...so it's a...ok so if we create two from one, if we use one function in two different places
(or something like that), doesn't that mean we can be fundamental to get everything done? We CAN do this, it works, by all
measures of working, but I mean does it REALLY work or is it wrong, is it a wolf in sheeps skin?

Fucking a. Finally, we touch down. So freaking ok, umm...how do we measure if something works or not? So freaking ok, umm, if
the end...do the ends justify the means? Freaking can't even search the internet for that. Anyways, umm...so freaking ok, umm,
like, ok so what we ACTUALLY, ACTUALLY, end up with is something that works, in the end. So ok, then we have to ask something
like: does that mean that everything in the script happens all at once? Happens all at the same time? It does in that there is
no interaction with the code in between the code, running and all. So freaking we can't start, at least not in php, php,
running a script, and then stop and prompt the user for something or something and then continue the script (with data
gathered from the user or something like that) like we can in something like perl. So freaking ok, umm...so there is, AT
LEAST, no fork there, which means one thing and not two. So freaking ok, therefore we have achieved oneness, even if only ever
so slightly, and that is that. Therefore this works. Therefore we can use one thing that makes two and we're good. So freaking
ok, you're COMPLETELY SURE you're right? You're ready to continue past this point based on this premise? Umm...yes. Ok, so
therefore we commit.

Freaking ok, umm...so how do we do this faster? Freaking umm...so there is, fundamentally, a point, and that is what that is.
We take that point all the way home and we're done!

So freaking ok, umm...how do we do this? Hah dude freaking ok man how do you build IT? How do you build THE ENDER? The ender
of all frustration, of all trial and error? Freaking umm...

So freaking ok man! There's like nothing left to do but build this thing! Unless you want to sit here and theorize about the
details! Good job dude, way to get it done. 13,000 lines of unbridled explanation!

Now code! Code, you code monkey!

Ok lets hammer this out. What's happening is I have a filter for every type, so first I would have a type, then I would have a
filter. So freaking ok you have something like a value, then a filter...so freaking ok, so you're sure you wouldn't have a
filter first? Well like basically you wouldn't have a filter before you had a value, so...ok, umm...freaking...so like we
would have a value, then we would have a filter, so freaking build it dude. Ok then what? Or what? Build it dude.

Ok so you really are better off sitting here figuring this out before you build it...I mean, sit here and be mental? You have
to scoot dude! You've got to move it so fast that like you're sitting here thinking.

So freaking ok, umm...freaking umm...so lets get heavy into it, what do we have to do? Basically we have to work everything
out, work it down until we bring it to a point. So, quickly, what I figure is that there are no forks throughout the whole of
the thing, there isn't a point at which...ok so like freaking what we do is go ok, we take what we already have and skim
through it until we find a spot that needs elaboration, so like...freaking...so there would be no forking, so how do we get
from here down based on that logic?

So ok we're at the point where the thing is like wide-open, and freaking...so ok what I'm thinking is how do we make it down
with the basics, the fundamentals, of computer programming: forks, loops, and functions? So we could have a loop or a function
within a fork, and we could have a fork inside of a loop or a function, and so on. So freaking ok, what is the logical order
that these go in...or what? Somehow we need to grind our way down until we get there. Freaking ok, umm...how can we get this
down quickly, instead of slowly? Like how do we be fundamental with this so as to get it done quickly, and not slowly?
Freaking ok, so fundamentally...fundamentally there are no forks in the entirety of the thing, just like we said. Now, how do
we know this is true? Or what? Just pick a spot and start laser-beaming it.

So ok if we go with something like value and values, what we have is a value with multiple values inside of it, at least.
Otherwise what we would have is two values. Either way, we have to create a way of going through each of the values...so ok,
the thing is there is less forking to use an array to store these values, so like that is what that is. So what we do is have
a master value and everything runs off of that. Brilliant. Fits your view like a glove. So freaking ok, umm...so then like
PROBABLY what that value would be is an array, so that we're not trapped with a single value (where we would like then have to
convert that value to an array and so on). So freaking ok, umm...so what we would do is...freaking...I mean basically you
would just code the thing. What lacks such that you don't want to just do that? So like ok, we're going to get to the point
where we hit a soft spot, and then it becomes a matter of digging up that soft spot or living with it. So like what this is
is, for instance, lets say we code this thing, and we have a master value (an array), and freaking...we get to the point where
we code errors into the thing. So like what is going to happen...ok I mean all you need is elaboration, so you just find the
soft spots and elaborate until you get there. So ok, what exactly is a soft spot? A soft spot is a spot that consists of more
than one thing so that we have to code two different things to handle that one soft spot. So freaking here's what you do,
dude: code until you hit a soft spot, then freaking let it have it, dig into that thing until you freaking hit diamond.

So freaking ok, what is a soft spot that we have so far? Do we even have any soft spots? Have you even tried coding this thing
yet? Freaking ok, umm...so whatever this thing would be would be beyond comparison, because comparison alternates: "2 > 1",
but "!(2 < 1)". So then we have, at least, a single value, and whatever that value is is greater than another value. So
"1 || 0", "1". Freaking ok, umm...so the smallest two numbers that are polar opposites are 0 and 1. Both efficient and
functional.

Ok so basically, beyond comparison we have a single value, and "1 || 0" we get "1". So freaking that's what that is, both
complete and open-ended at the same time.

So ok, just to run it over once, we would have variables before we would have comparison, otherwise there would be no point to
the comparison. So freaking ok, umm...yea we would have variability before comparison, otherwise there is no point to the
comparison (there is effectively no comparison). So freaking ok, what is a variable then? Or, what comes before a variable? So
ok, constants would come before variables, so what is a constant? Constants would come before variables because otherwise
everything would be changing. So freaking ok, then we have something solid to work with, a solid foundation to build upon.

So there is no forking in the logic, everything is constant, then what?

Then we like run the whole thing over again and see what we get. So freaking ok, we have like an array...freaking get some
breakfast dude.

Ok man, freaking...ok so if there's no variability, if there's no comparison, everything is constant, so whatever that value
is is constant, so it will be the same when we get there so we can just attach the rest of the thing to it and voila,
extrapolator. So freaking ok, umm...

So like what does this thing come down to? Something constant. It is at least one constant thing. Freaking ok, umm...so then
we like code everything else around, code the peripheral of, that constant. Freaking ok, umm...start coding? Now start coding?
Not yet! Keep hammering on it until you get it all the way down in plain english.

So freaking ok, we would have no variability at the start of this thing, so no need for conditions/etc., so freaking ok, umm,
like then we would introduce variability, and then...ok so like shouldn't we program this thing with constants, since that is
what it comes down to? Freaking umm...like...how do you do that? Freaking a. So like there's no easy way to do this...ok so if
we don't have any variability we effectively have a blank php file, so freaking ok, if there IS variability then we have some
php code, at least. So freaking ok, umm...so like as opposed to sitting here staring at the screen what if you lay some stuff
down?

Ok, so freaking we would have some variables, or not, and if we didn't we might as well not have anything, because...ok I
think you're on to something. If everything is constant is there any point to having any code? ANY point whatsoever? Like is
there a point to having ANYTHING? Even html, any output to the browser whatsoever? So like freaking ok, the only point to any
output would be to account for variability, so like if there's only output...if everything is constant...

Ok so like variability implies two, so at that point we would have stuff like comparison, so...so then we would go ok if one
value is greater than or less than or equal to another value, we do certain stuff. So ok, umm...so like then when would we
check to see if something was less than something else? Or like really man, what you need to do...ok find an inlet, then ley
into it and don't let up.

So freaking ok, we would have like an array and then what? Then we would freaking...so we would run a variable through a
battery...so like we would have a variable, and therefore variability, then we would have something like a fork...so ok you
would have a fork before you would have a function because that way you could have a conditional function, but you wouldn't
have a function and then a fork because there would be no point to doing so, either way you would end up with a condition, no
function.

So ok, we have a variable, so it's value can change. So freaking ok, what if we define a constant off of a $_GET or $_POST
variable? That means the constant is variable at the point at which it is defined, since it is defined as a $_GET or $_POST
variable (which is variable). So freaking ok, umm...so ok like the thing is that fundamentally things are very simple,
"1 || 0" will suffice. So freaking ok, umm...so what is the deal? Do you need something more broad to study or what? Like is
it too simple?

Umm good question.

Ok so lets go with "1 || 0", therefore "1", and let us begin.

So freaking ok, we're going to need like error messages and stuff...or are we? I figure at a log-in we'll need some sort of
error message in case user credentials are wrong, but does that mean we need all-out generalized error messages? So ok either
we drill a hole down from there until we hit our "1" or we go broad and find another place to drill. Like that is what that
is. So freaking ok, umm...or like ok, either way you have to drill down then go broad about how everything relates and stuff,
like you have to go broad until you cover all the bases. So freaking ok, what if we do so until we cover two things...? Does
that work, therefore in such a way that we save time doing this? Is there a way to do that even?

Ok, so if we "preg_match" something, lets say our regular expression is "1" and our subject is "10", we get a match, and then
lets say our subject is "0", we don't get a match, so a match is "1" and no match is "0", therefore we have two things.
Straight up like a legit two things, both different from one another and everything. So freaking ok, there's two things, then
what? Then we have like EXACTLY the same problem: it's too narrow. But, on the bright side, it DOES like go all the way
through there. So freaking ok, umm...so then like we have to go through every little thing, every little possibility, and sort
things into "0" or "1". So freaking ok, umm...so like ok, lets say we have an "if" statement, the condition is either true or
false, to reduce it to two things, so freaking...so it's completely arbitrary, at least at a point. So freaking ok, lets
say...like ok, a number...if a number is less than another number, it is also false relative to that other number. So freaking
ok, umm...how do we know this? Ok so that is what that is, we don't need to know the details at this point in time, so
freaking ok, umm...so ok there is an inkling of consistency in my mind, where if two values are equal we have "true" in terms
of their equality. So freaking ok, umm...what I'm getting at is there is a point there that is rock-solid...at least I think.
Either way it will hold until we get there (true and all). So freaking ok, umm...I'm out for the day.

Ok, so lets get heavy with it. Freaking ok, umm...so we can make something that has two different possibilities that goes all
the way through...so freaking ok, umm...so then what we need to figure out is how these two things become many things, how
this thing "extrapolates" out into a full blown extrapolator. So freaking ok, umm...really I mean there's no difference...so
ok, we need to like build a thing that freaking...like...so like basically what we do is start off with a single point and
then build this thing out of, around, that point. So freaking ok, umm...so like basically we start building. So you can do one
of two things at this point: build the thing out of that point, or freaking keep planning in here. If you build it you are
prone to freaking rebuilding it over and over again, if you plan it out you can just keep on keeping on and freaking sketch
that thing out.

Ok, so lets keep sketching in here. So freaking ok, lets say we start building this thing and we have an error handler. So
freaking ok, this error handler will handle errors all throughout the system, at this point. So freaking ok, then lets say we
build a log-in system, this system would integrate the error handler and display errors on failed log-in attempts: wrong
username or wrong password. So freaking ok, umm...if the thing succeeds it sends the user to a screen that displays the users
and pages of the backend. So freaking ok, umm...now, the question starts to become: how do we generalize all of this stuff so
we don't have to build the same thing, effectively, over and over again. Freaking like ok, umm...so like freaking ok, what we
do is go ok, so...so like we need to generalize the whole thing until we get there. So freaking ok, we would have like a
value, the attempted username, and an input, the actual input that they enter the username in, and then we would have the
process of actually loading and reloading the webpage that actually processes the input. Oh, and we would have a submit button
(minor detail :). So freaking ok, umm...so what we COULD do is...generally come up with these things, so like we would have a
thing that is a webpage, and that would (potentially) handle all of the processing of data and such from the client, then we
would have like a value, could be any old value, and this value could be filtered (in fact would be filtered), and then we
would have inputs (which would/could be linked to values, such that the filtration/etc. was also linked to the input and
whatnot). So freaking ok, umm...the beauty of this is that it lines everything up, in most finite and doable terms. Freaking
like ok, umm...so like then we break everything up into single things (units), so like ok, umm...:

index.php
	process log-in details (if any)
	display log-in
		inputs mapped to values/etc.
			username
				filter
					username filter (e.g. 16 characters long, etc.)
			password
				filter
					password filter (e.g. "strong passwords", etc.)
			submit
...

So freaking ok, umm...so like...:

index.php
	process data
	output

So freaking ok, umm...so we process the freaking data, umm...so ok, we filter the incoming data, this we do for sure, then we
store it, or whatever we're going to do with it...so like ok, lets say we receive some data from the client, and we go ok, so
lets say it's from the log-in form, so like what we do is...we take that data, so we would have (ideally) some $_POST data, so
we take that data and go ok, so we check the username against all of the rows of the database for a match...so first things
first we need a way of expressing this.

So freaking ok, lets say we have a mechanism that will take a single value and do stuff with it: basically it's a conditional
operation against data from the database. The thing is though, it could be anything. So how do we freaking account for
anything? Freaking tiers and tiers of data. Tiers and tiers of controls and stuff. So freaking ok, umm...ok so like
fundamentally what do we have here? Like ok, so we have some values, $_POST variables, and freaking umm...we like freaking...
so we freaking take these values...how do we figure THIS out? Ok so like what if we came up with a simple thing for basically
doing this: we have a thing that links an input to a form variable, so like basically we have a form and an input. So freaking
ok, umm...we freaking...so we define an input, basically, so like ok, this would default to a text input, just like it does in
html, and umm...extraneous detail :)...so freaking ok, umm...so ok just lay it all out, no need for the details.

Ok, so we would have, at least, a connection between the back- and frontend such that the inputs...ok so basically we would
have some inputs, any inputs, even custom ones coded in javascript, and these would communicate, convey, information to the
server. So like freaking ok, umm...freaking ummmmm...or what dude? Freaking ok, umm...so like...this thing would have a
freaking input, so lets say it had a standard, text input. So freaking ok, we take some string in from this thing...ok so like
there is (probably) a reason why everything is translated to string. So freaking ok, umm...so like generally we have inputs,
then we have data processing on the server. So freaking ok, umm...ok so like what if we do this: what if we say ok, so for
every column of every row we have a number (at least 1), and what we do is add these numbers together to create a unique
number that indicates the row and column of the data, then we go ok, so we freaking operate upon this data...so ok like what
we need to do is continue to break the whole thing down until we've broken it into the tiniest little chunks it can be in.

So freaking ok, umm...so we would have like...so ok we would have like tabular data, so lets say we do what we were doing with
this data and add all of the numbers up until we get a unique number representing a column of a row, and freaking...then we
have a programmatic way of dealing with, of referencing, all of our data. So then we would have like a table definition that
would delineate how many columns per row we would have, and freaking then the thing is like completely stretchy.

So freaking ok, umm...what's next? So freaking we have everything we need, inputs, data processing, etc, so like...ok what if
we sketch out some objects:

index.php
	Cinder (object)
		data processing
			input
				filter
					"username"
				store
		output
			form
				input
					filter
						"username"
					storage
						users
							id
								username
				...
...

So like freaking ok, we would have filtration and storage on each of these "values", and like that is it. So freaking ok, umm,
so what this is...ok so just map the thing out, in plain english.

Ok, so we would have a thing that does everything. So let's take a website for example and work it out in this system.
Freaking ok, is it better, is it faster, to do this or to work out the binary? It's FASTER, BIGGER, UP, to work out all the
details of the system than it is to go directly to the (fundamental) binary. So freaking ok, umm...so ok, having some data...
ok WOULD...ok...so like having values implies input. We have the values themselves, but with no inputs there is no way to
directly modify this data, which means no input, just output. So freaking ok, umm...so we would have input, which implies
"form", so ok then we would define the parameters of the form and it's inputs like filtration and storage. This COULD be
anything, though. So freaking ok, then we have output, and that is it. So freaking ok, umm...so the thing is with javascript
input is defined as string sent to the server, as the direct translation of input, so the two are pressed directly up against
one another. Otherwise we have a form and that is that. So freaking ok, umm...so that is the input, then we have the output.
Raw, unbridled data.

Freaking ok, so the output would take data directly from the storage and output it to the screen. The thing is, however, what
if we want something like a naughty word filter on the output? Then we need to take the data from storage, filter it, and
finally output it. So freaking ok, umm...so then we have like a proper object, filtration on the outside, storage in the core.

Freaking ok, umm...ok so lets just take an object of some sort and break it all down:

<?php

class Filter {
	
	public $filters;
	
	public function __construct($filters) {
		
		$this->setFilters($filters);
		
	}
	public function setFilters($filters) {
		
		foreach ($filters as $filter) {
			
			if (!$filter["type"])
				return 0;
			else {
				
				if ($filter["type"] === "function" && !is_callable($filter["filter"]))
					return 0;
				$this->filters[] = $filter;
				
			}
			
		}
		return 1;
		
	}
	
}

?>
...

Ok so like the thing is, all we're going to do is go so broad before we go deep and finally pin-point the point at which all
of this stuff becomes one. So freaking ok, like, so just razor-blade your way through all this stuff and figure out what that
point is, then go from there.

Ok so like the problem is that you don't HAVE anything. Freaking you're sitting here staring at the screen with nothing in
mind as to how this thing MIGHT work. So freaking ok, like, it MIGHT, it just MIGHT, be one thing at the top, then work it's
way down all the way down to the bottom. So freaking ok, what you need to do is program an inkling of what this would be, then
work it all the way up until it's up.

So freaking ok, this thing would have, at least, a form...so then a form would be a part, the input, of a webpage, and that
webpage would be a webpage of a website, and that website would be a website of Cinder, and Cinder would be a project (or
something like an element) of mine. So freaking ok, umm...so AT LEAST what we would have is an element. Freaking then that
element is of a certain type, and that's it! There's only so much to it...ok so that is it WITHIN PHP. So freaking ok, umm...
hmm...so a website is an extension of an element, so what is an element then? An element is a value. So freaking ok, like what
we have...ok so what is a website then? A website would then be something like an extension of an element:

<?php

class Element {
	
	public $value;
	public $success;
	
	public function __construct($value) {
		
		$this->success = $this->setValue($value);
		
	}
	public function setValue($value) {
		
		if ($this->value = $value)
			return 1;
		else
			return 0;
		
	}
	public function getValue() {
		
		return $this->value;
		
	}
	
}

?>
...

So freaking that's all there is to it. That's an element. So we have an element...then what? So then the whole thing is made
out of elements. Then the rest is just a funky dance: forks, functions, loops and so on.

Fucking a.

Ok, umm...that is rather beautiful though. Freaking a. So ok, what if you mimic the structure of an array? Then you have all
of the CODE itself from there up...ok lets try this:

<?php

$array = new Element([
	new Element("Hello world"),
	new Element("Goodbye universe")
]);
$array->getValue()[]

?>
...

Ok so it's like way faster to just use a straight array. The only thing would be when you go to filter the array data...then
we would just use like a Filter class that extended a Value class to set the value of the element...ok so like there would be
no point to having an element class because it takes more syntax than it does to just use a straight value. So freaking ok,
umm...the only point is to like stream-line the form of the thing...ok what if we do this: what if we figure out exactly what
leads to the center of this thing from the top? So we figure out what goes all the way from the top to the bottom?

Or, what if we code an all-inclusive system? So like we have a "1" at the core of the thing, then we have a "0" that can be
turned on or off one step outside of that, then we have everything else...so like the "0" could display error messages and
stuff, umm...so lets do this, lets mock up a CMS and then break it all down until we get there.

Ok, so lets say we would have a log-in screen, we would have some well-structured (in fact precise) html (DOMDocument?), then
we would have some inputs for the username, password, and a button to submit the form. We would also have script/noscript tags
just in case the user didn't have javascript.

So freaking ok, umm...so we would have...

So lets say we had filtered data, then we just get it on the freaking screen and that is it. So freaking ok, umm...then you
need to figure out ALL of this stuff, how to process data, html layout, all of that, to get it (100%) on the screen. So
freaking ok, umm...so like we have two options, code everything up to the filtered data or like sit here and hypothesize. So
like ok, umm...

So ok, what is a filter? A filter is either a regular expression or a chunk of code. The value of a string is checked against
that filter and a 1 or 0 is returned reflecting the success of the filtration.

So ok, IS a filter just a regular expression or a chunk of code? So like in tabular data we can either check rows or columns,
so like we check the column of a row...so when it REALLY comes down to it we check the column of a row, that is one unit of
data. So freaking ok, umm...so what if we want to compare a table value to another table value? We simply specify the row and
column of the unit we want to use and then the row and column of the unit we want to compare against. And then we have to
specify how to compare the two: greater than/less than/etc.? Ok then we have to convert the unit to whatever...ok we don't
have to do this to do any form of comparison between the two, so that is good. So freaking ok, umm...so we straight up compare
the two values and get the succeeding value, the only thing here is that if we check to see if something is LESS than
something else we don't follow logical norms (we're not checking to see whather that value is GREATER than something else). So
this means we can have any boolean for any number. Therefore we need to dig a little deeper to get to the bottom of this.

So is there any comparison/etc. that we can do with two values that results in a boolean that is consistent with everything
else (numbers/etc.)? Ok what if we convert a single value to boolean? Ok like yea then we have a...then we have a freaking
single value, no comparison, which converts to boolean. So freaking ok, umm...

So like freaking ok, umm...so like there are two paths we can take to do this: one we functionalize everything and keep
working it out until we get to the master function, and two we like get fundamental with it and keep chipping away at a value
or something like that until it bottoms out.

I opt for the latter, I think. So freaking ok, if we have a website do we have a value? Not necessarily. So ok, how do we code
the thing to account for no variables? Do we even need php? What if, for some reason, we need to display a "time()" or
whatever on the website? Does that count as a variable? Well of course it does, it accounts for variable time returned by the
"time" function. So freaking ok, umm...so if there is no variability, or rather literally if there is no php to the webpage
then there is no php to the webpage. Freaking a. Ok, so umm...so basically if we have no variability we have no php: there is
no logic to the website. Freaking a. Ok, umm...so what if there IS variability to the website? Basically then we have string
variables representing form data within php. So freaking ok, then we go...:

<?php

$theVariable = $_POST["var"];

?>
...

Ok so the variable is some string, no matter what. So freaking then we just work within the parameters of string and we're
good. Consistent.

Ok so we have some variable string...so then we have variability within our system. Ok, so freaking how do we handle this
correctly? Like umm...we freaking...so like basically there are two, how do we do this, how do we SEE this, as there being
only one? Ok so like the thing is we don't have to account for variability, two things, when there is one. So freaking ok,
umm...

Freaking ok, umm...so like...so there is freaking...so everything we receive on the server is string. All of the data sent by
forms, by javascript, everything is string. Therefore the whole thing is made of one thing, string. And then one thing, any
old thing.

Fuckin' a. Ok, so freaking ok, umm...this is exciting. So it's real tight and hard, how do we do this bad boy from this point
on? Like from this point it's all just translation...if the trend continues it comes to a single point, and therefore we can
use that point to do it (rather rapidly). We just trot to town with our qi, and it all happens. The only thing is how do we
prove that it comes to a point? Ok so we have effectively done this by stacking a function on top of the constant stack which
is php.

So lets hit it.

Freaking a. Ok, umm...so just to chase it down...umm...huh...so like freaking ok, umm...so we have some string...what exactly
is that string? So like ok we can organize that string to a point, TO A POINT, where we can figure out that this is this and
that is that TO A POINT! So freaking ok, umm...then one has to ask: what kind of organization does, can, a string have? Or
what? We like freaking...

Ok so our string arrives from the server and we have to do some stuff. We have to account for variability. So freaking ok,
what this means is...so this means there are two paths any data can take, true and false. So freaking ok, what we need to do
(at some point) is catalog what is true and what is false.

It is worth noting, at this point, that something being less than something else can yield true just like something being
greater than something else, or unequal to, or anything for that matter (any comparison), is true. So truth and falsehood stem
from some deeper principle. We have to, at some point, AT SOME POINT, figure out what that principle is.

Fucking a.

Ok, umm...what if we take the numeric value of anything, of any "thing", and draw the conclusion that whatever that number is
is what that number is? How do we know what 1 and 0 are? We only know what one thing is, and only because then there is no
difference and so on and so forth. So freaking ok, umm...we like freaking...we freaking...ok so basically what we do is build
a battery to compare all these values with, so like we go ok, we take the breadth of something, the breadth of a system, and
relate it to another system and we get a consistent, working system. So freaking ok, if we narrow everything to a single
point, we take that and relate it to another system, lets say another indifferent system, and we get what? Or even if we
relate it to a system of difference we should get a consistent, working system without any extra work. This is because there
is a correlation: where there are two in a system of indifference there are exactly two in a system of difference. So freaking
ok, lets say there's no difference, and then we just relate that to a system where there are, say, two.

So either way there is no difference, so...ok so if it is 1 it is 1, or 0, and if it is 0 it is 1 or 0. Either way there is no
difference. Ok, umm...so what does this mean? What is the breadth of that? What is, basically, the breadth of 1 equalling 1
and 0 equalling 1? So 1 equals 1, we understand that easily. The question is, how does 0 equal 1? At the point at which both
are numbers 0 equals 1. Other than that they have unequal quantities. So does that not answer our question, at LEAST? Can we
not proceed from this point?

Freaking ok, umm...ok so like what we do is arbitrarily assign a number to both indifference and difference, so, let's say, 1
and 0, respectively. So then what we do is build everything up until we get there, or...so we arbitrarily assign a number to
indifference, 1, then we arbitrarily assign a number to difference such that if there is a difference, an arbitrary
difference, we account for that with a different number: 0. Freaking ok, umm...so this makes sense, I think.

Ok so lets say we receive some variable data in php. It is string. So freaking ok, umm...so we need to account for this
variability somehow. So ok there is a plane of string, then, in either direction, there is either html, javascript, or php. So
freaking ok, umm...well ok there is just php. The string itself...no this isn't right. There is either php or javascript. We
have the string on the server, inside of php, then we either directly deal with that string in php or send it to javascript.
So freaking ok, umm...so then either way it is string again, so freaking ok...so then we have string either way, so we have a
single string.

Now what?

Ok so everything converts to boolean in php successfully. There may be values that convert to some low-fi boolean values, but
we're still getting a signal. So freaking ok, then the thought occurs: even if we had to build the thing custom we would still
be getting boolean values through there, so like...

Ok so where do we go from here? So there is a two-pronged fork sticking out of the thing, now what? So there is both a
difference and no difference, so freaking...

Ok so I kind of have the same thought occurring over and over again: what if we analyze the pattern of binary to figure some
stuff out. The binary has certain fidelity to it that correlates to it's 1's and 0's, and their placement, so like what if we
map out the entirety of binary in those terms...this COULD take like 5 minutes:

0
1
10
11
100
101
110
111

So freaking ok, umm...so the further to the left a 1 bit is the higher it's magnitude...and then we count literally just how
many 1's there are...and then like we get the binary itself.

Or what?

Like how do we go about this...or what? Lol. :) So like freaking ok, umm...what we're doing is taking the quantum state of all
possibilities and breaking it down to a single thing, so as to achieve what we're going for. So freaking ok, umm...we're
examining how everything is the same all the way down...or something like that. We're starting from nowhere, which is up, up
or down, and going ok, how do we freaking...that's what that is dude is we have to make the quantum leap from up to down...we
have to go from up to up, so what if we just don't change anything? Or like what?

Ok so like basically you have to broaden your understanding, you have to figure out exactly what is going on in every possible
situation in php, to do what you're trying to do. Like ok, you have to...starting from nowhere, you have to like figure out
how there is no difference, so we have access, and then like...then you have to relate everything...you're just over a half of
the year over, so like don't be disgruntled...yet...there is still time to freaking make it dude. Can you make this bad boy in
a year? Only time will tell. Freaking ok, so like...the thing is this is so freaking flimsy dude. You need something that is
freaking rock-hard. So like ok, umm...

So freaking ok, what is the best way to go about doing this? I would much prefer to freaking wham bam this thing than to take
freaking forever on it. So ok, what is that?

So freaking ok, if this thing...if the php parser is constant, and we have a function, or if hypothetically it is constant,
and we have a function we use more than once inside of it, we have one thing: the function. So freaking ok, how about THAT?
What if it's one thing? Then we sit tight, there's no difference, and we hang on for the ride. So freaking a dude, that's what
that is.

So ok, like if we start programming this thing, what we do is go ok, so freaking we start programming, then everything will
naturally develop if we do it right. So like the way we do that is we go ok, we freaking account for every one thing in the
code and the thing naturally just comes out:

<?php

class Cinder {
	
	public $value;
	
}

?>
...

So like "$value" would be the overall value of Cinder, specifically the master array for all of our data within Cinder. So
what this means is we have to lay out everything that has to do with this array, so like we have to deal with each type, and
freaking...so ok like that value is (hopefully) an array, and that array contains...everything. Every freaking thing.
Literally everything. So like we would have websites in there, projects, odds and ends, and everything else. So the freaking
way we do this is like we make the thing extensible. So freaking what that means is we have...ok so lets say we build a
website with this thing: our Cinder website. So freaking ok, we would have our array, then we would have a project that was
like of a certain type, so like a custom project, and what that would do is...so like then an element of this array would BE a
freaking object. So like this greatly implies that at some point in time we would have to define a custom class to represent
this object. Then, otherwise, we could have straight values...we COULD have straight values, and this is definitely the time
and place to account for them, so like that is what that is. So ok, this array could have associative as well as straight
element keys, so like we could have a phone number that was a number...ok, this is cool, this is hell of cool, but does it
work? Umm...well it WILL work by the time you get there! So freaking ok, umm...so we have a straight array! Even with our
objects we simply have an array. That is good. That is very good. In fact the fact that that value is just plain a value is
like 100% consistent. So freaking ok, umm...so lets start coding this thing and see what we get, maybe we'll just cruise
along until we get there. We WILL freaking get there dude.

Ok, so like this may be better said with words: so freaking ok, what if we have a database where we store all of this data,
all neatly organized and stuff? Does that sound better than like not having any storage for any of the stuff or whatever? Is
this the route, DEFINITELY the route we want to take? Think about it man.

Umm...what if we don't have any storage? Is a full-on mariadb-integrated system the way to go? Or should we go with something
like the filesystem? Freaking umm...so ok lets plan this thing out.

So like we have a fully-integrated freaking snapper. So like ok, what that means is we have a thing that we can snap things in
and out of existence with. Sounds far out, but it's not. We've already proven this with our function.

Freaking ok, umm...so like...what do we do? We like freaking go ok, umm...ok what if we build stuff out of stuff? Like macro
program? Does that get us anywhere? So we build stuff out of big blocks of code, so like ok, umm, then it comes down to one of
two things again. And what is THAT? See like we don't know what that is. We have to figure out what everything IS. Or what?

Ok so this thing does everything, what exactly is THAT? If we have ANY idea of what anything is beyond this point we can move
forward (Some more). We're doing good, now we just need to keep it steady. So freaking ok, umm...so like what are we going to
store on this thing? Phone numbers? What? So like I would like to be able to store anything in here, although I have no
freaking idea what that means in the end. Like I want to store websites and stuff in here, projects, etc., just...what is
THAT?

Ok so lets lay out some data we want to store in here:

Element
	Project
		Cinder
			Project
				Website
					name
						The Cinder website
					description
						The portfolio of Cinder.
					path
						C:\Cinder\drive\sandbox\Cinder\website
					document
						DOMDocument of the website
...

So like freaking ok, umm...so like what if we just have an array, to shorten all the midriff? Smoke one dude. Or like ok man,
this is way more simple than it seems:

Element
	value
		Project
			name
				Cinder
			description
				Project Cinder.
			path
				C:\Cinder\drive\sandbox
			value
				Website
					name
						The Cinder website
					description
						The portfolio of Cinder.
					path
						C:\Cinder\drive\sandbox\Cinder\website
					document
						DOMDocument?
		Project
		...

Ok what if this thing is like all string? Is there an advantage to doing things like that? Freaking like...so here is what I
am thinking: if the thing is string we can have like commands instead of just strings, so like we interpret the command...so
like we could have the following:

"just some ol' plain string"
cmd "Hello world"

So like the first one would just be a string, the second would execute some sort of command...this would work well, we just
still need to store the data somewhere. So freaking ok, umm...

Ok so like fundamentally what we have is an array. Key/value pairs. So we interpret this array with an interpreter...so ok
like then we have array elements, so some of these being objects, that are read out to the browser, somehow. So freaking ok,
what this means is...now what if we want something like templated array data? Do we use objects to do so or what? At least. So
freaking thats what that is in php. Ok, umm...

So like you are so close...so ok a name/value/etc. is a value, so what we have is a bonified array. Mmk. So then we like read
this array...or do we? I'm outty for the night dude.

So freaking ok, if this thing is an array full of objects and whatever else, just freaking whatever else, then what? Then like
the constructors for all of the objects fire and everything and everything comes out, just does this make sense?

Element
	Project
		name
			Cinder
		description
			The Cinder project.
		path
			C:\Cinder
		an_object
			new CustomObject();
...

So like it freaking works...ok detail it some more, what sort of data do you want in this thing?:

<?php

$array = [
	"Eric Phone" => "***",
	"Projects" => [
		[
			"name" => "Cinder",
			"description" => "The Cinder project.",
			"path" => "C:\Cinder"
			"website" => "http://cinderproject.000webhostapp.com",
			"sandbox" => "C:\Cinder\drive\"
		]
	]
];

?>
...

So like ok, maybe it would be good to hammer out some of the details of how you would like your data laid out? So freaking ok,
I want it to handle any data, so so far an array seems to be a good fit. Now, umm...so like if we are missing data or
something we can always add it, therefore, so like even just a rough sketch is good enough. Exactly what I wanted dude. So
freaking ok, umm...start sketching? So like ok, what if we wedge eric's site in there...:

Element
	Element
	Element
...

So like ok, you have this thing somewhat figured out! If all we have are elements, we're freaking good! Then we just use a
single element and we're good. So freaking ok, then we have a single value, and that's what that is...so like the thing should
just naturally flow from there, shall we try coding this thing a little or what?

Ok so I'm drawing a blank. Lets go off the top again.

So ok, we have something like an array, we HYPOTHETICALLY have multiples, so we need something like an array, and you figure
that that works because it is sequential, so like constructors and everything will fire in order, so like then we have an
array element, and what is THAT?

So like that is like primarily an object, because objects have methods, so like other than that the data is like inert or
whatever, it doesn't move, it doesn't do anything, so like in order to DO something with the data we need something like an
object (in terms of values).

So we have a freaking object, or an element...ok if we have any data, what do we do/how do we do stuff with it? So we would
need like a function or something, which IS another thing, so what we're looking for, what that is, is an object.

Beautiful.

Then what? So we have an object...so like the question becomes: what is the ideal object? So it's like a freaking...ok so it
has properties and methods, and then like...so it has a method, it's constructor, which has no return, so like...everything
has to happen within that constructor, so like that is what that is. Freaking ok, umm...

Ok, umm...so like what is the full extent of this object? It's like literally anything. The only thing I can think this thing
can't do is access variables in the main scope, unless they are globalized within whatever method of the object we are talking
about. So freaking ok, umm...

So the question is like what does this object do? It freaking filters, categorizes and stores all data, so that is a thing. So
like we would have a value, and that value would have a filter, and freaking...then we have filtered data. Then we store that
data and we're good. So freaking ok, umm...so like would it just be an all-out value or what? At least. It's at least just a
value. So freaking ok, umm...so like this object has a value...and that value is filtered...yea so it's at least what we
already have, so its filtered and stored values, input and output. And like that's it. So freaking ok, umm...lets say we have
a value, a filtered string, a username, and that username has to be between 4 and 16 characters long, and so on and so forth,
so like we store this value...then we have to wonder: where do we store the value? Like ok this would be a little wierd, we
would have an all-out mariadb table that would store array elements and stuff, or values, more accurately, so like ok, umm...
so ok, we would just have an array, then we would make sense of everything from that point on. So then what do we have? A
collection of data, numbers, strings, objects, that ultimately do all of the input/output/etc. of the script. So like ok,
umm...so we would have...would we have anything but objects? What if we just had some data, no objects? Nothing would happen.
We would effectively just have the syntax, the data itself. So ok to get beyond that point we have to DO stuff with that data,
so what is that? Shortly it's an object because objects bundle all of this stuff together into one coherent unit.

So we have an object. What kind of object do we have? What do we do with it? The beauty in this is it reduces everything to
the breadth of an object, so like we could, at that point, have several mariadb tables and whatnot all working in unison
within that object, there is no need to clump everything together into one big mess of a table.

Ok, so what is the ideal way to run an object? Or what is an ideal object? It should account for any kind of database table,
any kind of data, so on and so forth.

Ok so like an all-encapsulating object would have all of it's data inside of itself, along with all of it's methods for
dealing with that data. So freaking ok, AT LEAST what we have is an object with some data and some methods for dealing with
that data. So freaking ok, then what? So like the structure would be the same for the innards of the object, there would be
only one variable for the data to be assigned to, and there would be one method. So like we achieve this, at least in terms of
the method, by having a constructor method. Also we only have one object, which is also what we want. Yea. So freaking ok,
umm...we're getting closer though, dude. Freaking ok man, so like we would have an array as a property of the object, then a
constructor function. So freaking ok, start building?

So like what is in this array property? Everything. Filtered values. Ok, so we need to filter values of the array...should we
have an array or do we need some other sort of structure when it comes to storing the data? Like ok, on a single page-call we
have like...ok so we either add, edit, or delete data, so if we add data we have the new data itself, and we add it to the
database and that is it. Ok so we filter it then add it to the database. So then ok, umm...then what if we have some kind of
custom process where when we add the thing we do something with it, before or after? So that is a thing, like, hooks...
everything has to be custom, just how do we DO that? Ok so like basically what we do is start from the fundamental end and
build everything up from there until the thing fits perfectly into php itself. So like ok, if we want to add a value or
something we have to account for that, we have to account for DOING that, and everything else having to do with it. So
freaking ok, umm...so at some point what we have is like a factory where we manufacture objects. This way we can completely
control the structure of the object and everything.

So freaking ok, then one has to ask oneself: what is it to DO something with an object? Or like of all the quantum
possibilities of objects, how do we do this? So like we can add properties and methods, and like that is it! Freaking ok, umm,
we're going to have to go a layer deep to manufacture these things, as well. Then what we do is go ok, so we have a thing that
programs the things, and what that does is directly take orders from the user and then press out the objects. So freaking then
ok, we can either do that or hand-code these objects. There is like no point to not hand-coding these things...what if, just
what IF you want to machine these out for some reason, with a layer of code? Why would you do that? I'm out for the day, we'll
hammer on this tomorrow. Straight up slap-bass. :)

Ok man, umm...so like we have an object, hypothetically (at least), so ok then what? Then we do everything an object can do...
with a few exceptions? Like ok for our purposes our object needs a constructor, and a public one, such that the constructor is
called when the object is created. This is because that is what is in our design specifications: we have to have a thing that
handles multiples, and does stuff with the data (displays it, formatted and all, on the screen, so on and so forth). So like
freaking ok, umm...

So we have, at least, an object, so that we don't end up with like lost data (or data just sitting there), and so we therefore
do something with that data. I think. Yea that's right, that's what we want. So that's what we do. So freaking ok, umm...so
like lets say we have an object...

Ok so in our CMS we would have an object, Cinder, that would like not store any data! There would be like no reason to
actually store this data as a property of the object. There would also like not be any reason to store maria information
either. So like there would be no reason to store any data. Freaking ok, umm...so ok the thing would fire up via it's
constructor, then it would check to see if it was installed, and if it was it would proceed to run, and if it wasn't it would
install, where it would gather maria information and then save this information to a php file upon success. So then beyond
that point...so then it is "installed" and it can continue to run like normal. So freaking ok, then there is a fork between
front- and backend and like...or something...ok so we would have the frontend, then the backend. So like ok, umm...or do we
want to dig deeper into this thing?

So ok, we would have like clients and stuff, under Cinder, and then before that we would have like the great blue sky. So ok,
umm...so we would have an object, either way, so then we have to define that object. Would that object be "Cinder"? Umm...dude
this is freaking HOT. This would make for some hot sex.

Ok so what we want is an all-inclusive system, so do we call that Cinder or what? We call that whatever we call that, is, at
least, what that is. So freaking ok, umm...so ok, what does this system do? It freaking categorizes, organizes, all
information, or at least all information having anything to do with Cinder as a company. Freaking a. Ok, umm...so AT LEAST
what this thing does is organize clients and client information, with a capacity to handle stuff like side-projects and stuff
(lets say you wanted to develop an operating system, it could handle that, fully integrated and everything). Freaking ok, so
lets say we come up with something wierd, like some string:

Hello world

How would we "integrate" this into this system? It would have a database or something like that, some sort of storage, where
we could store that data. So then we have to figure out how to store all of this data. So freaking ok, php can handle as much
storage as indicated in the php.ini file (under "memory_limit"), which defaults to 128 megabytes. So freaking ok, umm...so
like this is going to be way too much to allocate for each row in mariadb, so like that is out of the question. Freaking ok,
umm, so like we need to break everything up...

Ok, so we have "Cinder", and what this does, at least, is it's a CMS...freaking do this well dude and you are on your way, do
it spot on and you are a fucking legend. Right on the tack dude.

Ok so it's a CMS, so (at least) what this thing will be doing is installing, as outlined earlier, oh yea also when it installs
it needs to create a user account...so like we do that, then when it's all installed its "installed", so it runs (at that
point in the fork), and what it does is it displays the "pages" webpage, or the integrated admin view on the frontend of the
site. Seems simple enough. Ok, so at this point if we integrate the view into the frontend we have to design the view, so like
this is going to be quite the hurdle. We have to integrate rich-text editors and whatnot directly into the view. This isn't
going to be hard, but it IS going to take some time. So like that might not be a route you want to take. Freaking ok, umm...so
like what is the happy medium? Or like ok, so we load the thing, front- or backend, and freaking the thing checks to see
whather it is installed or not...ok like what if we build a system that puts all this stuff together? Like that is what we
want. So freaking ok:

input
	any form of input, html inputs (noscript), javascript input, so on and so forth.
		anything that results in a string, so literally anything, unilaterally
filtration
	any form of filtration
		particularly string-based filtration, so specifically regular expression?
storage
	completely independent from the rest of the system
		mariadb?
output
	all output
		data stored to files
		directly to browser
		etc.

Freaking ok, umm...so we start with output, input or output, so like...so basically we have to output the input controls
before we input, so that is what, or like everything, all of the php code, is the input of php, then the output of php, based
on that input, is the output, so then we alternate again, so the input controls would be, simply, embedded in that output, or
would BE that output. Freaking ok, yea, that's what that is. Or what? We have constant input, so like we could use a get
string to input without any output. Fucking a. Ok yea that makes sense...umm...freaking...ok the thing is you, at least, need
output before input because you have to output the input controls before you input...or like we have to output an input before
we have an input...or like sheeit...or like ok, in basic logic, even if we input with a get string, we need some code on the
server to do stuff with that input, otherwise it is like basically lost. So, fundamentally, that is what happens. Or ok, so
what if we have input but we don't "do" anything with it? Like what if we have get variables with an empty php file? It
exists. So ok we "have" input, which is definitely good. So then what about output? Then, hypothetically, there is no
difference, so the input is also the output. Ok, so what are we going for at this point?

Ok, what if we...what if we have a static system for handling errors, such that when there is an error a toggle is switched...
ok so then we just check something like the count of the errors...then we just generate an error (or not), and like...that is
what that is. It's the same as having a toggle set. The only thing then is that you can't succeed while you still have errors,
so you want the toggle. THAT is what that is. That is the turning point for you, because then you need to fill in ALL of the
cracks...

Ok so there is no difference, then we have a toggle that toggles a zero-state of the thing, so we can switch from "1" to "0"
and back again, so then we successfully have a 1 or a 0, or a fork, which is good. Then one has to wonder, why not have like
a three, a four way fork? So like yea, we're going to do that too, just fundamentally we have a two way fork (basically
because it's efficient). So freaking ok, umm...so then like we would have one fork per variable...and one loop per fork, and
one of everything per one variable (value), so like ok umm...

So we have a freaking thing...we have a thingy. :) So like ok what is this thing? So like ok, we have everything translating
to boolean (at all), but we need to figure out exactly what something is in terms of boolean.

So a boolean is given, true is true and false is false.

Numbers...numbers...what are numbers in terms of true and false? So numbers are bipolar, so I figure that negative numbers are
false and positive numbers are true. If I'm wrong we can fix this in the future.

String. An empty string is false, otherwise is true.

Arrays. An array is an array, and not it's elements, and therefore one thing, which is therefore true (or false, just has to
be one thing: consider the syntax).

Everything else is the same as an array.

Ok, now what? How do we bottleneck all of the logic, in fact therefore all logic, in one fell swoop? Obviously not an easy
feat, but hypothetically it is possible...

Ok so like first to figure this out you need to know what bottlenecking logic IS. So bottlenecking logic is when a single
value occurs at a point, so for example a bottleneck would be the fact that all arrays are considered true, since they are one
thing (by your previous logic): we wouldn't go into it's elements to determine whether it was true or not because it is
already true at the point it is just an array! That point is the "bottleneck" of all of the logic.

So ok, the way that we get it down to there being no difference is we just program a thing that unifies everything, so a core-
class that all other classes extend, or something along those lines, and there is therefore no difference.

Ok, so the playing field is leveled and everything, now how do we program this bad boy? We have the thing mapped out, end to
end, now we just need to build it.

So freaking ok...umm...what that is is...

Ok, so I'm thinking like, ok what if we work our way down through all the logic of automation until we get there? Like we
clump this and that until we hit rock-bottom? So like we would go something like ok, if we have files we generally handle them
in such and such a way, and so on and so forth, until we max the thing out? Then, the closer the better (which is also what we
want, definitely a good thing) and if we ever get there well hallelujah. Hajejujah.

Umm yea let's do it.

Ok, so generally speaking this thing is going to have to handle files and stuff, so like I guess just pick something and get
started. So lets go with files.

Ok, so when we handle files we need certain filenames and stuff, and we have to deal with files on a per-mime-type basis, and
like sometimes, for instance, we will need to do stuff like crop images and stuff, which are files, so that is a thing as
well. So freaking ok, umm...so then like I'm thinking, wouldn't this just be php itself, at some point? If we fill the thing
in entirely is that php itself? Ok so if you go up, it's php, it's the breadth of the current working thing (we're still
inside of php), if you go down, it's not, it's something more generalized. So freaking ok, umm...

Ok, so you freaking have a thing that loads a file, a file class, and you need to define some stuff about this (with a wrapper
class ("Cinder")): the point is to "soften" the way php handles files and all things, so this, as an example, needs to take
it's configuration from Cinder, so like what we do is go ok...freaking this is awesome dude...so like the class would be
configurable independent of Cinder, and then Cinder would extend it, and freaking ok, umm...so we would have a single line of
inheritance, so freaking ok...umm...

So we "soften" php, or what? What do we soften? The functionality of the thing. So we need to figure out what it does...so if
generally you want it to do everything you have a master method...like really it seems like the thing doesn't have to be that
complex, it just has to work. So like, umm...so whether it stores files or not, so on and so forth, it just needs to work. If
nothing else, this is freaking super interesting. Ok so how soft does something need to be? Completely soft...ok so what we do
is we have some core functionality, and that needs to be soft, so lets get to it:

filtration
	error message(s) on failure
		regular expression
		code
storage
input
output
...

Ok so the thing is everything is going to be like integrated, like freaking woven together, so we have to COMPLETELY seperate
each component from the others so the process is as efficient as possible. So freaking ok, umm...so what if we use, or rather
emphasize, the constant or static component of our system when we do this:

input
	filtration
		storage
output

So we don't filter anything until we've received input...what if we want to filter output as well? Like what if we need to
filter naughty words out of output and stuff (that are otherwise in the data in the storage!)? So yea the order would remain
the same:

input
filtration
storage
output

because we would filter the data before we output it, so then we would have storage AFTER filtration because we would filter
input before we stored it, so then we would have...so then the question is: storage before output or output before storage?
Output would come after storage because we would have to...:

input
	comes before filtration explicitly because filtration has to fire on the input's "onchange" event
		or when something is submitted (sent) to the server
			this explicitly comes after the input, ltr ("input.onchange")
filtration
	comes before storage because we want to filter our input before we store it
storage
	comes before output because we have to read the storage before we output it
output

So freaking ok, that is what that is. So now ok, umm...so ok, now what we have to do, at least, is translate everything to
string for storage, so like what this means is like getting to the heart of everything. So freaking ok, umm...so then what
happens is we have a layer where we have string, then we have stuff like numbers and booleans (that that string might
represent) so we have to resolve all of that logic. So freaking ok, umm...yea that IS what that is...we have to resolve all of
the types we can have so our values are accurate. So freaking ok...so we have to have two things when we store any value: it's
type and it's stringified value. So freaking ok, umm...so then we take that string and convert it to that type, and that's
what we get...:

boolean
integer
double
string
array
object
resource
resource (closed)
NULL
unknown type

Ok so like how are we going to store objects? And arrays?

...ok so like are we even going to transmit anything but string? I mean literally string, not even like stringified numbers
and stuff? And what is the end of the line of THAT? Ok so everything is one thing, which at a point means everything is
string, which at a point means it's the users' responsibility to translate string to numbers/etc. So freaking ok, there's our
storage, simple ass storage, just stores strings. So freaking ok, umm...then we filter our strings with...regular
expression...yea this is making a lot of sense. So we like delegate the responsibility of further filtration further down the
line (we "soften" it). So freaking ok, if this thing were completely soft, what would be going on?

We would have like some syntax that defined the structure of an array...ok so first things first we would define our inputs.
So like radio buttons/etc., we do that first, then we go from there. Mmk, umm...so the filtration/etc. would "depend" on the
inputs, and then the inputs would depend on...what? They would depend on like the requirements of the site. Yea the thing is
that stuff is all chopped up, so like the whole site would be like scribbled on paper basically before it gets produced. So
freaking ok, umm...no it wouldn't dude! At SOME point it would all come to a point and be one thing. So what is that one
thing?

In order to figure that out we have to figure out like what this thing is made of. So it can handle anything, so any CODE, so
that defines the perimeter of the thing. Now it's your job to dig into the thing and figure out it's inner workings.

Mmk, umm...so lets just walk it back from the point that it is an array with structural definition and stuff, so like what
that does is define...ok so the whole thing is "soft"...so ok like how would this thing work, softly, off the top?

Ok, so the thing would shoot off, and what it would do is...AT LEAST what it would do is create a website, so like it would
just come up with something out of thin air, then it might ask you for some details about the site (it's name, description,
etc.). So freaking ok, umm...so like lets say we had a one-dimensional array with some data and we display that array in the
browser. So we pretty much just print_r the array inside some pre tags and we're done. What I'm getting at is ultimately we
have to display that data correctly, we have to work out everything from the back- to the frontend until the whole thing is
"softened".

So like ok, umm...so like we have a thing where we can input some data and it saves it to an array. Ok like this isn't the way
to go about this. The way we should do this is hypothetically test-run the thing and map it all out from there.

So lets say we fire the thing up, and we put some data in there that defines like the webpages of the website and stuff. So
every one thing: webpages, websites and stuff. So like ok, we would have to, at some point, define what a website is, just
like we would have to define what a webpage and everything else is. So like ok, umm...so a website has a title, a name, a
description, which are all string...ok so lets proceed under the assumption that all of this is string, and we'll correct
ourselves whenever we run into otherwise. So freaking ok, umm...so then a website, and everything for that matter, would be a
collection of strings. So an array of strings. So ok, then we have to like define where all of these strings go and stuff, so
like then you have to wonder how you aren't going to go one more step and just hand-code the site? Well, umm...ok so anyways
that's a value. So freaking ok, umm...so like ok, in order to dynamically generate some html you have to know the rules of
html (to generalize them), therefore in order to dynamically generate anything you have to know the rules of anything to
generalize them. Freaking a. So like ok, if we come up with a rough sketch we should be able to work something out, something
that comes at least closer to our goal.

So like what we do is go ok, umm...so we generalize the input of the website, so like we define radio's and stuff that...ok
what is the point, closer is better, where all of this stuff starts? We generalize input, then what? Is that the start of it?
In terms of a website that is what comes first...ok so like if you proceed under the hypothesis that input comes first
because you have to update your output with your input before you display it you will get somewhere, and that is further than
here!

Ok, so we generalize the input...so we have a thing that defines, let's say, a radio button: the different settings of the
radio button are defined and the radio button is born. So freaking ok, umm...now how do we define what a radio button goes to?
What comes before it? So we define that too, so ok like we would define a form...or we COULD define a form that this radio
button goes to, and then we define another element that this form is inside of. Then we have a webpage, and ultimately we have
a website. Then we have Cinder, and then projects, and then our root. So like the question to ask yourself is do you want
Cinder to be your root? I kind of don't, just because it isn't that pure. What's pure is treating that as a single point, not
a name or some broader idea or anything like that. But I mean I dunno, if your system really works you can just fly with it
and fix it later if it breaks.

Cinder it is.

So freaking ok, we have "Cinder", and then we have projects...or do we not want to...ok umm...so then we have projects and all
that kind of stuff. So freaking ok, umm...so then we have anything, literally anything. So freaking ok, umm...so like the
simplest route to take to do this is to use one thing, so like one type of xml node called "value" or something, to do
everything. Then we just get soft with it:

Value
	Cinder
	Value
		Website
	Value
		Clients
			Value
				ECJKD
				Value
					website
			Value
				Couchboys
				Value
					website
...

Or like we would simply have a value, and that value could be an array...so then all of the elements of that array have to be
arrays as well, so then we have to use a single value that is a single value (1!). So freaking ok, umm...so the problem is
that there is more than one thing. That is the root of the problem. Freaking a. So how does coding a "soft" system solve this
problem? Fucking a. Ok the thing is, however, that if you do that you create a single thing that is a REALLY BIG one thing, so
it's still one thing, it's just really big. Ok so you still need to figure out what a single one of these is, something better
than an array, lol. :) Freaking a. So at the point at which the server communicates data with the database/browser/etc. it's
string. So we'll use string until we get THERE.

Ok, so we have some string...or like ok, lets say we have arrays and strings as values, so lets say we have an array of
strings, so freaking umm...what if we represent the whole thing with string, so that like the whole thing is one single thing?
Or like at some point you have to represent everything with one thing, and string is a good candidate. Fucking a. Ok, let's do
that. So we have a string...then we have an interpretation of this string, so...so then that is what that IS. String. 

Ok, so now we soften everything? Now we like interpret this string. So then all the weight falls on interpretation of this
string: you have to convert numbers, booleans, everything from string. You even have to figure out how to consistently convert
resources and whatnot to string! Consistently! Fuckin a! Ok, what if we deliberately convert everything to something like
string just to simplify what we are doing?

Ok what if we just keep marching and go ok, so we figure this thing out for a webpage, then a website, then so on and so
forth? Makes sense. Starts directly on the ground.

Yea lets do it, I'm otherwise drawing way too many blanks.

Ok so we have a freaking webpage, and what this is is...either a string or basically multiple strings. So like ok, umm...so
like if we have some data:

Cinder
	portfolio
		array
			Konig Media
			Waking Ashland
			...
	contact
		string

So like basically what we are building is a php framework. Fucking a. Ok so like what we are going to do is both use existing
frameworks and create our own, so on with the program.

Fucking a.

Ok, umm...so ok we have a thing that creates something like a radio button. What we do is define the various settings of the
radio button, then define a default for the radio button, then we press out the radio button. So like ok, umm...ok so like the
thing to remember at this point is this stuff is extremely fundamental, so if it seems to go off the freaking richter it is!
Just fight back with fundamental force and get it to go the other way. Don't give up hope dude, don't give up at all.

And get to the bottom of that.

So ok, this thing builds a radio button. Simple enough. You can work out all of the details as far as the code is concerned.
What about the rest of it? Where does it go from there? You basically have to like spelunk the thing with a string to lay down
a guide for someone else.

Freaking ok, umm...so we create a radio button, then we create all the rest of our inputs, and then we like have a webpage.
Then we have other webpages, which comprise a website. Then we have websites, which comprise a website company. Then we have a
project. Then we have projects. Then we have something called "Project". And that's the end of it! I don't know of the rabbit
hole going any deeper than that.

So freaking ok, umm...

Ok so I was thinking last night and I thought: lets say we created a radio button and we wanted to assign different types of
values to it's settings. We would need to account for, say, numeric and string types for these settings all the way at the top
to correctly work it down. So like to do that we need something like the following:

Cinder
	create radio button
		options
			one
				default
			two
			three

Where...ok so we are inside of php, so like everything beyond that point is code, php code, so like umm...so ok we like don't
even have to figure out what anything is...until...we get to the point that we actually define stuff. So like umm...NOW code
the thing? Umm yea I think the answer is actually yes to that question. Lol! :) Ok well I'm going to go for it and see what I
get.

Ok so like I'm sitting here staring at the screen. So at the top we need to account for all types, so we do that, then we have
like a fork that forks to websites and webpages, and projects and what have you, so like...so then it should just all fall
into place. Code it dude.

Ok freaking I totally want to make sure this thing works before I start coding it. I don't want to end up with a freaking heap
of code that I trash, so like...or what? Freaking like hell dude, there's like nothing to do but code it...so ok, how are we
going to account for various types...or like ok, so what I'm thinking is this thing needs to be completely extensible, so
like...umm...so like what I want, or what I need, is a thing that can handle flexibility at its root, so that if in the future
I come up with new classes and stuff that I want at or near the root of the thing it still works, so like...I guess just fit
it all to php and go from there? It SHOULD, you would THINK that it would be a stack of core classes that handle like storage
and everything and then everything on top of that, but I mean I dunno...will that work?

Ok so this thing needs to handle everything, so if it can handle every type in php that's "everything". Freaking umm...so then
from that point on we need something that...so lets say we want something called a "project", and what that is is a collection
of values, so an array, and then we have our values and it's good. Like so far so good. So freaking ok, umm...what if we want
to do stuff with these values? So like we would have...so like that would be some code. Or JUST about:

Cinder (object)
	"project" (?)
		name (string)
			"Website"
		description (string)
			"The 2021 Cinder website."
		projects (array)
			project
...

Ok so then we have a value, so then we have to generalize everything from that point on. So like ok, umm...I think the
quickest way to do that is to go straight for custom work, so like what would we do in those terms? What would custom work be?
Raw code? So it's definitely code, so what if we work with it in those terms? So like we need a structure that is lends itself
very easily to extension. So like umm...so like basically what we need is a rock-solid foundation to work upon...if we code
everything we're like good...so we code an error-handling system, a zero-switch and a constant 1, and so on and so forth, and
then everything else "sits" on top of that. I mean it makes good sense...then you could extend everything, core changes could
be made as updates to Cinder itself, and then custom classes extending it could be added to the Cinder class itself, so
freaking umm...so like what we need to do is bump the whole thing up and create an object coder, a thing that generalizes the
process of creating objects. Fucking a.

Ok, umm...ok so lets get our hands dirty and code this thing. It's all broken up into bits so this should be a relatively
painless, efficient process.

So ok, I'm coding and I'm thinking what if this thing doesn't go far enough? What if somehow we come up short? Like I'm
thinking we SHOULD be able to come up with a solid plan before we do this so we KNOW it's going to work before we potentially
go off on an inefficient path and waste a bunch of time. So like freaking ok, what if we revisit our system and see what we
get?

So like we would have a system that was a single thing, so far an object, and it would read some data from someplace. So like
this data can be anything, numbers, strings, anything, and then...ok so we're (technically) inside of php, so like we have to
calculate x and y in terms of php, so number, string, any type php can handle. Otherwise what we would have is any old type,
so like even made-up types...so freaking ok, we need to define the line between php-centrism and everything else. So freaking
ok, basically that line is just wherever it happens to be when we get to that point, we have to define the territory before we
start drawing lines, the topography before we go so high.

So freaking ok umm what we want is a system that can handle anything, so like XML, MariaDB, anything. So freaking what this
means, at that point, is string. So like ok, umm...so what kind of data do we want to store with this thing? String? Numbers?
Draw up some data and lots see what we get.

Ok, so like we need something that is completely extensible, so something that can handle freaking anything, so like something
that can handle stuff being assigned and stuff...:

Cinder
	Custom (template)
		name
			string
		description
			string
		email
			string

So freaking ok, umm...like ok, so we need a single thing that: can have a type and a filter applied to it, so like...umm...so
like we need to figure some stuff out or something...if we have a type that is something like a resource, is that what we
want, or...ok they all need to be the same thing. So freaking ok, umm...we have to translate...get into this heavy tomorrow or
what? Work on it tonight? Take the freaking night off man, you've been going at it since freaking early this morning...ok I'm
out.

Ok man, freaking code this bad boy!

Ok dude, lets figure out if this thing is actually going to work or not. So freaking ok, umm...so all of the connective tissue
is effectively there, it all translates correctly, and everything is accounted for...so how would this thing work? So like we
would give it some syntax and it would spit something out, so like we would specify some array structure and then insert some
rows into the thing and it would spit it back out...:

Cinder (object)
	contacts (array)
		contact (array)
			name (array)
				first (string)
				middle (string)
				last (string)
			address (array)
				street (string)
			phone (array)
				type (string)
				number (string)
...

So like ok, we need to figure out how all of our data cooks down, so we're not picking through an example trying to figure
that out (it's faster to just go straight at it than it is to dissect an example). So freaking ok, umm...or like what dude?
What exactly are you going to do?...Umm...ok so we code our data, then we code our interpretation of that data, so like...so
we freaking code? Umm...so like we would have a value, and that value could be an array, and then that arrays' elements are
other values, so like we need to code a value...

Ok, so lets say we have some inputs, those inputs send their values to the server, and the server interprets these as such and
such types. Then, it assimilates that data, so it filters it, stores it, and displays it to the browser again (pretty much).
So like...ok so like there is nothing left to do but code this thing. The only thing I can think of is we come up with a more
fundamental solution to our problem and don't even do any coding at all! Or like ok...

So if we figure this out we can figure out whether this thing is actually going to work or not (not just get there and recode
the whole damned thing again), so like ok, lets say we receive some data...:

index.php
	input
		POST
			"name" (string)
				"Brent Edward Bevans"
			"age" (integer)
				37
...

Ok so like for every single one thing we would do everything, so every value (every POST variable, in the above example) we
would filter, store, so on and so forth. So freaking ok, so we have our input, the actual POST data itself, then we have
filtration, which, at this point, simply limits "name" to a string and "age" to an integer. So freaking ok, umm...then we have
storage, where we actually store our data, so it is like important to note here that every step of the way we have to go
through our entire array, all over again, so like that's something that we'll have to figure out, something that we'll have to
reduce to one thing, at some point. So freaking anyways, then we store the data, then we do output, where we summon forth the
applicable data and display it on the screen.

So ok, lets say we visit the site, so what happens is at this point there is (probably) no input, so what we do is just read
the applicable data from storage to the browser.

Ok so like we have...what do we have? Freaking umm...so what this thing does is...basically comes up with an array...so like
it doesn't come up with an array, it comes up with a value, though that value CAN be an array...freaking a...

Ok man...freaking code the thing or plan it?

Ok, if you plan this thing out you have to go step by step, but I mean because it's in pseudo it might be faster than actually
coding it, so like...

Ok, so lets say we output the site to the browser. Simple enough. So like to do this we would need some syntax and stuff, like
we would need to prepare the html and js and css and whatnot for display, so that is a thing, and then like...so like we would
need html elements, and these like need to be integrated into the thing...:

index.php
	html
		body
			form
				input (radio)
					one
					two
					three
					...

Such that the input needs to be linked to the form, and the form to php, so like...ok so the form is linked to the php by it's
"action" attribute, and the input is linked to the form by being inside of the form (or otherwise, like for instance if it is
ajax). So freaking then we send the form to the server, and what happens is Cinder assimilates the input...so ok, it would
need a way to identify what form the input came from, and like...then it would, for instance, need to reload the form with the
form inputs set to the input data, such that it "saved" the form data. So freaking ok, umm...so like then, also, we figure
that we need stuff like input labels and whatnot, so we have two things: a form element and input elements. Now, if the input
elements can't "contain" other stuff, elements and text nodes and whatnot, then we have to account for still adding labels and
stuff to these inputs, so like maybe a table with labels to the left and inputs to the right or something, but whatever it is
it needs to handle custom layouts, so like...so we have a fork where we have either straight string html so we can define
completely custom layouts or templated things where we might have, for example, radio buttons to the left and labels to the
right, all seperated by "br" tags. Something like that. So freaking ok, that defines the forking at that point, so then once
this is done we have a form laid out in the browser. That's dope.

Ok, so then we send the data to the server, and the data maps the input to it's internal structure, filters and stores the
data, and then outputs to the browser again.

Ok, so lets run it down piece by piece until we get this thing all laid out.

So freaking ok, first Cinder would assimilate input. So it would have GET/POST/etc. variables that it would read, and those
would be mapped to "types", and...then it would...:

Cinder
	input
		radio
			"one"
			"two"
			"three"
			...
...

So we would have to define an input...so freaking all the way up the chain we define an input:

Cinder
	input
		radio
		text
		...
	output
...

Ok so like lets say we had our data, which is a mariadb table, and that data is formatted with columns, so in one row we have
columns and like that is it. So what we do is go ok, we can template those columns (a straight table) and we can add columns
to specific rows, so we end up with completely flexible rows. Freaking a. Then we have complete control over our rows...then
we can have templated and non-templated data, fork accomplished.

Ok, so we have forked data, then what? Then we like...ok then we have completely flexible data on our database. Fucking a. Ok
so then what if you have a table and then you have a "sub-template" within that table that defines a few more or less columns
on it's rows? And then what if we have a custom column on one of those rows?

Ok so either way the row would have columns, so the columns remain (which means the table and everything before it remains)...
so then you just have to figure out the row.

So ok differentiation between one or more rows means more code, which is bad (greater size), so we use the database whether we
have one or more rows.

So freaking ok, umm...then we have to hook our database up to our output, so freaking...ok so like primarily we have to define
our output (our output IS at the end of the line!).

So freaking ok, our output...so like our output defines our input controls and stuff, so like...so what if we want to link
output to input? So like if we want to link our columns to our inputs? So then we...so ok we would have our database, then we
would connect everything to the output, so we would need to identify stuff like links between the database and the input
controls, so like...ok so everything would be string at the database interface, so everything WOULD be string, all throughout.
So freaking ok, what this means is that whatever we have at the top is string, so like we are outputting straight php code and
html and stuff, therefore.

Ok, so lets say we define our table structure, what we do is define filters for each of the columns...:

Cinder
	Portfolio
		Clients
			name
				definition
					VARCHAR
						255
				filters
					filter
						regular expression
							/[a-zA-Z0-9]*/
						onfailure
							'The "name" of this client must...'
			description
			screenshots
	Contact
...

So like ok, umm...ok so like at the top we would define inputs...so then like how do we define an input? We either line them
up with columns or arbitrarily create them, so...so what we would have is a function that accepts like some parameters for how
it should work...so like we would give it the filter for the thing, as well as like...

Ok so there would be freaking...we would like define inputs, and then tailor the data to the database, so like...isn't that
all just one big custom thing? No, it isn't. At some point it's a completely generalizable thing, so like umm...so we would
have our basic inputs, radio, text, so on and so forth, and we would constrain our data to that definition, so like umm...so
lets say we had a radio button, we would go ok the data in the database can only be one of the settings of the radio button,
so freaking umm...like there would be the settings of the radio button, then there would be the fact that you select one of
those settings and that is a radio button. So freaking ok, umm...so like then we need to account for custom inputs, so like
that's what that is...so freaking like ok, umm...:

input
	type
		radio
	values
		default
			string
				"one"
		string
			"two"
		string
			"three"
		number
			4

Ok so the freaking beautiful thing about this is it's all the way at the top, so it's freaking extensible. We can add
different types, at will, at this point without freaking completely overhauling all of the rest of the code. Static splendor.

Ok, umm...so we would have an input and a type, fundamentally speaking. So then what? So then like we would either hook the
input up to the database or not, so like that also would be a thing...so ok like what do we do with the input at this point?
So we like freaking output it, so umm...so consider the following:

Cinder
	storage
		input
			type
				radio
			values
				...
	input
		type
			text
...

So like we can have inputs inside of storage or not, so inputs whose values are stored and inputs who are hooked up to like
arbitrary code, so freaking umm...ok so what is this thing besides an input? Like so an input is basically a successfully
custom defined thing, so then what remains? Like nothing dude.

Fuck yea.

There's fucking nothing there. All of the templating, everything comes to a point, and at that point there is nothing there.
So we're inside of php, so that means an empty php file.

So what do we build? Where do we go from here?

So like we need to find our way down from here, we need to keep pressing on until we reach rock bottom, until we hit bedrock,
and then we're good, then, THEN, we can code this thing.

Ok, so like lets say we have some templated data, we would define this template, so like we would define the details of this
data: if it is a selected one of multiple things, two of multiple things, simple on/off, text, numbers, etc. It could be
anything. So what we have to do is make sense of this.

Ok, umm...fucking a. How should we do this? Freaking plow through it or what? Take some other route about it? Keep it
consistent.

Ok, umm...lets pick it up tomorrow, we'll get a good full day in on it.

Ok man, umm...what to do today? :) You know what, you're freaking going to start digging into the meat of this thing. This is
a freaking historic day in your life dude...you're totally getting down to your master freaking system and all that. Freaking
bad dude. SO bad.

Ok man, let it rip.

Freaking a, umm...so like how should we do this dude? Freaking like...ok so it's potentially all string, and we're inside of
php, which means string (code), so it's all string. By a freaking thread it's all string. So freaking code the thing dude. :)

Ok man, if we freaking code the thing we are definitely recoding it because we don't know what inline units the thing uses. So
freaking ok, umm...keep writing...

Ok, umm...ok so like fundamentally our value has one of like 9 types. 10 types. So freaking ok, umm...so that is a thing dude.
As it stands, in here, in php, that is what that is. So freaking ok, umm...so then we have to like define handlers for each of
these, so like...so just like everything between php and mariadb is string, everything between php and values of different
types is (at least at a point) string. So freaking ok, umm...so ok basically everything translates to code, every value, and
code is string, so at that point everything is string. So freaking ok, even if we have a sloppy geloppy that is eval'ed php
code that turns into these values we have something that works, so like all we have to do is refine the process until we get
there.

Ok, so then we have a value, any old value, so umm...then we have to figure out like what to do with all this stuff. So
freaking ok, we still have multiple "types", so like we're still inline with our stack, so freaking ok, umm...so ALL in string
this would be a php file, some php code. So freaking ok, umm...

So like ok, these things would be like values of types, so like what we do is...ok so we have a layer that translates
everything to string, so that we have a 100% string (or 100% anything for that matter) interface. So freaking ok, from
there...ok so then the whole thing is one consistent thing: string (at least). So freaking then the thing is officially ready
to be built.

So like ok, what is this thing? Or like what? So it's all string, or all one thing, but then what? I still can't really see
what this thing is end to end, which is what I want before I code it. So freaking ok, umm...so like ok when we code this thing
we preserve the types, so like...so then we have values, and like that's it, we like straight have values. So freaking ok,
umm...beyond that we CAN therefore translate to string or whatever, so like that's what that is.

So ok, beyond this point we're like just clarifying what everything is, but it's like necessary to code this thing, because I
have no idea what this thing is (beyond this point).

So freaking ok, umm...

So ok, basically what this thing would be, then, is a radio button! Duh! Like we have to start from the point where we left
off with the radio button. So like it wouldn't literally be a radio button, that's just an example to work with, but it WOULD
be one or two of multiple things. Like it would be at least one thing, possibly more, but no less. Any less doesn't make
sense. Or does it? So basically it would be one or more things. At least. Just because, roughly, that makes sense. So like
what we do is work it down from that point, work it all out. Even if it's not one or more things (which it obviously is), it
relatively works, so we just relatively work it out from there.

So freaking ok, umm...we go...

Ok so like it's about time to figure out whether this thing is going to work (like we want it to) or not. So what we want this
thing to do is be an all-out system that is capable of so much as snapping things into reality out of thin air. So like we
need to test the thing thus far and see if it's working, or otherwise somehow test the thing to make sure it works along those
lines. We could, however, just keep chugging along until we get there.

So freaking ok, I figure that what we do is...take the rest of the day off? Naa. Ok, so what I was figuring is that if we code
a radio button and break it down we should find our way to the tippy top.

Ok, so one of these things would be...:

<html>
	<body>
		<input name="radio" value="1"> One<br>
		<input name="radio" value="2"> Two
	</body>
</html>
...

So like it would have a name and a value and like that is it. It might have a label and whatnot, but all it needs in order to
be fully functional is a name and a value. So ok, now if we work it down...so like a "project" would have a type, basically.
So freaking ok, umm...:

Cinder
	Project
		type
			website
	Project
		type
			some other type
...

Freaking ok, yea this makes sense, umm...so then we would have:

Project
	type
		Cinder
	projects
		Project
			type
				website
		Project
			type
				some other type
...

So it is consistent! It IS consistent! Fucking a. Ok so an input would be an "input" of a "webpage". A "webpage" would be of a
"website", and a "website" would be of a "project". And then a "project" would be of a "client", and a "client" would be of
"Cinder". The only thing here is that these are completely independent, such that you can have a "project" without a preceding
"client". Fucking a.

Ok so you still need to figure out what all of this stuff is made of, so like...it's made of binary, that much we know. Umm...
hmm...ok so like all that it would take to "generate" a single radio button is all that it would take to generate anything. So
freaking generate a single radio button, generate everything.

Ok, let's do it.

Ok, so like we already did this. :) So freaking ok, umm...we would have an input, and like that's it. Just like a hyper-
conceptual input, because they vary by type. So freaking then we would have input, filtration, storage and output, and like we
would have to figure out what to do with these things...beyond that point it IS wide open, so like we have to figure out the
generalities of these things...or like that's what we're doing, so like...we have to freaking umm...we have to like figure
out...umm...ok so then we have inputs...so then we input, then we filter.

So ok filters are like made of regular expressions. What we do is filter the input directly from the server with regular
expressions, since it is string at that point, so that is what that is. So like the thing is a filter is just like an input:
it can be completely custom, it is defined with a type which forks all of the logic from that point on. So freaking ok, umm...

So ok, if all of our stuff is at the top, what we are doing is creating something subjective out of something objective. So
like the only thing left to do is I guess figure out all the generalities of that? So ok, if all of our inputs, filters,
storages, outputs are typed does that mean we just start building, let it rip? Like then we come up with some custom stuff
that is like reusable, completely reusable, there's no more forking preceding it. Unless there is like a structure...no,
that's all typed, forked, as well. So freaking there's basically boolean running all the way through php, and our thing is
successfully mounted at the top.

Ok, so like should we start building it or what? This is going to be fucking awesome dude. Freaking completely generalized
code and stuff, fucking bad.

What is the generalization of generalization? Or like what we're going for is the penultimate freaking thing, so I mean does
that mean we start coding at this point or keep hammering along until we get THAT done? This all makes sense.

So freaking ok, umm...so like what we want to build is basically a snapper, so like what we need to figure out is...ok so like
we need to move towards a completely generalized and therefore automated system, so like what I mean is the thing is
generalized in that it does one thing all the way at the tippy top. So freaking ok, umm...or like ok, so what it does is...
freaking generalizes things all the way up, is "general", or "generalized". So freaking ok, umm...how do we generalize
everything? Generally speaking we make two things one, bit by bit, so like what we do is make two things one in general. !
What the hell is THAT?

Ok, so lets do this: ...ok what if this doesn't work? How do we know that it works? How do we ALREADY know it works?

Umm ok so arrays are "static", so any two elements of an array never overlap in any way, shape or form, so like therefore the
thing works, any two states, any two values, never are each other, so like the thing retains integrity all throughout. Or like
nail it dude! So freaking ok, umm...so we know that two things...ok so everything is "forked", so...or like there is a fork
that runs all the way through there, so like then we have things that are of different "types", but like...so there is an
illusion of forking when really there are individual things.

Ok, so every "thing" is the result of a fork, and then what we have is individual "things" with one "type" a piece, so that
there is no forking (at that point). The first of these "things" is responsible for all the rest of them by the same process
of forking, and therefore there is no difference.

So that is what that is.

Now do it.

Ok so is this thing going to work, we ask?

There is no difference.

So freaking there is the illusion of Ying in that there are two, things are forked, before we have any of these "things". The
solution is therefore to use two, since two is a positive number like one (and not zero).

So freaking ok, umm...

So ok, I theorize that if we create two of these things we should be able to tell how to create one of "those" things, how to
put the two together into one, how to create an extrapolator, how to achieve my goal.

So freaking ok, lets say we have a "project" and a "client". So like a project would be generally anything, any "project". So
like a project might contain a name, a description, some filepaths, etc., and a client might contain like the same things,
along with maybe contact and billing information, so on and so forth.

So freaking ok, umm...so a "client" is a "project" but a "project" is not a "client". That is generally what that is because
a client precedes a project, but I mean it doesn't necessarily add up like that. Like a client can have a project, but a
project can't have a client, which doesn't actually make sense, but makes relative sense. So freaking ok, umm...so at the
point at which they are interchangeable in order they are the same thing. Ok, so like lets develop what these are to figure
out like how they overlap, how they are one thing:

client
	contact information
project
	no contact information

So then basically what we would have is four, single things: client, contact information, project, and no contact information.
So then each of these becomes it's own independent thing, so like then we can put them inside or outside each other at will.
This is definitely what we want. So freaking ok, are they objects? Are they arrays? They are like objects. The only thing
about an object is we have to define the methods of those objects, arrays we have just straight data, although then we also
have to account for objects (objects can be elements of arrays) at that point.

So ok, a "client" would potentially be a collection of these things, so like...ok so "contact information", for example,
would be something like:

phone
	cell
		*** (string?)
email
	work
		... (string)

So basically string, at that point, umm...at the point at which this is all code this stuff is all string, or all one
consistent thing...ok so like if we use objects they have properties and methods, if we use arrays they have anything. So
objects are more concise. So we use objects. I mean yea that's what that is. Freaking a.

Ok so like what we would have is an object that has a "$value" and a method (maybe more than one method). So like basically,
typically, this "$value" would be an array, but it doesn't have to be. So that is definitely what that is, because we are
definitely using objects and the "$value" of one of those objects is (at least) an array. It's a value, so what we have is an
object with a value and a method. So freaking ok, what this method does is basically it is the constructor of that object and
it handles data according to type, so what it does is unifies all data, interprets "$value" unilaterally. Fucking a.

So what does it do when it interprets it's "$value"?

So then we would have different interpreters for each type, so like we have a "Value" class or something like that that is one
of these objects, and then that class loads interpreters for types and so on, and then interprets it's value. Fuckin a. That's
badass though dude, infinite potential. That thing could do freaking anything.

So then we like generally interpret things, so like types in php...that's AT LEAST what that is. Ok so like there is one
consistent thing: type. Beyond that everything is different...so ok at that point we could interpret, or we do interpret,
everything as the same thing, so like...

Ok so at the top of this thing would be an object so big that it wouldn't matter what it was, particularly, until it came down
to it and you needed something accurate. :) So like what I mean is it would be completely generalized, so you could just start
and run with it, or you could dote on the thing until you get it all figured out.

I opt for the latter, at least at this point, so like...so we have a thing that is all the way at the top, and like what it
does is build websites and stuff, generalizes the process of doing so and all that, so like what is this thing? Does it even
matter? It like doesn't even matter.

Well, the thing doesn't work (yet) so like that's not what that is. But it's a beautiful idea, that you can use anything for
that because of what it is, because it is THAT generalized.

So freaking ok, umm...so we're going to call this thing "Cinder", subject to change at any point in time for any reason, so on
and so forth, and like ok so this thing breaks down websites to bits and pieces, such that we can use a shorthand command to
build a huge website, so like...

Ok, so if I freaking...if I freaking add two numbers or something, if I generalize the process of doing so I end up all the
way at the top ever so slightly doing what I'm trying to do. So then I figure we're getting there because binary is a number.
The thing is consistent, it's consistently made out of anything (we want it made out of), so like all we have to do is
translate everything, translate one thing to two things.

What if we make the thing out of an algorithm? That would get us WAY closer to our goal.

Fuck man. I don't know what to do...yet. This totally sucks just sitting here like this though, I totally have to figure this
out. I, not we, now, I, not we, then.

So it fits a curve, binary fits a hyperbolic curve, so like then what?

Ok so like what we are trying to do is create this thing out of an algorithm, so like what we do is freaking drill down and
plot out this algorithm. What this is is...ok so if we built one now we would basically have a function that handled input
(any form of input), filtration (user authentication, filtration of input, etc.), storage (any form of storage) and output
(any form of output). So like all we have is a function that is one thing that does all this stuff, and what we need is a
successfully replicative function that is one thing and that does everything. And I freaking mean it. :) So like ok, umm...

Ok, fucking a, so AT LEAST what this thing would do would be the same as what a website would do, so all we have to do is
(carefully) outline a website and then freaking relate everything until we get there:

output
filtration
storage
input
...

So like our input would be a product of our output, basically our input would be the product of our output towards php, which
would be php's input, and then php would output (run the script) and produce the actual display or whatever which is the
input. So besides a get string we have to actually output the input to have input. Fucking a. Ok, then what we do is filter
the input, so we, shortly, filter the input AFTER we receive the input, so AFTER we have something to filter (otherwise this
doesn't make any sense). Ok yea, so DOES it make sense to have output before input? At the point at which you have to output
your input, yes it makes sense. Ok, so then, after we filter our input, we store it. AFTER we filter it. We don't filter it
AFTER we store it because this doesn't make sense, and would be a huge security flaw. So:

output
input
filtration
storage

Fucking a. So we have a rough sketch of everything...wow. Yea like filtration and storage would be a product of input:

output
	website
		html
		text
		inputs
input
	data
filtration
	regular expression
storage
	store data
...

Yea this is making sense. Fuck yea:

output
	process input
		filter
			store
	website
		html
		text
		inputs
		...
...

output
	input
		filtration
			storage
	website
		text/other
		input
			filtration
				send to output
...

Yea this is making sense...so like we would have html, js, etc. versions of output, input, etc., so like the php would fire
off (the output), and the output would process the input (in php). This process would be purely php! No html, nothing, all
php.

Or like what if we just consistently translate everything to string, or some one thing? That would like force us to be
consistent about everything...would that get us there? Ok so then you have like a little window that everything fits into, and
then that window is like totally representative of the whole, and then everything translates, at least, to boolean, so like...
so like yea that gets us there, just not ALL the way there. It gets us to the point where everything is the same, which is
definitely what we want, but it doesn't get us to the point where everything is different, which is what we need, because we
HAVE indifference, what we don't have is difference. Yea, the problem isn't that everything is indifferent, the problem is
that everything is different.

Ok, so this majorly points to da qi. Freaking if we just bit the bullet and held on tight we SHOULD like go through there,
there is no difference, but I mean if it doesn't work we're fucking screwed. So freaking ok, umm...

Ok so wrapping it up for the day, what we need to do is like freaking map this whole thing out, so end to end, freaking
output, input, so on and so forth, all mapped out. So like what we need to do is go ok, how are all these things like
interwoven, how does it all work, all of that. I mean like ok, we need to figure out...we need to like figure out how the
output works so we can get all this stuff working, like freaking figure out how the output works in terms of the input, and so
on and so forth, and go from there. All in all though I think it's just kind of going to be a pain in the ass. I mean it's a
complete feat of freaking strength and majesty though dude, so don't be surprised if it's kind of gnarly getting there. The
thing is though dude when you get there you are fucking THERE. I mean THERE! Like you will be able to snap your fingers and
out pops a cheeseburger, so don't worry about it too much.

Ok man, umm...freaking ok, so like you need to map out freaking everything from end to end, so freaking like...umm...so what
is that? That's like umm...so like you need to relatively map everything out, so like translate everything to string,
something, just get it done.

Ok, so freaking what this is is...ok so like what we do is go ok, so we freaking map out every step of the thing, and what we
do is go ok, so each thing, each "thing", is either output, input, filtration or storage, so we map everything out in those
terms. Now I don't know how this is going to make sense...doesn't it make more sense to use our minds to do this? The mind
moves so much more quickly...it will draw up a huge diagram of something, look over it's data, and relate a conclusion about
something in a matter of seconds. It sounds kind of dumb, maybe, but if you think about it it would take like a month to do
that by hand. THAT is what that is.

Ok lets see what we get:

index.php (output)
	Cinder (storage)
		output (output)
			process input (input)
				filter input (filtration)
					store input (storage)
			input (input)
				filtration (filtration)
...

OR:

Cinder (storage)
	output (output)
		input (input)
			process input (input)
				filtration (filtration)
					storage (storage)
			output input (input)
				js filtration (filtration)
...

OR:

Cinder (storage)
	output (output)
		input (input)
			input input (input)
				filtration (filtration)
					storage (storage)
			input output (output)
				js filtration (filtration)
...

Or something like that:

output (output)
	input (input)
		filtration (filtration)
			storage (storage)
		output (output)
			js filtration (filtration)
...

So like the same thing is happening over and over again, which naturally makes sense, just like the only thing is that...ok so
if we have an input, an html input, and we "output" that input, what we do is go ok, so we have the input first, so I think we
have this thing backwards, I think storage comes first, then filtration, then input, then output. That way we have something
to output before we output, and so on and so forth. The obvious.

Anyways, umm...

Ok what if we do this: what if we map everything out from bottom to top for a project? So like lets take the Cinder site: so
we go ok, we have the mariadb, at like the very core of the thing, so what we do is design our tables and whatnot BEFORE we
move on to other things, so like ok...so basically, BASICALLY, a site can have ANYTHING stored in a database. What I mean by
this is they can have any string stored in the database, and what I mean by that is simply that the contents of the database
are transmitted to the server as string, so like what this means is that EVERY time the database sends something to the server
it has to be translated into its' correct type. Fucking a. Either that or there is some (good) reason...naa that doesn't make
sense, because when it goes back into the database it gets translated back to the type set on the database, so freaking that
is what that is...so like effectively what you are doing if you don't translate the data to the corresponding type...ok so
whether you use the correct types or not, when it finally gets in the database it has to be the correct type, the
corresponding type. Fucking a.

Ok, so like the output would be the output, and the input would be the input. Now, the thing is like, ok, umm...the thing is
that these are interwoven, so like the output shoots off, then the input is a PART of the output, so like then that shoots
off, just the only thing is that the input ALWAYS shoots off after the output, so like I'm not actually getting anywhere. The
wheels are spinning, but they aren't touching the ground.

Ok, umm...so like the output would fire, then the input, and like what the input would do...so ok the output of the inputs
would be output, not input, so like all of the inputs would have to come before the output, so I think, I'm pretty sure...I
mean at that point the input would come before the output, although this like doesn't make semantic sense, because 0 comes
before 1 (O comes before I...even though it doesn't...)...ok umm...so it doesn't really matter at this point, so logically
what would happen is...

Ok what would happen logically? PHP would parse the code, executing the statements. Then the thing would process input, first
and foremost...ok it would, specifically, read input from GET/POST variables. Or would it:

index.php
	read GET/POST for input
		filter and store input
	output rest of site

Or look at it this way: if the output isn't hooked up to the storage, we can't output the contents of the storage, so like...
then the storage has to come before, has to already exist, before we shoot off the output. Fucking a. Ok, so we move forward
based on that basic logic.

Ok, so it would go:

storage
filtration
input
output

or something like that...how does this make sense, though? So on the way out the storage has to come before the output, on the
way in the filtration has to come before the storage, so what order do they go in? Or I mean does it even really matter? It's
just a technicality easily resolved by actually coding the thing.

Ok, umm...yea anyways, umm...so we have a thing that freaking...umm...like...so we have our database, then we have php
interpreting input from that database. Everything is string, we just have to convert everything to the proper types after we
get it from the database, so like we have to read the database structure...I'ma try coding a little snippet of this thing.

Ok so like what we have is:

column_1	column_2	column_3	...
0			0			0
0			0			1
0			1			0
...

So like what we do is go ok, we reference data by row, then by column? Ok so each row is a single thing, whereas each column
is not. What I'm saying is columns are part of rows, but rows aren't part of columns. Shortly what you do is like, ok a row
would represent a single thing, so lets say like a person, where the "first", "middle" and "last" columns would represent the
names of that person. It wouldn't make sense to reference only the columns themselves, at this point (without at all having
anything to do with the other columns). So freaking that is, at least, what that is. Or, if you only reference the columns of
the rows you would effectively have three different tables, at which point there is no point to having more than one column
per table. Then we wouldn't have columns per rows, we would have rows per columns. And then we can't have multiple columns per
row! And then we just plain can't have multiple columns, which is no good, we want one and greater than one, not just one. So
freaking ok, that's what that is.

So ok, we need something unique to identify something when...it has children...so basically, how else would we identify
something? How would we identify something, uniquely, without something unique?

So like basically everything would have a unique order that it occurred in in the binary. So what we do is keep track of this
ordering to keep everything unique. So like whatever the thing is, that is AT LEAST what it has to do to do what we want it to
do.

Ok so if we multiple two numbers, lets say 16 and 32, what we do is add 16 32 times over, so:

16 + 16...

So what we do is go ok, what is 16 * 1, then what is 16 * 2, then what is 16 * 5, so that we multiply by numbers that are, if
we divide by them, precise. So what we end up with is:

(16 * 5) + (16 * 5) + (16 * 5) + (16 * 1)

or (simpler to think about)

((16 * 2) * 16)

Such that we start with something simple to thing about (16 * 2), and then multiply by the remaining multiplier (16). Or
somesuch, I don't know the exact wording but you get the general idea. So freaking ok, umm...so like we take the larger of the
two numbers and multiply by the other, so "32 * 16". Then we go...:

32 * (2 ** 4)

or

((((32 * 2) * 2) * 2) * 2)

or

512

...yea that's right, 32 * 16 is 512. Ok, umm...so if we are multiplying x and y:

x = 32
y = 16

where z is the value:

z = x * (2 ** sqrt(y))

is the freaking equation of the universe, the simplified version of the equation of the universe. Ok, umm...so to add two
numbers together:

6156456 75674345

We go...:

x = 75674345
y = 6156456

z is the value:

z = x + (y )...:

<?php

// main init
$x = 75674345;
$y = 6156456;
$remainder = $y % 2;
$remaining_y = $y - $remainder;
$twos = $remaining_y / 2;

// loop init
$twos_exponent = 1;
$current_twos = 0;
function augment_current_twos() {
	
	global $current_twos, $twos_exponent;
	$current_twos = 2 ** $twos_exponent;
	
}

// loop
do {
	
	$twos_exponent++;
	augment_current_twos();
	
} while ($current_twos < $remaining_y);

// calculate remaining_y
$remaining_y -= $current_twos;

// remaining multiplier
$remaining_multiplier = $remaining_y / 2;

// z
$z = $x + ((2 ** $twos_exponent) + (2 * $remaining_multiplier));

?>

So freaking ok, that explains what that is, now we just spread this out to deal with everything, and we have something that
easily describes everything. Fucking a.

So the basic problem is that everything is too hard to understand, so we have to sift through everything and find all the
chunks and break them down, until the whole thing sifts through there! Not an easy task given the potential!

Ok, so lets just ram-rod it, freaking umm...

So we have like a...something. So off the top would be like the way to go at this point, so what we do is like program...
something. We program a thing. So basically we program a website, so what we do is basically come up with some syntax, then
bring that syntax to life. So freaking ok, umm...:

<?php

// Start Cinder
include("includes/Cinder.php");
$Cinder = new Cinder("localhost", "root", "", "cinder");

// Do everything else (with Cinder)
$Cinder->makeProject(
	"name" => "Cinder website",
	"type" => "website",
	[
		"title" => "Cinder",
		"webpages" => [
			[
				"name" => "About",
				"innerHTML => "Cinder is a..."
			],
			[
				"name" => "Portfolio",
				"innerHTML" => [
					
				]
			]
		]
	]
);

?>
...

So like shortly what we would do is, lets say we wanted to create a simple web page with multiples of something listed on it.
No freaking styling, nothing to it, just a "print_r" of the data between some "pre" tags:

<?php

include("includes/Cinder.php");
$Cinder = new Cinder();

$Cinder->createProject("test", "website", [
	[
		"name" => "Test webpage",
		"innerHTML" => [
			"Some leading text",
			[
				"type" => "text",
				"maxlength" => 2000
			]
		]
	]
]);

?>

That's astonishingly simple. Freaking a. And it handles all of the backend, everything, from that simple bit of code. Very
good. Now, what else? Umm...so like even if we wanted to define custom data we could specify what type the data is and the
data itself, and voila, custom data. So freaking ok, umm...so like it's all coming together, or just plain all together, well,
so now what?

Umm...ok it's ever so slightly doing what we want dude...I mean there is like no difference between what we have now and what
we had then, but that is like the beauty of it. So freaking ok man, umm...

So how do we push it to the limit? How do we get this bad boy to freaking run so fast and hard it isn't even funny? There is a
way to do it! We're ever so slightly doing it! Just take it a little further and we're there. Fucking THERE dude. Yea. That is
SO what that is.

Ok, umm...so like in order to full-on extrapolate things we have to break everything down to a single one or zero. From there
we just go "1 || 0", and therefore 1. So freaking ok, umm...so like we want to compare two things, so we need an expression
and something to do depending on whether that expression is true or false. So freaking ok, umm...

Ok so generally speaking what we do to max out shorthand is to write the syntax, then the semantic. So freaking ok:

<?php

include ("includes/Cinder.php");
$Cinder = new Cinder();

$Cinder->createData([
	"name" => "Brent Bevans",
	"contact" => [
		"address" => [
			"street" => "1801 Bath st.",
			"city" => "Santa Barbara",
			"state" => "California",
			"country" => "United States of America",
			"zip" => "93101"
		],
		"email" => "cinder.brent@gmail.com",
		"phone" => "(805) 770-3575"
	],
	"mugshot" => "somepath.jpg"
]);

?>

Umm ok, so now what do we want the thing to do with the data? Or, how is this predictive? How is it "reading your mind"? Like
the only way this is reading your mind is by dint of the fact that I "typed my mind in there". Fucking a. It is, however,
reducing things to more simple terms, at least in it's web application. It's taking a small amount of syntax and creating a
great big thing out of it. So freaking ok, what we need to do is create big things with small things. So what does this mean?
So like ok generally speaking what we do is have a generalized system for creating stuff. So like what we do is go ok, umm...
so lets say we wanted some specific structure for data, so like just any old weird data structure. So what we do is generally
create the structure, the more general the better, so that what we end up with is like a structure of...so that what we end up
with is something closer to our goal. Or like what are we trying to say? Have you ever noticed you just don't know how to
"say" that?

Ok so like if we generally generalize...freaking like umm...

Ok so like what we need to do is generalize everything...we need to generalize the thing to a point, in SOME way, so like what
we do is go ok, so when we create a "website" we so declare that we are doing so, when we create a project so on and so forth,
so like what we need to do is have a master type or whatever that we can use as a single point that all else stems from, then
we connect all the dots between there and freaking heaven itself...ok this is going to be relatively hard, I think, but like
ok, so like we have a master function, and like...ok so what we do is have a method that does all this stuff, and what it does
is accepts like a definition that defines everything about the "thing" it is making. So freaking ok, first off we have to get
to the point where we don't need a definition, where the thing works automatically, and beyond that the thing needs to be more
and more efficient, so less and less definition until we get where we are trying to go. So like I think basically what this
means is we need a bunch of presets, things that define the general structure of stuff. So I think these are types. So yea
this is consistent we definitely need a bunch of types to do this. Oh freaking kay, umm...

So generally speaking this master type would...take some orders and give some orders, so like...

Ok so what we do is take what we already have and work with it. So like we go ok, we have a master-method that generates
websites and webpages and such, and what that does is...ok so what you do is fork all the forks until you hit the top. So like
lets say we made a website with this thing, we would generally define the website, a name, a description, a title, so on and
so forth, so that is AT LEAST what this thing is in the end. So then fork all of that stuff until we get there and bam, it's
done.

Ok, so when we make a website we what? We define like the title of the website...so we define a name for the website and
generally use that for the title. So ok, umm...freaking...:

<?php

include ("includes/Cinder.php");
$Cinder = "Cinder";
$cinder = new Cinder([
	"name" => $Cinder,
	"type" => "website",
	"definition" => [
		"title" => $Cinder,
		"webpages" => [
			[
				"name" => "About",
				"definition" => [
					"innerHTML" => "Cinder is a..."
				]
			],
			[
				"name" => "Portfolio",
				"definition" => [
					
				]
			]
		]
	]
]);

?>
...

Ok so freaking umm...so if you start at the top-level and build a website from there, you SHOULD have all the components for
building this thing. So like ok, umm...so if we take our earlier example:

<?php

include("includes/Cinder.php");
$Cinder = new Cinder("test", "website", [
	[
		"name" => "Test webpage",
		"innerHTML" => [
			"Some leading text",
			[
				"type" => "text",
				"maxlength" => 2000
			]
		]
	]
]);

?>

Umm...so ok like the thing is we have to "know" how to loop through arrays and stuff like that, so we use special instructions
to do so (which we custom code), the problem being we have to code every inch of the thing to get what we want. So what we do
is what we did: take something big and compress it into something small. If we could somehow automate the process of doing
THAT we would be way closer to our goal, we might just get there. Granted, it's going to take some work, that IS better than
what we currently have. Ok so second to the top we freaking interpret static string or multiples. So freaking ok, which is it?
Static string, I think, since it is one and not two. At the point at which it is different from the other, and the other is
multiples, it is one. So freaking ok, then what? OR if we just translate everything to string, interpret in string. There is
no difference, you're no better off doing it any other way.

Ok, so how do we draw differences with string? Two different characters, two different things. Two characters, two things. One
character, one thing? Ok so what we need to do is define what two things are. If we use string we have to determine where we
draw the lines in terms of differences, so what we need to do is draw the line in terms of one difference, then go from there.
Fucking a.

Ok, umm...so like if we know what one thing is, we just apply that logic over and over again until we get what we want. Right?

Ok, so we know whatever it is we are looking for is a number, because what else would it be, then...so then that is AT LEAST
what that is, so what we do is use a system of leasts to get there, so we just keep going like that. So freaking ok, it's AT
LEAST a number, so then...

Ok so I think it would be either a positive or negative number, because there has to be a difference, and there IS, ever so
slightly, not a difference between two positive numbers because they are both positive. So if we CREATE a difference, if we
instead choose to use a negative and a positive number, if we CREATE a greater difference, things are "different". So freaking
ok, umm...so then you would think you would have something like positive and negative infinity, but the only thing I can think
of at this point is we need to maintain efficiency, so we use 1 or 0. Thus we end up with VERY small syntax. I think. This is
consistent with my previous data, but that is IT! Other than that I don't know why we would use these numbers. So we'll use
these for the time being, until further notice.

Ok, so what we do is draw some differences between 1 and 0. What is 1 and what is 0?

So here we freaking go again, what do we freaking do? Freaking a. You know what's funny is I'm an organism and I'm totally
sitting here doing this. :) Anyways umm...

Ok so I was thinking and what I'm trying to do is like meld so little as a single "word" syntax for interaction between php
and a database with pixel-perfect algorithmic production of images, and beyond. So like what I mean by that is to create a
sort of image in ones head about what it is I'm trying to do. It's like looking down at the ground and imagining you're
looking at the surface of the sun. Quite fundamental, but not THAT fundamental.

So like what we need to do is "shatter" everything up to create a two-dimensional image of this thing. We have to like lay out
some freaking bones and read them with our bone-mysticism, which we don't have, and then translate to php. Fucking a. So like
what we have to do then is literally learn bone-mysticism, throw down some bones, read them, and translate to php. And even
then what if you can't translate to php? Or what if you have to LEARN how to do that? So coming from the fundamental end you
have to learn, either way. So that is what we are doing then, learning.

Or how about this: hypothetically we are "reading" the thing, and the thing is "up". Like hypothetically the thing is up, is
constant, and we are reading it.

Ok so the difference between two things is, at least, numeric, and the difference between the magnitudes of those two numbers.
There is the implication that these two numbers are different, whereas if they weren't they would be equal, they would be one.
What we seek is two, so these numbers have to, at least, be different in magnitude. They have to be different. So one and two,
one and zero, two and four, as long as they are different.

Ok so if we freaking...so if we write a general bunch of functions for doing stuff in this thing, what we have to do is
account for "every one thing", so like if we are going to write to a file we have to account for opening the file handler (to
write), writing to the file, and closing the file handler. Then we also have to account for such things as forking (logic) and
returns. Basically any special function of php.

So for instance, when we return something from a function we can't have layers in certain ways, we can't call a function that
handles the return, it'll return to the function it's inside of and then nothing will be returned. There is a direct
relationship between the syntax and the functionality of the thing at that point which therefore must be adhered to. This may
allow for a new programming language being devised, but basically we have to limit ourselves to code (the string that is the
actual php code itself). Completely relative detail until we have to like recurse.

So basically the answer to your question, at least, lies within the the aforementioned. So like ok, lets say we have...so like
we have to have a layer that codes the php, and that layer is forked, so it can be two things at once (a whole 'nother
programming language or a php preprocessor).

So freaking ok...so what we do is go ok, lets say we wanted to read/write a file: we open the file handler. So that is an
integral part of the stack (of life:). So like we have single things...we would have a file handler, then we would have our
functions for doing stuff with that file handler. Freaking umm...so like it's counter-intuitive. You have to open a different
file handler for each function, one to fwrite, one to fread.

Ok, so like then what do we do? What comes before file handling? Types. A file handler is of the "resource" type. Then what
comes before that? Ok so a file handler is a value. What comes before that? Whatever is to the left of it, in syntax. So like
we would have the opening of a function, the left-hand side of an assignment, that kind of thing. Ok so we have to "do"
something with a value. So like umm...so what we do is..."hand" the value to something, so assign it, hand it to a function,
etc. Fucking a.

Ok so like php isn't making sense. Why would you freaking seperate opening a file handler from functions that require a file
handler? This is retarded. There's no point to having a file handler seperate from functions that require a file handler...
like I guess unless you wanted to successively do something with that file handler, like fread different parts of it at
different times...or like fwrite to it at different times...you COULD do that. THEN it makes sense, and only then. So freaking
ok, so what we do is...generalize the creation of file handlers and stuff...freaking umm...I think we nailed php itself. So
you do the following:

<?php

$fh = fopen("somefile.txt", "w");

?>

And you open a file for writing...then you write to the file successively at different times...so yea in order to do something
like that you need a seperate file handler that you can reference more than once, so like...why would you ever need to do
that? You potentially COULD, at that point, and that is what is important, is otherwise there is no way of doing that. So
freaking ok, umm...yea it would be completely form-fit to php at that point, since it is (at least) just php. The reason for
that is that that is php itself, what we're seeking is the potential of php, which is php itself.

Ok, so now we're like flatly inside of php, now what?

Ok, so if I "soften" everything in PHP...lets say I create a...like ok basically what you have to do is shatter everything up
into little bits and pieces, so like the thing is you only have to do this on a piecemeal basis, so like when you need a file
you program one, but like ok so then, for instance, when you open a file the filename and the mode of the "fopen" call are set
seperately, so that the thing can handle each of these being set independently (in case you want to dynamically generate file
handlers or something like that). So freaking ok, umm...

Ok I think I've struck bedrock. If you don't break everything up into single things, you have to declare two things twice.
That like explains the skeleton of this whole thing. Of the whole freaking thing! I'm like banging on it with a rod and all of
a sudden there is something solid, I can hear the thing echoing and everything. Fucking a.

Ok, so like umm...so if we start coding we start crawling along, if we don't we potentially get this thing done, ACTUALLY
done, where we're snapping our fingers and stuff is popping out of thin air.

So which path do you choose: crawling or finger-snapping?

BOTH!

Ok man! So like everything is all laid out, structurally, so you just have to figure out all of the details...I think...so
like ok, umm...so like relatively speaking that is what that is, so I mean the thing SHOULD fit right in there, but I don't
know if that means it will go all the way up and down or just relatively fit in there.

How does one figure this out?

So ok, there would be a master object, and then everything else would follow that. So freaking ok, umm...so like, for
instance, this master object would check to see if the website was installed, then would install it if it wasn't, then...ok so
like what if we install dynamic tables and stuff like that? So like we make the website more flexible...so what we,
ultimately, need to do is break everything down to fine-grained stuff so we can feed it into the thing and out pops a
completely custom website. The more the better, the merrier.

So like ok, umm...so what we need is...ok so we would have a master object, and what that would do is...ok so like what we
need is a code-refinery. Even better than that we need like a...ok so like if you get something to go all the way down, you
take that and apply it to something bigger and you get what you're going for. If it goes down, all the way down, you know how
to break everything all the way down, which means you know how to build the top-level of this thing.

So like ok, if a string is, at least, the string itself, freaking like umm...then that defines the "top" of everything, like
these tiny little things have to "do that" in order for the whole to work, or just that's how things go down. So then we have
to figure out like ok, how do things go down from there?

Is it even this complicated? Can't it be simple, too?

Ok so like at some point here we have to address some stuff: we need to figure out how to "macro program" stuff, we need to
figure out how to build lots of stuff out of a little stuff. So freaking ok, umm...so we know that like what this would be is
an inline stack, so like we have to figure out...

Ok so like all we need to do is get the data into and out of the database. So all string, filtered data into/out of the
database.

Ok, so like one thing at a time, output, input, filtration, and storage. So freaking ok, umm...so what we do at that point is
repeat the same pattern over and over again, so at the very top we do that pattern, so freaking umm...

Ok so like first we output, so we code the thing, so like what will this consist of? Ok so first we code the "website" itself,
or "make" whatever "project" we are making, so we actually dive in and get the thing done. So like what I mean by this is get
the thing itself done, so like what I mean by THIS is get the "website" done, the actual html and javascript. Then what you do
is go one step further and get the input done, and what this would be is...ok lets lay this out in like complete freaking
detail:

output
	actually build the thing
		the "face" of the thing
			on a website this would be the actual website itself, as in the html, js, css, etc.
			so like what this is is building the "output", so you have to seperate the output from the input/etc.
input
filtration
storage
...

Ok so like how do we "build" an "output"? Ok so like the process would be completely flexible. That's defined by our system
(as indifferent). So freaking ok, you just start building. So freaking what you have done is "mapped out" the whole process,
end to end, or like at the top, and then what you are going to do is actually execute. Is this redundant/inefficient? Umm...
like no it shouldn't be at all inefficient or ANYTHING, because it goes all the way to the top, and at that point the
algorithm is defined as "super", as in it goes 100% throughout the thing.

Ok, so like what we're going to do is...so like what we're going to do is...ok so we're going to build the Cinder website with
this bad boy, and what we're going to do is basically just start coding the thing, and what we'll do is go ok, so we build
all, ALL of these layers and stuff, and work all of this stuff out to a point, and go from there. So like umm...so what you
need to do is make up your mind in terms of the "look and feel" of your website...you need to engineer a website. Fucking a.
Ok, umm...

Ok so like get started? Or what?

Ok so to build this thing we're going to need some stuff...like the more we break everything up the better, inside and out.
The more it's broken up, the more we get out of it, like if we break up the mariadb into freaking little bits and pieces...ok
so like umm...:

output
	output
		the "output" of the website, the "output output" of the website
			static elements
				header
				footer
				etc.
	input
		the "input" of the website, the "output input" of the website
			html inputs
			etc.
	filtration
		the actual js filtering input inside of the output
	storage
		the actual view of the data from storage
input
	output
		process input on the server?
	input
	filtration
	storage
filtration
storage
...

output
	static elements
	inputs (html "input" elements, etc.)
input
	process input
		actually connect the dots in terms of GET/POST variables
			start the process of processing input
				based on existence of GET/POST variables etc.
filtration
	
storage
...

Ok umm...so like what we need to do is start coding...ok so like what we're going to do is come up with a layout, with the
static end of the website, so like the html, js, and css. So freaking ok, this like doesn't make sense since php is the root
of it all, but I suppose we'll get to that later.

Umm...ok lets start coding and see what we get.

Ok umm...so like what we do is code the php FIRST, because like naturally everything follows that. So like any stylistic stuff
associated with the innards of this thing come AFTER those innards, which is the php, so like we code that first. Then,
everything naturally flows...so lets get choppin'.

So freaking ok, umm...so we need to code a master object for this thing, so like for now it's called Cinder, and...umm...so
like ok, umm...so what it's going to have is a simple about page, that is just a rich-text page, and then a portfolio page...
so ok what we need to do is generalize the WHOLE thing, so that like...so then what we have is a "website" with several
"sections", or "webpages". So like what we have is...a thing that is a "website", and that is basically like an array...ok so
like this "website" has to define certain stuff like nav and stuff, otherwise there's no "access" to it's parts. So freaking
ok, we either can or can't have "access" to these "parts", so umm...but like generally speaking that's what that is, so what a
website would be is like a static definition of a, well, website. So what this is is...like some html and xslt. Huh...yea so
like that's where xslt comes in, because what we have to do is define multiples in html, and like that's how you do that. Ok,
umm, so we have a "website", and this website has an array that holds all of the "webpages" of the website. So freaking ok,
umm, ...ok so like the core of this is we have to completely generalize a simple function, so any old function. Like what we
do is go ok, so we break everything about that function into single things, so then what we have is something that we can
successfully feed through there, so like what we do is go umm...what we need is like a way to "edit" any part of that
function, so that we have complete control over it. So freaking ok, umm...so what we do...ok so to spare redundancies what we
do is just break everything into single little bits and pieces:

<?php

function someFunc($filepath = "", $contents = "") {
	
	if ($fh = fopen(""))
	
}

?>
...

This is incorrect, because if we want to set the filpath and contents seperately we need some way of doing this, like, for
instance, if we're trying to first write to a file, then read from that same file (it's redundant in both semantic and syntax
to do so with a function as opposed to an object):

<?php

class CFile {
	
	private $path = "";
	private $mode = "r";
	private $fileHandler;
	
	public function setPath($path = "") {
		
		if ($this->path = $path) {
			
			
			
		}
		
	}
	public function open() {
		
		
		
	}
	public function write() {
		
		
		
	}
	
}

?>
...

Ok so it's going to take forever to freaking code all this stuff, where we KNOW we can code something, no matter what it is,
so all we need to do is come up with a hypothesis for the thing, not freaking rake over a freaking TON of details...

Ok so like basically what is happening is there are a variable number of layers going on and a variable number of inputs going
on on any given website. So freaking ok, umm...so like ok, so what we have is lets say we want a website with x and y data. So
that data is...so ok like what is happening is lets say we have an input on the site, now lets say that input is filtered, so
like what is happening is the same filter has to be applied to the input on the front- and backend of the site, in the js and
php. So freaking there is like one thing that defines this filter, even though it is in both js and php, so then like what we
have is a master language that we write everything in, and freaking...so it's kind of complex, but ok lets say then this input
is hooked up to the storage, and we have a circular we can circulate input through. So freaking ok, the input is basically a
pipe going through like four layers of steel, so one pipe, four layers of steel. So what we do is define a pipe, then four
layers of steel, and we're good.

Or like ok, umm...ok freaking umm...so like there is a freaking...dude this is freaking bad ASS! Ok man there is the php,
html, css and javascript, and then like so lets say we have an input, that input either does or doesn't run all the way
through all of those layers, so like what we have is...so like what we have is stuff in php that is like inputs and stuff, and
what that does is, well basically its the generalized version of that thing, completely customizable and all. So lets say we
wanted to define an input with this thing:

<?php

include ("includes/Cinder.php");
$Cinder = new Cinder();
$Cinder->createInput([
	"name" => "Username",
	"type" => "string",
	"filter" => "/[0-9a-z...]/"
	"onFailure" => "Usernames must contain..."
");

?>
...

And then what we end up with is something like:

<html>
	<head>
		<style>
			input {
				/* styling for the input shows up here */
			}
		</style>
		<script>
			// this is roundabouts what would show up for js for the input
			window.onload = function() {
				
				var theInput = document.getElementById("theInput");
				theInput.onChange = function() {
					
					if (!theInput.value.match(/[0-9a-z...]/))
						alert("Usernames must contain...");
					
				};
				
			};
		</script>
	</head>
	<body>
		<input id="theInput">
	</body>
</html>

So like what is happening is completely inline, completely flexible, it's totally working. Fuck yes dude! Just a little bit
further dude, we're actually getting there! ACTUALLY! FUCK YEA!

Ok so remember dude, it doesn't come down to code. It comes down to the idea itself. You can code anything, it's what you code
that matters.

Fucking a. Ok, umm...

Ok so then the question like becomes how do you build a thing that builds a thing? Or, in general, how do you build websites?
We know how to build "a website", but how do we build "websites"? Since that's what we CLAIM to do. :) 

Umm...so ok, generally speaking what do we do? Output, input, filtration and storage. So just generally do those things and
like you have this thing dude...:

output
	general output - anything "output" to the screen
		what the user reads
			details about how to go about using the system
			etc.
input
	general input - any "input" taken from the user
		the actual inputs that the user uses to insert input into the system
			html inputs
			javascript inputs
			etc.
filtration
	
storage
...

Ok so like then we have to wonder, what exactly DO we do when we do something (with this thing)? Like ok, how do we make this
thing generate every tiny little bit and piece of everything (that it uses when it does it's thing)? We have to like extend
the algorithm to account for this kind of stuff. So like ok, umm...so like what is a thing? A thing is at least the result of
some kind of expression, a value. Umm yea...like other than that...ok so it's at least the result of a loop, as well. And it's
also the result of recursion. And like that accounts for what a "thing" is. Basically, a "thing" is the result of some code.

Fucking a.

Ok so the logical conclusion of two things is equal to the result of the expression representing those two things. At least.
The thing about that is that that is completely relative to those two things: 1 is greater than 0, but 0 is less than 1. One
would think, would hope, that the logical conclusion of either of these statements would be consistent, but alas, it is not.
Basically we have to put either the 1 or the 0 on the left-hand side of the expression to get the correct, the expected,
result. We simply must dig deeper to find what we are looking for.

Ok TECHNICALLY SPEAKING this is consistent, because the MEANING of greater than/less than is consistent, and like thus we are
getting consistent results, just the expressions are inconsistent: one has one thing on the left, the other the other. So we
can't use these to get what we want.

Ok so like why is a 1 relatively a 1?

Ok so "1" is a character, a single character. So ok, if we convert binary to string, which will (as long as the string can be
stored in memory) hold the meaning of the binary with 100% fidelity, a 1 in binary is a "1" in string, which is a character,
which is a single unit of string. It's a character. Even beyond that 1 and 0 are numbers.

Ok so like it becomes a question of what our output, input, filtration and storage are made of. How do we generate these, and
everything else, EVERYTHING, for that matter?

Ok so we just generate generally what these things do:

output
	send data to the browser
	any form of output
		even something just labelled "output"
input
	take input from the user
		html forms
		etc.
	this is generally typing, mouse clicks, etc. communicated to the system
...

Or ok what if we generate ONE of them? Like ok, so lets say we do our storage, since we might use the filesystem or mariadb
(two different things). Generally speaking, what do we need to store information:

storage
	user
		username
		password

So we would have to store the username and password as a single thing (a single user). If we stored it in mariadb it would be
a row with "Username" and "Password" columns. If we stored in in the filesystem it would be something like the string:

username:password,...

So like ok, umm...freaking...so like we would have a freaking...ok so like either way we would have the data itself, and like
that is all that is important. So freaking ok, umm...so for instance the username and password would be the same string either
way, the same thing either way. Anomolous detail.

Ok, umm...so then we have a freaking seperate system for each one of these that deals with everything with regards to storage
of this information, in and out. Fucking a.

Ok, so these systems would be COMPLETELY UNIQUE! You would basically have to code these things by hand...obvious detail.

Ok, umm...so the way that we generate these things is by defining some stuff...like what we do is define the syntax for
actually doing this, so like ok, when we store stuff in files we simply use different syntax than we do if we, for instance,
store that same stuff in mariadb. Freaking a. The thing is, though, there are certain similarities between the two that can
be exploited for our purposes: because the data we want to put in this thing is constant, everything in between is also
constant. Therefore we simply, well, basically program two of these and we have our answer.

Ok so everything about the storage would go down the drain when you relate two different storage mechanisms. The syntax for
any one storage system is rigid, it takes the same syntax to insert a single column into a single row, data (username/password
from our previous example) is always couple together in rows, basically the data is constant, the syntax for handing that data
to a database, or some storage mechanism, is what differs between two storage systems, but is relatively constant.

And the whole thing goes down the drain.

Ok man, how the hell do we build this thing?

It's BETTER if the thing gets CLOSER to working, so what we would do is generally use our storage, so like what this is...ok
I'm going to make a cup of coffee real quick.

Ok man I might be done for the day. Or not? I feel like I want to keep going just...took a quick walk down to the store and I
guess a little winded...

Ok! So freaking umm...so like now we freaking code...ok so like we program this thing, so what it is is a generalized thing
that handles storage and stuff like that, so like what THAT is is...:

mariadb
	database
		table
			username
			password
filesystem
	encoding
		username
		password

So freaking ok, like when we use database versus filesystem we have a couple things, first we need to "connect" to the storage
itself, so with maria this would be connecting, literally, and with the filesystem this would be opening the file. So then
what we do is...well ok like directly at that point we have two different ways we have to do stuff:

mariadb
	new mysqli()...
	mysqli->select_db...
filesystem
	fopen...
		fread...
		fwrite...

So they are completely different...well, not COMPLETELY different, but basically a lot different than one another. For
instance, in one we have to encode and decode the data before we actually write it and so on (with the filesystem), whereas
with the other we directly read/write from the database. The simple fact remains, however, that they both do the same thing,
and in fact, in terms of the ends, the exact same thing (username and password).

Fucking a.

So ok, there are certain congruencies between the two of these, therefore. They would both read/write the data, they would
like both "connect" to the data source...so basically we have to account for "every one thing", or, when there are multiples,
multiple "things". So freaking ok, umm...so what we do is figure out the slightest difference and go from there. So basically
this would be when we have two 1's, two 0's, or a 10 or a 01. So the thing about this is 01 is 1. So like freaking ok, at that
point the thing curls over into itself. Also, 0 isn't a "thing", at least at the point at which we conceptually take it into
hand, so we have 1 or 10. Or something like that. :) So freaking ok, umm...so what WOULD one of these storage mechanisms need
to be able to do? Read, write, and organize data. So freaking ok, we need like...so for sure we need to be able to read and
write the data, and then like we need to maintain the organization of the data, so store it in "tables", so on and so forth:

storage
	table
		read
		write

So like freaking ok, there's not that much to it. So what we do is go ok, now what does this thing need to be able to do in
general? It needs to be able to read and write data...doesn't it? Or freaking does it? Ok maybe this is a little deep at this
point.

So freaking ok, if the storage needs tables and the ability to read and write, everything that comes before it needs to be
able to do those things. So figure out the storage, figure out the whole thing.

Ok, so lets say we want to store usernames/passwords: we basically need a table (the formatting of the data) and the data
itself (a row in the table). So freaking ok, umm...what do we REALLY need to do this? We basically like need a...so ok we need
the ability to store multiples, then do we need any formatting? We need, at some point, somehow, the ability to, for instance,
store a password with a username. So yes, we need formatting.

Mmk, so how do we, dynamically, account for something like storage? Woof dude, that's a freaking heffer.

Ok, so what if we do something like lightly extrapolate some binary? So we do the same thing we do with our plug-in generator
and go ok, so freaking umm...basically it IS our plug-in generator, so like what the thing does is take some commands and
generate a bunch of stuff from them, it takes little and makes much of it. So freaking ok, umm...so basically what you need to
do with this thing is liken it to your plug-in generator. If nothing else just make it the plug-in generator itself, for all
it's worth.

Ok, umm...so like freaking what we do here is...ok so we have to come up with a completely dynamic storage system...so like
tables and all, formatting and all, all down the drain. So freaking what this is is...:

storage
table
row

And that's it.

So ok dude, what do you need in terms of storage? So like we need...tables and rows and stuff, what all do we need though? If
we have tables and rows we have two-dimensional data. If we "link" to other tables we have "three-dimensional" data, even
though that data is like...so basically we can have a row that has an array associated with one of it's columns. So let's call
it good, at that point, and carry on. If we're wrong we can fix it.

Ok, so now we have data...so how do we "do stuff" with our data? Good fucking question. I have no idea. So ok, if we purely
have data, then what? So like ok, umm...so like ok, more fundamentally what we have is basically a filesystem storage system,
and then the encodings/etc. of the data. Then we generate those encodings and whatnot, and like then what we have is a string,
is, in fact, a string (once we get it inside of php via fread). So freaking ok, then we just need to figure out how to
interact with a string, completely dynamically. So freaking ok, umm...so string is a linear series of characters, so like ok,
if we represent arrays and stuff with this string they follow certain rules. They are, thus, linear. This is WAY down there.
So freaking ok, the only ranges that would occur would thus be completely linear, so "2-5", "4-10", "12-15", so on and so
forth, and then like...then we would have like a one-dimensional character, so '"' for instance, that would denote the
beginning and the end of something (one dimensional). Then we would have something like two-dimensional characters, so, for
instance, "[" and "]", that would denote the beginning and the end of something, respectively. Then that's like all we need. I
mean how would you make a three-dimensional thing out of this stuff? So like lets say you used angle-brackets on top of that,
and like selected ranges out of arrays and such, this like really doesn't make sense. And if you do this inside of some quotes
it certainly doesn't make any sense, because if there had been an opening quote the string would be a part of that quotation,
not something interpreted (it is all string) outside of that quotation. It would have to be this way because there is only one
quote character, whereas with the brackets there are two characters, one that specifically denotes the beginning of something
and one that specifically denotes the end of something. So then the question becomes: do you, can you use a three-piece
bracket system, and then a four-piece, and so on? This is not necessary, as these logically stack up. So freaking ok, umm...ok
even if we did that, we have quotes to account for one-dimensional stuff, and brackets to account for two-dimensional stuff,
and three is greater than one just like two, and therefore there is no reason to do that.

Fucking a.

So fucking then we have the database, which is encoded string, and then the php itself, which is also string. All string. So
freaking then we just have to make sense of the code that we interpret the database with. Ok so then we interpret rows one by
one. Freaking a. So like ok umm...so then we have an algorithm that interprets the database, one algorithm for one database,
pretty much, and like...ok so what this algorithm would do is...dude keep going dude, you've spent $4, ate nothing, and worked
freaking like 13 hours today so far. Fuck yea. And you're fucking getting shit done. Get this shit DONE! DONE DONE! Get it
done so fucking hard dude, be all ok this is EXACTLY what this is and fucking POW, people are like oh my fucking god when
something, when that cheeseburger, pops out of fucking thin air before their very eyes. Hell fucking yes.

And when you get there dude...

Ok so we would have an algorithm that would define how basically php would interact with the database. So at the point at
which we have php and a file that we are reading with php we have string, directly string (as we could read both of these
files with php). So fucking ok, fucking get it dude, strike it so fucking hard, fucking claim it, get your dirty hands on it
and fucking keep it for yourself no matter what. And when you do it again do exactly, EXACTLY the same thing. Fucking right on
the fucking nail dude. That's what that is.

Ok, so we would have an algorithm that would define how php would interact with the database, and what this would do is define
everything about how php would interact with the database. Basically, since this is php, it would just be all of the php of
the website.

Ok, so like what we would do is lay down some syntax that would define, say, how user-authentication worked for the website.
So like we go ok, IF one thing (the input from the user) matches another (the user information in the database) the user is
authorized. Then like ok, umm...so ok let's say that's it and go from there. So like this defines the freaking user
authentication. Yea duh.

Ok, so then we define everything with this thing, and we have a working website. So like freaking ok, umm...so we define user
authentication, the webpages themselves, the backend, the frontend, all that stuff. Freaking ummmm....and then we don't have
another algorithm that defines that algorithm, that's the main one. At least. Yea, THATS what that is. So ok, two algorithms,
one algorithm. So we have a single algorithm...we have a single algorithm because it's the master algorithm, the algorithm
that the other algorithm comes from.

So ok man, what does this algorithm do? So ok, then we define some shorthand and freaking go nuts with the thing. So like ok,
umm...get heavy into this tomorrow dude, freaking call it a night. We can plow into this headlong tomorrow. Or not? Naa I
ain't down dude, fucking keep ripping at this thing dude.

Ok, so like basically the rest is history. If everything directly piles up, all we have to do is build stuff and keep piling
stuff up with this bad boy to build anything. And if it comes to a point, you have yourself a fucking extrapolator. Fucking a!
I mean ok, so like how do we do this...

NOW start coding the thing?

Ok I'm out for the night, gotta take a shower and everything. Peace nigga.

Ok man, back at it. Another 14+ hour day of mayhem.

Ok, so lets get down to it. What are we going for here? So we have an algorithm, an algorithm of algorithms. So freaking ok,
umm...so this algorithm would generate everything, so like what we do is...freaking reduce everything to a point, so like we
have to figure out does an "if" come before a "for", all that kind of stuff. So freaking ok, umm...so ok, like the algorithm
would work in concert with the refinery to come up with completely badass code. So freaking ok, what I mean by this, or
rather, to elaborate, is we will have to come up with shorthand for this thing, and in order to keep it tight the refinery
will have to sift through this shorthand to find any inconsistencies. So you're totally in for quite a freaking feat.

Ok, umm...so like ideally what is happening is the shorthand accounts for every one thing, so what we need to do is figure out
the root of everything. Of EVERYTHING. That's what you get for coding the algorithm of all algorithms.

So freaking ok, umm...ok man so you're looking like right down it's throat. If you create a bunch of "macros" for coding, what
happens is that there is like an exponential gain in efficiency, where for every "macro" you come up with you potentially save
yourself from manually coding an infinite amount of code. So freaking ok, what you need to do is advance very carefully from
this point.

Ok, so what if we go ahead and try to code something with this thing. Like a freaking...just do something simple:

<?php

if (isset($somevar))
	doSomething();
else
	doSomethingElse();

?>

and what this converts to in shorthand is something like:

if
	isset($somevar)
		doSomething()
		doSomethingElse()

So like ok, "if" would have a condition, a success callback and a failure callback. So like you would require a success
callback, otherwise there's no reason for the "if" in the first place. So freaking ok, lets say we started writing...ok at
SOME point this makes sense, because it starts adding up to (a lot) less syntax.

Ok so what is your point with this thing? I was just thinking and I was like ok, so we build this thing, what are we getting
at? Like ok so you come up with less syntax to do more stuff, we need to like find the root of all that to successfully get
this thing done. Like we have to completely reduce it all to a point. Obliterate it.

So freaking ok, umm...so like, at some point, what you would have is successive layers of shorthand, until you had a single
"1". A single character (and in fact a "1"). So freaking ok, then what you do is reverse flow, so anything you code from that
point on directly fits into this structure, such that it is as efficient as possible in terms of syntax. What we end up with
is tiers of code, one after the other, cascading all throughout. So freaking ok, umm...yea that would be an algorithm of
algorithms. If the thing, at least, codes the algorithms from that point on, it's, at least, as big as it's going to get. So
freaking ok, this thing codes algorithms...so what is happening here is we have a single point at which all of this stuff
comes together, so like then there are no redundancies, etc. Fits like a glove.

Ok so like what is a variable without a condition? Constant:

<?php

$variable = "constant value";
if (time())
	$variable = "variable value";

?>

And furthermore, conditions have to be variable, otherwise variables are constant:

<?php

$variable = 1 || 0;
$variable = $_GET["input"] ? 1 : 0;

?>

So freaking ok, umm...so we have the constant of variability, at which point our system becomes viable, unless we figure out
how to code it out of constants. Without variability, there is no point to coding the thing, with variability, everything has
to be constant, otherwise we have unpredictable outcomes. So everything is constant.

Ok, generally speaking what do we do when we run a program:

program runs
	conditionally do stuff
		call a function
		execute some code
		loop

Ok do you need conditionality before looping, or looping before conditionality? There would be no point to looping if a
certain condition wasn't met, and we would have to loop and assign elements to an array before we did something based on it's
count. So freaking ok, umm...so they are interchangeable, but if we HAD to put one before the other we would put conditionals
before looping, otherwise we couldn't conditionally loop! Or ok if we looped and conditionally did something inside of that
loop on every iteration, it's inefficient, we should just do the conditional once before the loop and then loop, therefore
conditional before loop. Or consider this: we can loop with functions, but we can't have a conditional in the main scope
inside of a function, so we have to have conditionals before functions for this thing to be fully-operational. Bam.

Ok, so we have a conditional, we have two, and then we have everything else, the second thing, functions. So like we need
switch and function, and like that's it:

switch
expression
case
function
success
failure

switch
	expression
		case
			success
				function
		case
			failure
				function

Ok so then values would come before conditionals, so that we could have conditionals at all (conditionals are made out of
values), or a conditional with no values is erroneous (inside here, inside php, which IS consistent). So freaking ok, umm...so
your algorithm would be something like conditional, then function call. Fucking a.

Ok, so like you would need code defined for authenticating users, so like...you would somehow need to tell the computer to
"do" that. So like ok, umm...what this becomes is 100% all of a sudden, like ok it's BETTER if the thing runs off of less and
less code, so like:

Cinder
	installed
		login
			view
		install
			login
...

installed
	check_table_structure
	check_one_user_exists
...

check_table_structure
	mysqli
		host
		username
		password
		database
		query
			table
				exists
					table_name
				structure
					column
						"id"
							int(8)
							...
...

So like ok, what is quickly happening is the freaking syntax is piling up, getting more and more complex, so on and so forth.
So freaking ok, umm...what can we do about this...well I mean that's a natural thing, what we do is go ok, umm...just keep
piling it up until you get there. So like what this is is...we freaking...so ok if this thing works we could just code the
thing and it works. Inside and out. So freaking ok, umm...:

if
	installed
		if
			login
				view
				login
		install
...

So freaking ok, umm...first we would have an if, which is like consistent, what comes before if? Well you can't have an if
without an expression, so an expression comes before if. So freaking ok, what is an expression? Something that boils down to
true or false. So freaking ok, umm...expressions are logical, so like BEFORE we derive a value from an expression we have
logic...so what is logic? True or false. Anything that results in true or false. Bam. So freaking ok, umm...so then we have an
expression, and thus we have either true or false, so like...freaking umm...so we have a boolean, then we...then depending on
the value of that boolean we do certain things, so like ok, umm...so your expression can result in anything, so any value of
any type, so like...ok so like if your algorithm comes down to hard-wiring the interpretation of the database, you have to
figure out the hard-wiring to get this right. So like what it comes down to is the difference between two values. So freaking
ok, umm...:

if
	installed
		if
			login
				view (default)
				view (login)
...

Ok so like what we have to do is a top-level thing that like happens when we are processing input...it's like "input", and
what I'm talking about is the algorithm for handling input. So like what happens is...:

Cinder
	output
		input
			backend
				logged-in
					view
						default
							users
								add
								edit
								delete
							pages
								add
								edit
								delete
								re-order
						login
			frontend
				view
...

So ok like for instance how do we generalize the CRUD for stuff? Like ok, so working with the database would be a matter of
sending/receiving string to and from the database, so at that point everything is generalizable...so like first things first
what we do is connect the storage firmly to the filtration, so like lets say we create a table that has an integer column and
a string column, we preserve those types once we transmit that data to php (in the form of string), apply any other existing
filters to the data, and then, finally, work with the data in the output or something like that.

Like ok, so lets say on the way OUT we have our data in the database, then we send it to php, then we (at least) type the
data, then like it's ready to go in php. So there is so much we can do to make stuff generally more generalized in php.
Fucking a. Ok, umm...so lets say we have our portfolio page on our website: we have a client (in the database) which has a
name, description, etc. So freaking ok, we send this data to php (on the way OUT), type it, and then go from there. So
freaking ok, umm...then what if we want to do something wierd with the data, like...ok lets say we had a shopping cart, and we
have a user with a bunch of stuff in their cart: they go to check out, we retrieve the cart data from the database (or
wherever)...what if the cart data isn't in the database? Ok lets assume it is, so then what we have to do is, at a point, add
all the prices of all the items in the cart together, calculate tax and so on, and finally output a total. So how do we
generalize THAT? Fuckin' a. Umm...:

cart
	items
		checkout
			list
			subtotal
			tax
			etc.
			total
...

So like ok, when we come up with a subtotal we just add the prices of everything in the cart, so we use a function or
something to do this. At least. So what we do is go ok, generally speaking what we have is a bunch of functions. At the very
tippy top we would have, at least, a bunch of functions. Fucking a. Ok, so then like...we have to generalize THAT.

Ok, so then we would have stuff like unary/binary/ternary operators, and we would "functionalize" those things, so lets say we
had an "add" function...the "array_sum" function, which adds all of the elements of an array...so then we can "add" numbers
together.

So freaking ok, then what we have is a system wherein we can operate on all types in any way. So like ok, if we try to add a
number and a string together what do we get? An error? Ok so at least what we have is the ability to work with any types in
any way, shape, or form. Fucking a.

Ok, so like then what we do is...

Ok so in the static reality of this it doesn't matter how types are converted to accomodate things like the "array_sum"
function, since data never overlaps, so freaking ok umm...ok so then we would just have a freaking pile of functions. :) Yay!
We've somewhat achieved what we're going for! Then we just program all of the functions and we're done! Fuckin' a!

Ok man! IF you freaking program a website what you do is generalize everything about it, so like ok, lets say we program our
freaking portfolio section: we generalize multiples, so what we do is go ok, "one thing" consists of multiple values, so a
"client" in our portfolio would consist of several values, a name, a description, so on and so forth, and then we display
these values on the screen. So freaking ok, umm...ok so we code a webpage, like dude just code a single webpage with this
thing. Then you code another, and what you do is...you have all of the generalizations done for the thing. Then you just
freaking let it rip, or like dude you SHOULD be able to snap your fingers and out pops a freaking cheeseburger.

Ok lets start coding this thing and see what we get...I totally want to see something...:

Cinder
	refinery
		website
			webpage
				Portfolio
					client
						name
						description
						screenshots
							thumb
							full
...

So like ok, what we do is program the view, so we code a freaking client, so what we have is like a name, a description, and
some screenshots. So freaking ok, what we do is go ok, umm...

So fucking a dude, everything happens column by column row by row, so all you do is generalize everything along those lines
and voila, extrapolator! OR you're totally way closer dude.

Ok, so what you do is make a thing that selects values from tables, so columns from rows, and then does something like
"array_sum" with them. Voila!

Ok, umm...so now you have everything all gridded out, now what? Now like what is the algorithm of all algorithms...hahaha! :)
Yea fucking a what is that...umm...so like it's a bunch of tiers...:

Cinder
	if
		installed
			if
				logged-in
					view
						Cinder
					login
						Cinder
			install
				Cinder
...

Ok, so like what we need to do is come up with a master algorithm for the very top-level of this thing, because what is
happening is we need the same functionality here and there at the very top, when the browser is sent somewhere when the user
clicks a button (or something like that). So freaking what I mean is, for instance, when the user "installs" Cinder they will
be presented with a form...is this the way to do this or should we just keep chopping it up? Like shouldn't this stuff
naturally surface as we code the thing?

Code or plan?

Plan, just because it's like the first thing I blurted out.

So freaking ok, when we "install" Cinder we go ok, the user is directed to a form...so what we need is a way to create a form.
What will happen is that like the form will naturally require certain things to function, and everything will follow
naturally. Or will it? Hmm...ok so like the user will fill out a form to install Cinder, then click a submit button. Then the
browser is directed to the file that takes the installation details and installs Cinder (or not), so like what is happening
is...so ok every step needs to have integrity, 100% fidelity, so like what this means is when we direct the browser to a file
that file needs to account for 100% of the potential of the incoming request. Or something. Fucking a. Ok so like the question
becomes how do we proceed from this point? Literally?

Ok so what this thing would "do" is it would consist of a series of forks, preserving it's ability to fork until it doesn't
need it anymore. Fucking a. So we would have something like:

fork
	installed
		fork
			logged-in
				view
				login
	install
...

Fuck yea dude...:

installed
	logged-in
		view
		login
	install

Could be shorthand for this. Very neat, concise, etc.:

<?php

include ("includes/Cinder.php");
$Cinder = new Cinder("
	installed
		logged-in
			view
			login
		install
");

?>

Ok, then what would something like "installed" do:

installed
	fork
		proper columns in tables
			fork
				necessary table rows in tables
					1
					0
			0

So the thing is a series of conditional statements...so like freaking ok umm...ok so if you trace everything from a statement
back up to the top you end up with a computer program. Huh...:

fork
	proper columns in tables
		fork
			necessary table rows in tables
				fork
					logged-in
						view
						login
				install
		install
...

So like what we would have is a series of breaks in the code where we would take input from the user. So, for instance, when
we "install", we ask for installation information from the user. Other than that the program runs without any input. So then
the output becomes the actual running of the program and the input becomes html inputs/etc. that actually take input from the
user. Fucking a. Then we filter that input, store it, and so on. So what happens is the output fires until the input fires,
then the filtration fires, and finally the storage. So what this means is we have a fork at the point we draw a difference
between say filtration on the frontend and filtration on the backend. So like ok, umm...and the front- and backend fork at
output. Fucking a. Ok, umm...yea that makes sense. Dude you're like an inch from coding this thing. If you just coded the
thing it would all come out.

Anyways, ok so like umm yea the input is dependent on the output (at the point at which the input stems from the output and at
the point at which we do input on both the front- and backend), so like ok umm...:

Cinder
	fork
		installed
			fork
				logged-in
					view
					login
			install

Is like basically how it would go...ok so with razor-fine precision how would this thing go, so like with a single column of a
single row? Umm...ok so like forks would come before loops...

Or like freaking what? So like ok what happens is this thing is all gridded out and we freaking make sense of it all, so like
umm...what we do is freaking...dude this is freaking so badass...so interesting...dude THAT is what that is. That's what you
get for being a red ninja.

Ok so everything would be a tiny sphere, because a sphere will fit through any pipe, and tiny so that it fits in terms of
size.

Freaking ok, so I figured that what happens is objects, resources, closed resources, null, and unknown types aren't filterable
because they have no range, whereas the rest ARE filterable. So what this means is we narrow our search a little bit, but what
happens is we still need to account for logic in the thing, because like then we have some data but like that's the end of it.
So freaking what happens is we loop through the data, just without any logic (we don't, for instance, even account for user
authentication in our CMS). So like what we need to do is dig a little deeper...ok so if it loops through data what it does is
go ok, so we have a column of a row out of the database, so what we want to do is...ok so like that's not what we have, what
we have is an input, so an "input", as in an input that is fully-integrated unilaterally, so in html, js, css, etc. So
freaking what we do is go ok, we just check the value of the input against the database, so like what we do is fork the input.
So we have the input, then we have a fork that checks the input against the existing data in the database (as opposed to
actually inserting new data into the database or something like that), and we have what we want. So on the bright side it's
not looking like it's TOO much further to our destination. The only thing, beyond that point, is whether...so we just check
the input against the "username" column of the users table. Hah. So that is what that is. Ok, so lets map this out:

Cinder
	input
		username
			==
				column
					users
		password
			==
				column
					username
						row
							users
...

if
	input
		==
			username
				users
					if
						input
							==
								password
									row
...

Ok so like in plain english...ok umm...so freaking ok, umm...ok dude, so we could break everything down to functions...or like
to a single value, or like an expression...or like a single variable. So freaking ok, umm...:

Cinder
	user authentication
		view
		loop
...

if
	username
...

So what we have is a simple if statement that checks to see "if username". So what this would do is search all of the
applicable tables for a column called username (columns could be further specified by dot syntax or something like that, e.g.
"users.username", or, with a database specified, "cinder.users.username"). So like what this would do is we would specify an
input called "username", or, more deeply, a column called "username" that would have certain filters and stuff associated with
it, and what we would do is go ok, so when we...ok so if we "if" the username it goes ok, so logically we would check to
...ok so like depending on the context we use "username" in we get different things: if it's a logical check we would
(probably) want to use it's value from the database, but then like which one do we use? So then we create an input (it IS an
input, after all) and go ok, umm...so like if we summon up a username outside of a certain range, inside of a certain context,
we check the input against the database...against a column. However, what if we do something like a switch statement? Then the
"switch" function can take multiple arguments:

switch
	username
		case
		case
		...

So like that (at least) breaks our system of "words". BUT, if we do something like use if statements instead of switches to do
everything it WORKS. Our system of "words" then works. What if it depends on whether there are one or more of something? One
thing, it does one thing, two, it does something else? Like contextuality. Contextuality makes a lot of sense. Then things are
one way, but also the other. Freaking a. So like ok, if we have something like an "if" statement, it expects three parameters:
an expression, a function to do if the expression is true, and a function to do if the expression is false. Then, like...ok so
if we had a switch statement what we would have would be something like:

switch
	expression
		case
			expression
				function
		case
			expression
				function
...

So like ok, umm...so like what is happening is similar to an "if" statement, where we have an alternation of if, expression,
and function. Ok what if we simplify it, if we use an "if" statement we still have like two things, two paths the thing can
take after the conditional expression, so like...the only thing I can think of is that the "word" can only be "if" or a
function name. Freaking a:

if
	function
		if
			function
		if
			function
...

So if and only if the "sentence" has no two ways the thing can go...actually this like works because it alternates, if,
function, if, function, such that whenever you are on one, the other is false, so that what happens is you are never on the
one that is false, or the thing "works". If it doesn't alternate it's completely contextual, so like if we have an if and then
two functions, we are simply outlining what to do when the if is true/false, there is no error. If there is only one function
we are simply not using a function in case the if statement turns out to be false. Hah! If we have more than two functions per
if statement we have an error, but the beauty in this is that it works up until that point. Fucking a. Consistent logical
syntax. Beautiful.

Freaking ok man, lets freaking scale like a giant cliff today. What will it take to get this thing on the ground? So like ok
we need to generate syntax, so like ok we have regular stuff, like so what we need to do is...so everything is "regular", so
all we need to do from that point is "generate" stuff. So like what we do is go ok, what IS the pattern of whatever it is we
are trying to code, then just fit the pattern to the generator...then "generate" the thing with the pattern. So freaking ok,
like with our CMS we have a pattern...so what we do is...ok what is the pattern of the CMS? It has a password-protected area,
the actual place where we put in new content for the website, then it has the actual...so like what is the pattern we would
like the thing to follow?

Ok umm...so like we would like the thing to be as flexible as possible, so like what we do is go ok, umm...so what we want to
do is...so it would be cool if the thing could handle any data, so like if it was a single array and that array could hold any
data, so freaking like...ok so any input coming from the user is string, so it's wide-open from there, so what we do is go ok,
umm...we freaking...so we have user-authentication, then we have webpages. Now, a webpage is a...what if we're just super-
logical about it and go ok, so a "thing" consists of at least one fork and one function? Or somesuch? What if we don't want a
fork? We can totally do it without a fork. Ok no fork. So freaking a "thing" is wide-open.

Ok so like the thing is the point of inline is that it makes short what is very long. Like that's it. Other than that there's
no reason for it, but what it does is organize logic such that: what comes first logically precedes what comes after, in form
and in function, so like we wouldn't put a loop before a fork, simply because we might want to fork before we loop! But why
not put a loop before a fork? Doesn't even matter until we find the root of everything.

Freaking a. Well ok what if we want to conditionally loop? What if we DON'T WANT a loop to happen unless some condition is
met? The fact of the matter is a loop is one thing. I mean ok you COULD put a condition INSIDE of a loop, but then why loop at
all? Freaking a. So ok, if you loop and then have a condition inside of the loop there are potentially gaps in the loop,
whereas if we fork before we loop this doesn't happen. And that is what that is. Or look at it this way, you could fork before
you loop, but why would you loop before you fork? If you wanted the WHOLE loop to occur conditionally you would have to fork
before you loop, otherwise you have to cancel out the loop from within the loop, at which point there is no point to looping
at all, and you might as well...huh...ok so loop or fork, fork, because otherwise we can't conditionally do stuff. So we
PRESERVE our ability to do that and therefore go with fork.

Fuckin' a. So no loop, just fork, or, a fork is a fork, and a loop is a fork, and everything is a fork. Fuckin' a. So freaking
ok, umm...so like...ok so preceding this we need something that is "one thing".

So ok, a fork is therefore quite fundamental. Or rather, the notion of being able to "fork" is a great one. So freaking ok,
then we can proceed along one of two or more paths conditionally, so like what does this mean? Or what do we do, where do we
go, from here?

Fuckin' a.

Umm...ok so we have a pattern that is a fork and then some other stuff, like a fork and a function. So freaking ok, then we
have to figure out how we make functions...or like something. Fuckin' a. Ok, umm...so we need to make a pattern that fits the
thing, so like...ok so what we do is make the pattern completely maleable, so everything broken down to single things, so like
ok, umm, what if we just keep everything broken up into single things and charge it? Shouldn't that result in what we are
going for? Therefore?

Freaking umm...freaking ok dude, like, umm...so we have a pattern, what is this pattern? So it fits anything, so it either
forks or doesn't, then loops or doesn't. So like a fork and a print_r. Fuckin' a.

So like ok, we have all of our data figured out, all gridded out, to a column. So then the only thing that could happen beyond
that point is the logic could fork, so fork and then data, so like then what? Then the only thing that is different is the
expression that determines the path the fork takes. So freaking we need to figure out an expression then.

So ok, an expression is fairly simple, it follows certain rules and stuff, so like...ok so the fork remains the same, the
expression (in the case of an "if", true or false) is what differs. So freaking ok, umm...and true OR false, we get true, so
we have one thing: true. And then that is a number, and, thus, here inside of php and all, 1.

Fucking a.

Ok so now run it all over and code the thing. :)

Ok how about this: in all of the code you would code to build this thing there are only so many "tiers" of code. You would
have to break like a file, a database connector, and a few other things down to single things, and like that's it.

Ok what about this: if you break everything up into single things, freaking what happens is redundancy gets chewed up by the
thing more and more as you go, or at all. So you just code until you get there, the more you code the less redundancy there
is, overall.

Or, what if you just hyper-conceptually break everything down to a mental-pseudo code, or somesuch, and build with that? You
can build the thing, up until this point, instantly, and freaking cover ALL that ground to figure this out?

Ok so lets say we build this thing, we actually sit our asses down and start coding, and what we do is...freaking break
everything up into single things, so like...ok so if you do THAT, you SHOULD have a good idea of how to do THIS. Ok so if you
break everything up into single things, what you do is code the thing, and then take a look at what you have and figure out
where you need to extend things to build this bad boy. If everything is a single thing, there will be tiny little spots that
need improvement that, once filled in, together produce a "sand painting" of this thing. From there we just generalize it,
again, and voila, extrapolator.

Ok, so once again lets map this thing out and see what we get:

Cinder
	process input
		log the user in?
			process the rest of the input
	produce output
...

Cinder
	process input
		$_POST["username"] && $_POST["password"]?
			log the user in
				process the rest of the input
			login()
...

So like we would need to generalize the procession of input. So what we have is a fork and a function, so like...what we do is
go ok, umm...what if we loop, recursively...ok umm...so we need to come up with a "thing" so we can generalize the procession
of input, so like we would have something like an input...the only thing is that then we need to attach logic to it, so what
we have is like a fork. So we freaking make the thing out of a fork, and freaking fork the thing! So then we go ok, we have a
fork, and what this fork does is check the value of the inputs against the database, and if it finds a match, voila, we
continue down the path of truth. So freaking ok, umm...so like everything needs an "entity" at the very top. So freaking ok,
umm...ok so like what we have, in general, is tabular data. Also what we have, in general, therefore, is logic about that
tabular data. So like, for instance, we use certain logic along with the "users" table to produce a user-authentication
system. So freaking ok, what we do is...so like what we do is...go something like ok, if some input matches a "username" and
then a "password" of the "users" table, do something different than if they don't. So like what we have is just a general
thing going on, so like...but we don't HAVE to do this, we COULD just, say, loop through a table and display it, as opposed to
logically doing anything before or after it, so on and so forth.

Ok, how about this, if we have a file or something, and we break everything up into single things, that file becomes an
object, and that object is a value. A value IS an expression, and an expression is assignable, and therefore a variable, and
so on and so forth. So freaking ok, umm...so then we have an object, and that object has a constructor, and the whole thing is
thus one thing.

Ok so like what does a file class need to be able to do? So like if we have a class that represents a "file"? What if we just
take something simpler like a boolean, or even simpler than that like an object or somesuch that only has one setting? So like
we have an object, and...:

<?php

class _Object {
	
	public $object;
	
	public function __construct($object) {
		
		$this->object = $object;
		
	}
	
}

?>

So freaking beautifully all we do is set the object, so like we MIGHT have, we would have something like a set and a get, and
like that's it...:

<?php

class _Object {
	
	public $object;
	
	public function __construct($object = object) {
		
		$this->setObject($object);
		
	}
	public function setObject($object = object) {
		
		if (gettype($object) === "object") {
			
			if ($this->object = $object)
				return 1;
			else
				return 0;
			
		}
		
	}
	public function getObject() {
		
		return $this->object;
		
	}
	
}

?>

Freaking a dude! There's only so much you have to do with it! So you could set/get the actual object itself...and like that's
it. There's no filtering of values or anything dude...ok if we go one step further, with one thing that is like truly one
thing, and use null:

<?php

class _Null {
	
	public const $value = null;
	
}

?>

So null is constant, it can't be several types of objects (like our object example), so freaking that's it dude. No
variability, etc. Freaking a.

So freaking ok, umm...:

<?php

class _Object {
	
	public $object;
	
	public function __construct($object = object) {
		
		if ($this->setObject($object))
			echo 1;
		else
			echo 0;
		echo "\n";
		
	}
	public function setObject($object = object) {
		
		if (gettype($object) === "object") {
			
			if ($this->object = $object)
				return 1;
			else
				return 0;
			
		} else
			return 0;
		
	}
	public function getObject() {
		
		return $this->object;
		
	}
	
}
class test {}

echo "<pre>";
$test = new _Object(1);
echo "</pre>";

?>

So freaking I tested the above and it works, so like what we have is...ok so like what is happening is an algorithmic thing,
our output, input, filtration and storage algorithm is woven through the whole thing, such that we have "sets" which set the
value of properties of the object, at which point that value is filtered and stored. So the "sets" are the "input", and the
"gets" are the "output". Fucking a.

So ok, umm...so a property's value is the result of an expression, so like...so then this becomes a matter of expression, so
like what we have to do is break everything down in terms of expression...so basically equality, everything comes down to
equality. Or freaking boolean. So then we have two things...so yea we just have to break two things down to one thing to
figure this out. So freaking ok, if two things are equal, they are somewhat one thing. If they aren't, they are somewhat two
things. So that's a start. So freaking like what this comes down to is a value, and it's boolean equivalent. This determines
the path something takes at a fork. Really though, that isn't it, what it is is the value of something itself, since that
comes into play in something like a switch statement. So freaking ok, what our syntax looks like at this point is:

switch
	case_1
		function_1
	case_2
		function_2
	...

Fucking a. Ok umm...so freaking an expression...so we have to generalize an expression...there is like no generalization of an
expression, except for like purely aesthetic reasons. An expression boils down to a value, so what we have is effectively a
value, although we certainly won't jump the gun without knowing for sure what we need isn't purely aesthetic! :) So fucking a,
umm...dude this is like totally going to work though man, you're freaking plowing through there with a constant amount of
force and the distance is getting smaller and smaller, things are getting more and more simple, the end is coming near. We're
totally getting there. So like you figure out what something is...what else is there to it? So we have an expression, we have
something that boils down to one thing, then we have, basically, a switch statement, and like that's it. So freaking ok,
umm...so then we logically advance, so like what we do is freaking map this thing out...like freaking there is nothing to it
dude. You just like express, there's nothing to it. You can express anything. What are you trying to express? Or like the
thing takes one of two paths, fundamentally, or one of multiple paths, so it's not the expression but the paths, or path, that
it takes as a result. Fucking a.

Yea man that's a thing dude, that is totally a thing, and therefore it applies. So freaking ok, umm...lets code this thing?

So like ok, we map this thing out, what it does is...freaking take some input and go buck nutty with it. So like ok, umm...we
have everything all gridded out, so like lets build an input.

Ok, so we have an input, and what this is is something like:

<?php

include ("includes/Cinder.php");
$Cinder = new Cinder();
$Cinder->make([
	"input",
]);

?>
...

Ok so like we need to seriously map everything out, so freaking we would have the php, of course, and like what we do is
program everything in terms of php, so freaking the output itself, the input, the filtration, and finally the storage. So like
ok, umm...what if we generate this stuff? That would totally put us in a position...ok so like an input would have a php
reality of some sort, and like what that would be is some kind of method that created it and so on and so forth, so like we
create an input, do we directly link the input to the storage? No, we might want an input that does something else (the login
screen, for instance). So freaking ok, umm...so like what we do is generate html with php...or something like that. At some
point we have to hit the html, and that is dependent on the css, and then the js. So freaking ok, umm...the thing is the
freaking...ok so like how do we code this thing dude, lol? :) Like what we need is a freaking master of a freaking system, a
master system, to do everything with, and what that is is completely simple, just now we need to USE IT to freaking do this,
so what we do is like just start coding. So we have a freaking thing that generates everything else, and like what we do is
like...umm...we just like freaking let it fucking rip.

Ok so like if we can generate freaking expressions and stuff like that...so relatively speaking what is an expression?
Equality? Two things can be either equal or unequal. Fucking a. BUT, one thing is only greater than or less than another if
the two are unequal. So like equality is like the fundamental expression. Fucking a. I think what we're looking for is "&&".
If both are true then the expression yields true, otherwise false. We can like generate these things too dude, you CAN use a
function call as an expression...ok so what are we looking for? We're trying to figure out what the fundamental expression is
so we can generate expressions, or rather generate expression. Then the computer can output, well, everything. It could
effectively think and walk and talk for itself if it can figure out what to do with two things. Or something like that. :)

Fucking a.

Ok dude look at it this way: a property is storage, is "storage", which means we filter it, feed it input, and it is a product
of output. So freaking ok, umm...if we can generalize the process of handling properties...which we can, because it's all the
same thing, it's all one thing, so freaking all we have to do is tinker it out. Freaking so like ok, umm...so we know that
equality is AT LEAST what it is we are looking for, so like what we do is check to see whether two columns are equal or not,
or whether two things are equal or not, so like ok, how do we tell the computer to check whether input and a column are equal
or not?

Yea roughly that's what that is. And then there's the fact that equality simply returns true or false. So freaking it doesn't
come down to equality or inequality, it comes down to true or false. And then like it just comes down to two things, at that
point, before we choose one or the other, and get true. So fuckin' a dude, there's like nothing to an expression, and whatever
there is, you definitely have it down.

Ok, so we can express, then what? I mean furthermore dude everything came down to one thing, so there's nothing to it but to
just lay it down and freaking code this thing. Unless you FEEL like wacking off a little bit. :) Hahaha, wacking off. :)

Ok anyways!

Ok, so we have dynamic data, dynamic expression...what else?

So we can freaking generate data structure, we can generate what is done with that data, so we can successfully generate our
CMS. Voila! NOW code the thing?

Nope. Not until we have it ALL mapped out. It will move faster, in terms of coding, if we get the thing COMPLETELY laid out
before we code a single character of syntax.

Ok, so what do we need to build this thing besides dynamic data and expression? Freaking umm...ok so the two are one at the
point at which we have a value, AT LEAST, so freaking...

Ok so we have our login for our CMS, or the need for such, where what we do is we relate the data from the database in such a
way...so like what we do is...program the storage itself, and everything follows. So like we would have a "users" table, and
then we would have a "username" and "password" column, and then we would have rows in the table. So freaking ok, umm...then we
have the actual view of the login screen itself, where everything differs in terms of the storage and the output. So freaking
what we do is...code every "one thing", so we code the users table, the username and password columns, inputting a row into
the table, outputting a row from the table, and so on...so like you have to map all this stuff out, but the beauty in this
system is that you don't have to be 100% right at any point in time, so you CAN, if you want, just code the thing piecemeal.
So freaking ok, what do you WANT to code? You WANT to code a master system that so much as automatically generates everything
else, so like what you do is...freaking start coding.

Mmk, ALMOST there, just need to figure like one last thing out. IS this the bitter end of it, where we can start coding, or
not? Because everything has come down to one thing we're ready to roll. So ok lets go like this, so we can compare input
against the database, so we can create our login page (dynamically), so freaking umm...so we have the login page, or rather
the installer...do we have the installer? Yea, because we can logically check to see whether the thing is installed, and we
can logically do anything beyond that point, so if the thing goes logic then data...so we have a fork, so like we're good to
go...we have a loop and a function as well, so like we're good, we can recurse and everything. If we're wrong we can always
fix it. Fucking a. Smoke one dude.

Ok man, so like umm...start coding or keep planning? So like what we're going to have to do is form-fit the thing to all of
the available (or all of the necessary) functionality of php, and so forth, so like then one has to wonder: how do we generate
THAT so that we don't have to do ALL this stuff...freaking like umm...huh...

We just generate it. Like you just code the thing dude. Freaking all you have to do is bring it all to a point and voila,
freaking booyaka. So like freaking ok, umm...how do we freaking do this...so we build little tiny components, then we build
everything out of those, so like what we do is...so we filter values by type, and then we have like one thing. So freaking
then that one thing equates to either true or false, so we have a boolean inlet, so like it all "works", just what we need to
do is get to the VERY bottom of it. The VERY bottom, so when you know by all measures that what you have is the VERY BOTTOM of
it you raise your head and get to work, until then, GET TO WORK!

Ok so our thing would go something like:

if
	installed
		if
			logged-in
				view
			log-in
	install

And like that's pretty much it, so what we do is build every one of these components...so ok what is "one thing"? In the
microscopic sense, what is "one thing"? We need to know this to start all the way from the bottom...so one thing is like a
freaking value...we already know this...do we need to go any deeper to get this thing to work? Ok so we've reduced it to a
single thing, which fits our requirement, so we're good to go, believe it or not.

Ok lets freaking code.

Ok so freaking what's happening is we have everything happening at the top, and what needs to happen is tiers need to be
developed, so like for instance we have the database, and what we need to do is create a tier for the database, so that
controls the general functionality of the database, so for mariadb connecting to the database, creating and selecting a
database, so on and so forth. So freaking ok, umm...so the thing is all of this stuff boils down to generalized syntax, so
freaking smoke one dude.

Ok, so what we have is...lets say we have an input that we want to program, an html input. So we code the thing that generates
the syntax for the input, so it could/would take something like a name, value, etc., and we create one of these inputs. Then
we have to consider, what about the form the input is a part of? So we program that. So then we, technically speaking, have a
functioning input, so then we send the data to the server, and we process input. So freaking ok, then we have to look through
the data a certain way, with a certain algorithm, specific to the data itself. So then we have to go all the way back up to
the top and define THAT. So what we do is go ok, we define a "thing" that consists of an algorithm for processing the input,
then we program the input itself. Then we filter the data, which we also have to do with javascript (where applicable), so we
re-run the whole thing and we have to create tiers of functionality where the html/js/css has specific stuff defined by php,
all the way at the top. So freaking ok, umm...what we do is...so we define an input processor, so we define an array of stuff
that defines one of these "things":

"thing"
	input
		process input
	output
		output the actual input itself (html: "<input>")

Ok so without input, what do we have? So by "input" we mean "variable", otherwise there is like no reason...yea so like if we
have output and no input, we have a static webpage. Yea I mean makes easy sense, "input" is "input".

Mmk, so freaking basically the task lies in accounting for input, so like what we do is...see if we did that unilaterally we
would have an extrapolator, so just work it all the way through the thing and voila, extrapolator.

Mmk...umm...so what we have is:

output
	output, so like
		output html inputs
		html elements in general
		etc.
	believe it or not, our actual typing of php
	php outputs
		echo
		etc.
input
	
filtration
storage
...

So like we have output, so our typing in php, etc., and like what we do is cut everything up into, basically, input and
output. The goal in the end is to have a single algorithm that defines EVERYTHING, and by everything I mean "everything". So
the algorithm would run all the way through the thing, is in fact what that is. Fucking a.

Ok, umm...so assignment would be input, something like "echo" would be output, so there are two, so then what? So then it
works it's way through the syntax, and the syntax...is code. The syntax is directly code. At that point. Even if it's not, the
syntax is definitely syntax, so that is what that is:

<?php

function assign(&$variable, $value, $filter) {
	
	switch (gettype($value)) {
		
		case "string":
			
			break;
		
	}
	
}

?>
...

Ok so yea then we filter the values, so like that makes sense, so then all there is left to do is like code the thing, the
algorithm runs all the way through the thing and everything...

Ok what if we do THIS: we lay out all of the functionality of the site two-dimensionally, so in one big list, and go from
there? Then you'll have it all laid out right in front of you and freaking it SHOULD become obvious what is going on here.

Cinder
	output
	input
		filter
			preg_match
				output
					SELECT
				input
					INSERT
					UPDATE
					CREATE
						IF NOT EXISTS
							DATABASE
								name
							TABLE
								name
...

Ok so like basically what is happening is we have "one thing", so a column, and that column has output and input. Output is
like simply selecting that column, and input is filtering and storing that column. So freaking we just string one of these
together and we're done:

<?php

$mysqli = new mysqli("localhost", "root", "");
$mysqli->query("CREATE DATABASE IF NOT EXISTS `cinder`");
$mysqli->select_db("cinder");
$mysqli->query("CREATE TABLE IF NOT EXISTS `test` (id INT(8))");
function output() {
	
	global $mysqli;
	$row = $mysqli->query("SELECT 1 FROM `test`");
	
	
}

?>
...

Ok so here's what we do:

output
	view

input
	GET
	POST
	etc.

filtration
	filter input
		preg_match
			e.g. prepare data for "INSERT" into mariadb table of database

storage
	mariadb
		SELECT
		INSERT
		UPDATE
		DELETE

And like that's it...so ok dude you know that what a computer program comes down to is a freaking function, or like a fork and
a function, so freaking elaborate:

Cinder
	fork
		$_POST["logged-in"]
			view
			login

So like what you do dude is reduce everything to two dimensions, so we can actually get it on the view, on the screen. The
view WOULD therefore be two-dimensional!

So what this means is one array at a time...

Ok, so what this means is we take it one array at a time and freaking program the thing dude. Ok freaking take it one thing at
a time and code the thing.

Freaking a. Ok, what we do is we freaking start at the footprint and code a row. So freaking get a row in there...this like
doesn't make any sense because we have to create the tables before we "create" the rows, so like freaking umm...we like...what
IF we create the rows before we create the tables?

row
	Cinder
	alphanumeric13

table
	column
		"Username"
			VARCHAR
				16
					filter
						regExp
							/[a-z].../
						onFailure
							"Usernames must contain..."
	column
		"Password"
			VARCHAR
				255
...

Ok so immediately we hit a problem. We need to hash the passwords before they go into storage, so we're not storing the raw
password itself. So freaking ok, umm...:

output
	the actual input for the password itself
	translate the password to hash
...

Ok so like the fact of the matter is you need to organize the thing and deploy. So like what this is is the filter is
independent of the storage, since the storage CAN store something like a hash of the input. So freaking there is no point that
the thing has in common...well there is, just it's a VERY tricky point. It's thus going to go all the way down dude, ALL the
way down. Fucking a.

So ok:

data
	"username"
		filter
			regExp
				/[a-z...]/
			onFailure
				"Usernames must contain..."
	"password"
		filter
			regExp
				/[a-z...]/
			onFailure
				"Passwords must contain..."

So freaking ok, umm...so like the hashing of the passwords would be a function of the filtration, because the filtration would
"filter" the password into a hash form. Fuckin' a. Ok, minor detail: how do we freaking get the filter in there if it MIGHT do
something like turn some input into a hash? Then we like have columnular stuff going on, since that would be code (which is
columns, fairly directly columns). Ok so we can md5 directly inside of the storage, so like that is a thing, but it's still a
thing to do this somewhere else, like inside the filtration (or inside the storage, inside of php). Fucking a. Ok, umm, hmm...
so like freaking ok, even if we do that we have to like...so the plot freaking thickens...this is good though, the further
down it goes the further down it goes! Freaking a...:

Users
	"username"
		filter
			regExp
				/[a-z...]/
			onFailure
				"Usernames must contain..."
	"password"
		filter
			regExp
				/[a-z...]/
			onFailure
				"Passwords must contain..."
		onStore
			MD5

That like works...so like we would only do so much stuff, so like "onStore", "onRetrieve", all that stuff all laid out. Then
what? Fuckin' a dude I think that's how you do that. I think that's how you stick a slat in there. Hell yes:

Pages
	"id"
		unique
	"plugin"
...

So like freaking a, I think it works dude...like there would just be hooks, basically, before and after each of the things, so
like ok, umm...yea that makes sense. Why wouldn't that work:

Cinder
	store
		user
			username
			password
				onStore
					MD5

Ok, so then we have a system with "hooks", or somesuch, installed, such that we can do stuff with the data before and after
the fact, so like...then we freaking...ok so then the whole thing runs, so it freaking checks to see if the thing is
installed, and if it's not it installs the thing, and what that does is displays a form for taking in the installation data,
and like...so then we just make a form, then when we receive this form data we go ok, so we freaking store the data a certain
way, so we define that...so is that like "onStore" or what:

Cinder
	installed?
		view
			nav
				users
					$_GET["page"] = "users"
				pages
					$_GET["page"] = "pages"
			display
				$_GET["page"]
					table
						users
							add
							table
								username
								edit
								delete
						pages
							add
							table
								reorder
								view
								edit
								delete
		install
			form
				mariadb
					host
					username
					password
					database
					table-prefix
				user
					username
					password
						onBeforeStore
							MD5
...

Fucking a. Ok so like we would hook before and after a column, so like what is THAT? Or like where would we place these hooks?
So freaking before a column would be like before it's insertion, and after a column would be like after it's selection, or
somesuch...:

beforeOutput
output
afterOutput
beforeInput
input
afterInput
beforeFiltration
filtration
afterFiltration
beforeStorage
storage
afterStorage

Bleh. Hah. Ok so we create hooks before and after stuff, or thereabouts, so then what? THEN we start building this thing? Yea
that's just about it. Dude then we can create ANYTHING! We can successfully generate stuff with this thing. That's it dude
you're officially done for the day.

Ok no you're not. Freaking a dude, could this be it? Like freaking ok, so we freaking code this thing:

Cinder
	CMS
		if
			installed
				if
					logged-in
						view
						login
							username
							password
								onBeforeProcess
									MD5
				install
...

Freaking like ok, so we freaking GENERATE a freaking CMS dude...this is so fucking bad...ok so what would it take to generate
this bad boy? Freaking like we just lay out the syntax, then code the generator...from the top down. So freaking ok, umm...we
go ok, so we freaking have like a data structure layout, coupled with freaking hooks and stuff...or like what? Ok so we
freaking generate a CMS, like what we do is go ok, so we have users and pages as our data, then we go ok we have a freaking
hook that goes ok, or like some sort of thing, that goes ok we freaking require user authentication, so what we do is go...
when the user tries to go to the backend it sends them to the login screen, I mean the basic functionality of the thing. So
freaking ok, the real question is how do we generate these things? So like we basically just start coding, but this is fine,
we can plan this thing out to a freaking dot before we start (how badass would it be if we did, and it WILL, therefore, work).
Fuckin' a. Coffee...ok! Umm...so we freaking...so we code a thing that codes a thing...freaking YAY dude! YAY! :) Like a
fruity little fruitcake yay! :D

Ok! So freaking umm...so this thing takes some syntax and generates stuff out of that syntax, so like what we do is...
freaking...like...so we have a thing that generates a CMS, what it does is...ok so we generate a CMS, then we generate
plug-in's for the CMS, so what we do is generate one badass freaking CMS...dude what if this thing is badder than freaking
wordpress? You will be a fucking king dude! No joke you will be the fucking shit. And fuck a CMS, freaking we go all the way
dude and start building freaking HUGE systems, fucking HUGE, fucking go HUGE, like SO big people are like whaat the fuuuck?!

Ok man! Get to it! So freaking ok, umm...so like we code a thing that codes a thing, how do we do this bad boy? We code our
freaking core system dude! Fuck yea! Ok, so how do we do that? Or what? Yea we like generate shit, so what we do is...we would
specify some stuff, so like we would specify like the inputs and outputs of our algorithm, and what we do is go ok, so
freaking...so we specify our tables, so like users and pages, and then...so like what we do...dude this is SO badass...ok so
like we go ok, we freaking code our tables, then we code the functionality of the site, so like ok, what we do is go ok, so
freaking we have users and we check the inputs of the login page against the database to see if any user exists by the given
credentials, and if so, we log in to the backend. So freaking ok, umm...how this would go is...ok lets just write this in
plain english: so we freaking go ok, first we install the thing, so first we make an installer, and we go ok first we check to
see if the thing is installed, and if it isn't we install it. So then we look over the corresponding tables in the database to
make sure we have everything we need for the CMS to function, so what we do is...dude this is so fucking bad...I mean BAD...ok
so we freaking look over the tables in the database, and if they don't work out we don't use them, and that kind of thing, and
then we insert the user into the database. So freaking ok, if THAT works we go off the top and bam, we're in. From there we
cycle the thing by anchor tags and stuff and that's that, algorithm. So freaking ok, umm...so we generate this thing...so like
what we do is come up with some syntax to specify all of this stuff and let it fucking rip. Even if we just come up with php
functions and stuff to do it...it's wide open dude, and at that you should be well prepared to code whatever you have to to
get this thing DONE!

Ok so where do we go from here, is the basic question? So we freaking have a way of generating stuff, so what we do is build a
thing that generates everything, so like that generates stuff automatically. Freaking a. Umm...so we freaking...like ok,
umm...so freaking what this is is...freaking...we have a thing that generates a thing, so basically just start generating
stuff dude! So freaking ok, umm...

Ok man, lets get busy. So freaking what do we do? Fucking a dude, ok, umm...so we generate our CMS, we're at the point where
we finally generate this thing, so like what we do is feed it some syntax...what we DO is give it generalized commands and out
pops a CMS, in as efficient a manner as possible. So freaking ok, then we need to GENERATE stuff out of very little, out of
less, so what we do is...bundle these commands together and execute. So freaking ok, lets take a look at some stuff:

Cinder
	installed?
		logged-in?
			view
			login
		install

And what this would be in generative syntax is:

Cinder
	generally install the thing
		what does it require?
			how do we know this?
...

Ok so like if this works we SHOULD be able to define everything with little syntax. So freaking ok, umm...so lets say we code
the login screen, what we do is go pow, webpage, then we go bam, some styling and stuff, then we generate our inputs, and what
we do is go ok, so we take our input specifications and generate inputs with them, and like what these would look like is...:

Output
	login
		form
			input
				name
					Username
				onProcess
					Users
						column
			input
				name
					Password
				onProcess
					row
						column
...

So ok what the above does is create the login page of the CMS. So what it does is goes ok, it's the "login" webpage, and then
it has a form with some inputs. The "onProcess" syntax is for "onProcess" events, and what happens is when the username is
processed it's going to look for a "column", so it might have some sort of variable indicating what it is looking for, or like
somesuch, so like...ok so what it's going to do is fetch a row with the corresponding "Username", then when we hit the
onProcess for the "Password" we check against "row", so this is contextual, so it would take the last row it found, or the one
it directly has in it's hands, and look for a "column" with a matching "Password". It's like intelligently moving along. So
freaking ok, umm...

Yea this makes good sense...code the bad boy or what? So freaking ok, umm...yea it's JUST about time to program this thing.
Then we have to wonder: what is the root of all meaning? Like what is the root of everything? If it IS, slightly, this view
that we have come up with, then what is it, in full?

Fucking a.

Ok, umm...freaking ok, so like what is...how did we come up with what we have so far? If we can figure that out we can figure
out how to further generalize the thing...ok so there are certain "events" that apply to this project. So what these events
are are like things that happen before something is stuck in a database, so on and so forth. So freaking ok, dude like the
thing is you already have all of this figured out. So freaking ok, umm...like...freaking...so what we do is take what we have
and like break it up into bits and pieces until we freaking get there, so freaking ok umm...so the thing fits in there, we
just have to work it down...if it's done doesn't that mean it's ready to roll? I mean ok so like everything would be
contextual and everything, so like everything should fit into place EXACTLY. Freaking the thing dude, also, is that this thing
fits EXACTLY in there, fucking so bad. You have truly outdone yourself.

Ok, umm...huh...ok so look at it this way, "every one thing". So like we break everything up into single things, and freaking
so like what we have is one parameter per function, one function per object? Yea I mean something like that. Sounds nuts dude
but I mean it freaking hypothetically works! :) So freaking ok, what we do is...we build with what we have and like we're
good! So like freaking ok, umm...so the thing is dude we DO have something that works, so like all we need to do from this
point is freaking build the damned thing...

Ok, so if the whole thing is constant, what we do is reduce it all to a point, so like basically ok, so we have several layers
of stuff: output, input, filtration and storage. Then we have several layers of stuff within each one of those: css, js, html
and php. So freaking ok, then we have actions and events within THAT, so for instance "onBeforeProcess", "onProcess", and
"onAfterProcess", so like then we have a whole system...yea that's like what that is. So freaking what we have is a "thing",
an "event", like "onProcess", and then an event before and after that event. So freaking ok, umm...so like what we do is go
ok, so we lay down a footprint, so like lets say our users table, and then we have the columns of that table (the columns
themselves and the columns of each row). So freaking ok, umm...ok so if everything is constant, there is a constant "equation"
that represents this thing. So like we go from here to 1 and we're done. Fuckin' a.

Ok, so how do we do THAT? So now we find the patterns within the pattern...freaking ok umm...so then we like go ok, so when
something "happens" we register an event, and then there is a before and after event registered to that event, so like ok,
umm...yea that's what that is. So like freaking ok, umm...so we have an "onProcess" event, so like ok, does this mean we have
something like a "process" action? No big deal, what's important is that we have these events, because like what we do is go
ok, like, so we have an "action", so what we do is build a "project" out of these actions. So freaking this might go like:

Cinder
install
login
view

Such that there is a straight line that everything happens in, one-dimensional, no nesting or anything. So like the "install"
action would go ok, so we freaking...yea this makes sense dude, generally makes sense. Ok, so we have like actions and events,
then what? So then we have an event, and what is that? An event is a function. Ok, so then what is a function? So a function
is like potentially a reusable chunk of code, capable of things like recursion and looping, so like ok, umm...what we do is
freaking...this is freaking dope dude, because everything is a fucking function...functions can do everything you need to do
dude, period. Except for freaking conditionals dude...except from the top you have conditionals in a function, so freaking
you're (still) good dude. Fucking a.

Ok, so like NOW build the thing?...believe it or not the answer is like yes dude! I mean what remains dude...what else do we
need to do before we get started...ok so how would we make something that was like COMPLETELY flexible? So like if we updated
the thing we would need to toss around data in the database (transfer it to the new system and so such), so then we just do
what we do with two things and go ok, so like...you COULD just manually transfer the data...it only takes like two seconds to
do so...fuckin' a. Fucking build this bad boy dude or what? Dude you're like completing your notes for this thing...this is
fucking SO bad. It's been like 8 months. Fucking a. Smoke one dude.

Ok dude, so IF that's the bottom of it, it's time to go UP! :D Yay! So like this is where the action starts, since whatever
we'd be programming we'd be programming at the top. So freaking ok, NOW start coding?

Lets lay this thing out, end to end, BEFORE we do ANYTHING. We're totally on a good roll dude, keep it consistent and get it
done dude. Get it fucking DONE dude! You're like totally gonna get this done!

Ok so lets say we took some input, any old input. That input has a pattern to it, it's binary has a pattern to it. So like in
sounds, in music, we can account for things like pitch and so on, generalities of sound. So freaking ok, umm...so see the
thing is we don't have to know what the pitch actually IS, there is just the constant of pitch (to any sound). Voila! So what
we do is go from the top down and account for "pitch" all the way down, and we ride it all the way down, and when we get there
it will, therefore, fit directly in the hole dude.

Freaking ok, so like we have some potential work coming up, are you ready dude? Are you ready to fucking rock? Get it done
dude, make quick work of it, fucking lay that shit down HARD. HARD. Hard hard. To a point dude, every single character,
everything laid out in glistening detail.

Ok, so freaking what are we going to do here? So like we go ok, we have a freaking thing...so like we just start coding,
everything will fall right into place. What else is there? So like the thing still needs to generate stuff out of freaking
thin air, so...ok so we have to build a website out of this thing. So like what we freaking do is...

Ok so whatever it is, and we're talking about generating accurate data here, matches the pattern we have for the code
generator. So freaking just get it in the hole and voila, extrapolator.

Fuckin' a! This is like going to be harder than it seems...all we have to do is reverse engineer the thing and apply the same
logic to the extrapolator, so like ok what is it...the pattern is, basically, that we come up with more stuff for less input,
so freaking ok, umm...ok so if we can figure out how to generate a single 0...you're like smoking hot close to figuring this
out though dude, I can fucking feel it and everything...

Ok man...how do you do this dude? Freaking a. Umm...:

Cinder
	CMS
		if
			installed
				if
					logged-in
						view
						login
							username
							password
								onBeforeProcess
									MD5
				install
...

So ok, every "thing" can have before and after events, as well as events right on the dot (which I think are after events), so
like then we go...so like freaking...is this accurate? If it is we have a "thing", so like...ok so we go ok, a freaking "if"
"action", or "thing" or whatever has a before and after event...is this overkill? You could just put stuff before or after the
"if", but like if you do it this way it's more compact, which is better. Fucking a. Ok, umm...so ok, umm...ok so then we have
a "thing", so we can generate these "things". Freaking like ok, so then we have to define what a "thing" is. Ok, so how do we
do this? Like the thing is dude we can generate a freaking CMS. We can fucking do that at this point. What we do is generate
all of the logic and everything and we're set! So freaking ok, how do we "generate" the user authentication, for example? It
would like have something to do with the uniqueness of the usernames in the database. We would need something unique to do
something like that, so freaking ok, we "generate", we generate, the fact that it uses something unique to do that, and then
like why not just any unique? Why not like the id off of a blog post or something? Then you select a blog post at the login
and voila, done. One more hour to go dude, hang in there you're ALMOST there. Then tomorrow is friday and voila! It's the
weekend! :D

Ok, umm...so the thing is a username uniquely defines a "user", so at that point we have a way of generating a user. So
freaking the only question that remains, at that point, is why a password? Well, obviously, and roughly, because we want to
"protect" the user. So what we need isn't necessarily a password, it's protection. Fucking a. Ok, umm...ok so we need a
"username" to be unique because one username equals one user. I'm pretty sure. It's right either way since it's one. And then
we have a password. So freaking that is what that is, is a user is one thing, so it has some sort of unique identification
(something that sets it apart from other "things"), and a user has protection, a password...so like protection would be
anything that would like keep pathogens out of the "thing". Fucking a. That's what that is. So freaking everything effectively
has a username and a password. That's what that is. Always wondered what that was. :)

Ok so now you apply this pattern to everything and you should be THERE dude, if nothing else you will be CLOSER to your goal.
Mmk...umm...ok so a username is unique so that it is one thing. A password protects a username. So like freaking ok, umm...a
password ATTEMPTS to...yea it attempts to keep pathogens out. That's basically what a user is.

Or look at it this way: lets say we receive some login credentials on the server: what EXACTLY happens from that point on:

Cinder
	process
		username
			password

So freaking ok, there isn't that much to it, so like ok, how do we GENERATE an authentication system? Yea dude because if you
figure out what that is you know what it takes (AT LEAST) to generate one thing. Like in order to generate an authentication
system you would have to know stuff like WHAT a user is, what a username is, what a password is, and so on and so forth,
because otherwise you simply have no idea how to build an authentication system. Fucking a.

Ok, so generate an authentication system or generate a 0? Or what? So ok, to generate something where there's no difference
there is no work to be done...hint hint. It fits in there dude. So ok, that's what THAT freaking is, now we just need to
figure out like, umm...17 minutes to go dude...then ONE more day and its the freaking WEEKEND. Fuck yes!

Ok, umm...10 minutes to go...so what it is dude...watching the clock like fucking crazy...finish dude, 9 minutes to go. Just
like sit there until you get there. I mean ok, so I have to like figure out how to generate a username, or like I mean really
what we need to do is just translate our system and we're done! But then like the question is how the hell do you do that?
It's like not as easy as it seems. Freaking a. Umm...ok I'm out for the day, peace.

Ok man, so like you still have stuff to figure out! I mean you have it all mapped out, now you need to run over your map with
a fine-toothed comb until you figure out how to put all this stuff together. So like freaking ok, umm...tis' a labor of love
dude, a labor of love...so freaking ok, what we need to do is break this stuff down some more until we get to the core of it,
so closer is better, like always...

I think I can finally take a freaking breath dude...IF you have the thing all mapped out, the rest is a cake walk: just
translate, at some point in time, and pow, extrapolator. So fucking take the day off or what? Nope, got the itch dude, got the
need for speed. THAT is what that is, that when it comes down to it you do what you want, and, so much as as a result, you
want what you do. So freaking a dude, fuck yea!

Oh fucking kay dude! Reverend keep working it down! You're like totally knocking on the door of heaven dude. We are fucking
GOING to heaven dude, that's a fucking statement. Potty mouth and all. :)

Ok:

Cinder
	output
	input
	filtration
	storage
		onStore

Ok so like we have a thing I'm calling an "action". So like an action is actually storing data to the database, so on and so
forth. So I surmise that what we have are hooks before and after these "actions", such that what we do is define a "module"
that does stuff like interact with a database, or the filesystem, etc., and then we have full control over that "module". So
freaking ok, umm...:

storage
	mariadb
		query
			CREATE
			ALTER
			INSERT
				e.g. MD5 a password before insert...
			UPDATE
			DELETE
			SELECT
...

Cinder
	CMS
		installed
			logged-in
				view
				login
					onBeforeProcess
						MD5
							password
			install

Ok so like this makes easy sense, so far. So freaking like what we need to do is somehow get the thing down deeper in there,
until it comes to a point, so like what we need to do is dig vertically instead of horizontally or vice versa until we get
there...or somesuch...so like umm...ok so like the thing is, if we break all this stuff down to single things it's a bunch of
string. It's a bunch of computer code which is (at least) string. So what we need to do is figure out the algorithm for
string. I know this doesn't sound easy, this, in fact, sounds rather completely nuts, but there isn't THAT much to it, because
like all we have to do is generate like some fixed string, so like string, code, that works. And that does what we want it to
do. So like what we do is break down the pattern of php code, then reverse-flow and generate the code with the generator. So
freaking ok, umm...so we need to go DOWN, we need to get more fundamental with it until we figure out what it fundamentally
is, and then we go up.

Ok so when we model a module we go ok, so for every one function of the module we have on thing in the representation of the
model itself, so there is a direct 1:1 ratio, all throughout. So freaking ok, umm...so what we need to do is like sniff for
functionality to represent in these models to dynamically generate them. So freaking ok, how do you do THAT? Like the thing is
you COULD come up with an algorithm, a fractal, or somesuch, that fit right in there, and then you would have effectively
sniffed out all of the functionality of the thing and everything. So like the thing is that seems like a rather nutty thing to
do, so like how do we approach this problem? What we do, in fact, is like fundamentally inductive by nature, we come up with
something that fits, because we don't (necessarily) have a way to sniff around for functionality, but we DO have the means to
"just fill in the blanks", so to speak. So freaking ok, what we do is...ok dude this is what we do: so we freaking map out a
fractal image generator, then we map THAT to a general algorithm generator. So freaking ok, umm...so like what we have are
"pixels", and then we have like logic with pixels, so clusters of pixels (a dot, or a group of pixels that are, perhaps, the
same color), so on and so forth. So then we have the logic to deal with the view. Fucking a that's what that is.

Ok so reverse engineer a fractal generator or what? Like ok, so it comes down to it dude, freaking do you trust your mind or
do you get to work? Is there a difference? There's no difference. Fuckin' a. Fuck dude. If you would've gotten up at 6 this
morning like you were supposed to you would be almost done by now, BUT, either way you're not done yet. So that's what that IS
dude! Fucking a.

Ok, umm, so we translate everything...we build a fractal image generator and generate some fractals...so how do we do this?
What is this? Like ok, umm...so like you take an "a", or a "1", and copy its shape, then generate it with a fractal. The
answer is within. You have to figure out how to do that, either way.

Ok:

Cinder
	if
		installed
			if
				logged-in
					view
					login
			install

So we have a "thing" called "if", and so on and so forth. So freaking ok, umm...so if you work your pattern through this
structure what do you end up with? Ok so "if" is relatively straight forward. I guess so is "installed":

installed
	if
		database
			if
				tables
					if
						user
							1
							install
					install
			install

So freaking ok, umm...and then what about install, since that's where the action starts (in terms of a storage mechanism):

install
	if
		database
			if
				tables
					if
						user
							1
							insert
					create
			create

So ok, like what we do is go...ok so we have...whoa huh...like ok the way this would work is all of the functions would be
like nested inside of one another in one great chain, and then...the thing is inline. Ok...:

Cinder
	if
		database
			if
				tables
					if
						user
							if
								logged-in
									view
									login
							if
								insert
									Cinder
									install
					if
						create
							Cinder
							install
			if
				create
					Cinder
					install

Ok so then we have something like before insert, after insert, so on and so forth, and like what we do is...ok so if we can
like figure out what one of these things is we can figure this out dude...it is one. It is one now, and it is one then.
Freaking like ok so what you do is...so ok lets take something simple like boolean or something, so hit or miss, true or
false...or rather lets take object since it has no two settings, since it is one thing, or lets take null since it is simple:
ok so like it is inert because it has no methods or anything like that, nothing we can call, so you have to DO something with
it. Fucking a. Smoke one dude.

Ok, so what do we do dude? What do we DO? Freaking DUDE you are getting close! Closer and closer...:

mariadb
	select
		before
		after
	insert
		...
	create
	update
	delete
...

before
SELECT * FROM `table_name`
after
...

select
	range
	from
	limit
		start
		end
	order
		ascending
		descending

Ok umm...so there is no before or after something like the individual characters of the select statement itself, so like...we
would (at least) contaminate the statement and make it unusable. Or, I mean is mariadb capable of such stuff? Does it even
matter? It doesn't even matter, relatively speaking once you figure THAT out you figure THAT out. Two different THATs. :) Ok
umm...so like yea then we just have a before and after event for the statement...so then we call the statement...

Freaking ok man, so like we code this bad boy...or somesuch...so like what we do is start mapping something out with this
thing, so like a maria connector or something, and freaking go from there. So like ok, umm...freaking like ok, umm, we would
freaking...like...basically we would just code the thing...like the only thing...ok so take a feature of this thing and work
it down...

Ok so the thing would have like the ability to select a column, so like we would go:

SELECT `column_name` FROM `table_name` LIMIT etc.

So like freaking ok, umm...so we break stuff up into functions...so like basically what you have to do is break everything
down IN TERMS of one thing, to de-relativize everything, so what if you break everything down to TWO things and then just go
one little step further and break things all the way down and voila, extrapolator? Freaking a, umm...how do we do this
quickly? Freaking a...ok so if we have two things, an object and a method...so like then we have one thing, an object, so...
yea ok we have an object, and? And we freaking...so like ok, what if we do this: what if we make everything out of objects, so
freaking EVERYthing, so like we have a single object, and that object has properties that are strings and stuff, and THOSE are
objects, and like all of it's returns are objects, so everything, inside and out, is an object. Then what we do is go ok, so
how does all this stuff come together to form a universal algorithm (that we can query)?

Umm hmm...so like you need to map out...ok so you map out a module, or like a class, of this thing, of your CMS, and like what
you do is go ok, so freaking...so like basically what we have is everything is made out of functions, and then we have hooks
before and after each function, before and after ANY function. Freaking a.

Ok, IF you build a system for building stuff you ARE one step closer to what you want, so like how do you do that? Ok so we
would have our CMS, which we would have built with our generator, so like...ok how would we build this with a generator? WHY
would we build this with a generator? Umm...huh...

Ok so lets go back to our syntax for generating stuff and lets generate a CMS:

Cinder
	if
		installed
			if
			if
				configuration
					if
						database
							if
								tables
									if
										user
											Cinder
											Cinder
									Cinder
							Cinder
					Cinder
...

Ok so we would have like a whole 'nother layer of "code", so like a layer that controlled the generation of the code itself
where we would "program" the thing to generate certain code. So freaking ok, umm...it's like code itself, it's like php code.
Maybe it's not, it's not, but it's SO CLOSE that it's like php code. Fucking a. So like what we have to do is define the data
itself, and then the logic to handle the data with. Which is like code. That's like a description of code.

Ok so like 45 seconds left in the day, I'm out for the day.

Ok I'm back. Fucking a. What are we going to get done today? So I figure what we need to do is go from the top all the way
down, so what we do is just go down, or maybe pick a really simple spot ("1"?) and go down from there. Once we get THERE we
just reverse flow and actually build the thing. So the beauty in this is what we are doing is freaking getting everything,
EVERYTHING, down to a point. So like your deepest fears, your greatest dreams, all down to a point. Fucking so bad.

Ok so lets get to work, what do we do here? Ok so if we BUILD the thing that BUILDS the thing what do we get? Like then we get
a thing that builds a thing, so like what is THAT? Freaking like ok, umm...so we build a library, a collection, of
generalizations and then build everything out of those. We can constantly update that collection at will and freaking build
whatever we want to out of it. So freaking ok, umm...does this make sense? Is it more efficient than building stuff from
scratch? IF it makes one out of two then it is more efficient than building stuff from scratch. And this it does! So freaking
that is what that is dude. So then you just hit it with your refinery...yea that makes sense...then like what we do is...build
the freaking collection...so what if we generate the collection? Based on an algorithm that accounts for all the general stuff
we would need to build a website we generate this collection. IF you can get that done you just generate the whole damned
thing! Fucking ok, so like umm...so we generate either way. So like the problem with this at this point is that there is no
contrast, there are two things and they are the same color and everything, literally they are the same thing. Like there is
only one thing. Which like is a problem because there are two of them. No idea what that means. What does it MEAN when there
are two of exactly one thing? Like that doesn't even make sense. Anyways that's where I'm at with this thing.

Ok so if we generate algorithms with an algorithm we have this thing in the box. It's inside the box, is what I mean. It's
php (code), we can generate conditionality and data and stuff. So all we have to do is refine THAT to a point and we have an
extrapolator. Fuckin' a.

Ok, umm...so what is one of these algorithms that we are generating?

Our CMS.

Ok, so umm...so you generate conditionality, data, loops, all that with an algorithm. So like what this means is we take some
input (ideally we do this as well as run the thing automatically) and freaking translate into an algorithm, so all we have to
do is figure out how to translate the input into an algorithm, and THAT is simply a matter of interpreting the input a certain
way. The input itself is constant, the output dependent on that input is what changes. Mmk? Make sense?

Ok, umm...ok so if we build the CMS we end up with a snapshot of the algorithm. All we have to do is reverse engineer THAT to
get what we want, like if that's the general process the thing takes to build something...that IS the algorithm. So basically
we just go if something happens we do something, otherwise we do something else, and then we loop through data and so on and
that's it! Fucking a dude you're like getting REALLY close...:

Cinder
	installed
		if
			database
				if
					tables
						if
							user
								create
								create
						create
				create
	view
	login
	install
	if
		installed
			if
				logged-in
					view
					login
			install
...

Ok so by programming you ARE somewhat doing this. It's entirely inefficient, but you're doing it. So then what we do is...:

<?php

$array = [0, 1];
$looping = false;

echo "<pre>";
foreach ($array as $value) {
	
	if ($looping) {
		
		echo "$value\n";
		
	}
	
}
echo "</pre>";

?>

...ok so the simple fact of the matter is we wouldn't put the condition for a loop inside of the loop itself. It's redundant.
We just check the condition before we start the loop. Also then you don't have the computer looping for no reason too, when
you could reduce the number of iterations to one by just checking the condition before you loop.

Fucking a.

Ok, umm...so ok, if we had some input that was one of two things there is the possibility that we could flip the meaning of
these two things, so that you have no control over the input, at which point there is (at least) no difference, so
hypothetically the semantic is constant.

And that defines the length of the thing in binary, so now we just have to, literally, translate binary to something more
readable and we're done.

Ok so what if we go back to the point where we account for all data, or something like that, where like we freaking come up
with 100% of something (from this point)? So like any value has a type, and like that's basically all there is to that. So
then we just assign our values...

Ok freaking a, so I'm thinking like we break this thing down, we program what we have and see what we get. So like what we
have is...freaking...umm...freaking like...freaking like we code what we have then we work our way down from there...duh...
like we have the numbers, we just need the algorithm. Or something like that. Basically it's on the tip of my tongue, I'm
having a hard time wording it, but I think I know where to go from here...ok so IF I know how to generate the LOGIC all I do
is run the thing through the logic and GENERATE ANYTHING! Fucking a. So like how do we "generate logic"? This is so freaking
dope dude, if this works your digital art goes through the fucking roof dude, freaking maxed out. So like freaking all you do
is go ok, match the thing to what you DO have, then freaking find the route down (INSIDE of THAT). That's totally what that is
is like the solution is in something that works a little bit.

Fucking a.

Ok so you FIT the thing to...so you manually write code that uses completely reusable libraries, so then you GENERATE those
libraries, you don't manually code those (you don't manually code anything). So freaking what you have to figure out is the
algorithm for doing THAT. THAT is AT LEAST what THIS IS. So then you have to like detect features and stuff, like html
(itself), js, etc. So freaking how you do THAT is...like a giant leap from where you are. BUT it's totally possible.

So ok, what you do is generate these reusable libraries somehow...so freaking how do you do this? There is an algorithm that
ALL of this stuff fits, so all we have to do is fit the thing to that algorithm, so...so ok then you think like ok, so this
algorithm is (at least) completely flexible, it can produce anything. So what that means is we don't just generate something
that looks like "fopen", etc., we generate something that is like super-logical, so like something that makes sense of the
fibers of words, not just the words themselves.

So ok, in order to get THIS down you have to get EVERYTHING down, so what we do is go ok, everything is DOWN, now we just
figure out what we've made. You know something fun you could do is come up with a fractal image generator: then you have to
map out pixels until you get the correct image...pixels are "units" of "view". Point being a unit is a unit. AND you could
gift Sunshine with the thing when it's done.

You know what would be badder though dude is a total system for fractal images, so like a thing catalogues their algorithms,
the images themselves, so on and so forth, all categorized and everything.

Yea that would be bad. You know what would be even badder is a system that RAPIDLY came up with computer programs, so like if
you think, like lets say this thing generated a fractal image production program: the algorithm would be no more complex than
that of one which generated fractal images. Although complex, not THAT complex. So freaking ok, umm...so like how do we do
that, lol. :) That's like massively complex...you have to build a thing that builds a thing. So ok, what if we build ONE thing
with this thing? Then we build a bunch of stuff with it...freaking like...

Ok what would it take to generate a fractal generator?

:

<?php

function fork($configuration = []) {
	
	if (count($configuration) > 0) {
	
	
	
	}
	foreach ($)
	if ($condition)
		$onSuccess();
	else
		$onFailure();
	
}
function onSuccess() {
	
	
	
}
function onFailure() {
	
	
	
}


?>
...

Ok if we freaking create a fork function we create a fork function, because of the technicalities of something like if or
switch there is like no way to emulate their behavior in php, therefore the solution to this problem is, simply, somewhere
else. BUT, what we do is go THERE and get it done!

:

<?php

class Fork {
	
	private $configuration = [];
	private $return = "";
	private $break = false;
	
	public function __construct($configuration = []) {
		
		if ($this->setConfiguration($configuration))
			$this->fork();
		
	}
	public function setConfiguration($configuration = []) {
		
		if (isset($configuration["cases"]) && count($configuration["cases"]))
			return $this->configuration = $configuration ? 1 : 0;
		else
			return 0;
		
	}
	public function getConfiguration() {
		
		return $this->configuration;
		
	}
	public function setReturn($return = "") {
		
		return $this->return = $return ? 1 : 0;
		
	}
	public function getReturn() {
		
		return $this->return;
		
	}
	public function setBreak($break = true) {
		
		return $this->break = $break ? 1 : 0;
		
	}
	public function getBreak() {
		
		return $this->break;
		
	}
	public function fork() {
		
		foreach ($this->configuration as $case) {
			
			if (isset($case["default"]) &&
				$case["default"] ||
				$case["condition"]) {
				
				$this->return .= $case["callback"]();
				if ($this->break)
					return $this->return;
				
			}
			
		}
		return $this->return;
		
	}
	
}

$configuration = [
	"cases" => [
		
	],
	"default" => [
		
	]
];

?>

Untested. But like what we do is go ok, umm...eat some hummus and carrots. :) Yea that's what we do...as to whether or not we
actually do that do we do that or not? 1 || 0 == 1 :D

Ok so freaking what else? Ok so like do we have like a switch statement or something more like an if statement? On the broad
side we would have a switch, on the narrow an if. So like we freaking have a switch statement up until the point that we need
something narrower. And that is, at least, what that is.

Ok so we freaking know that this thing is (at least) a value, because we need a value (an expression, which results in a
value) to fork, so freaking umm...

Ok so like specifically this thing would be an object and then a function inside of the constructor of the object, so that we
have recursion. Then we freaking lay everything out from that point on, so it would be, at least, a function, so like anything
a function can do, anything a function can handle, freaking like wow dude, freaking so bad. So ok the thing is dude what this
would be is a single function call, no looping, no recursion. So like what we would do is...so like the thing is dude that's
how you do that! That's how you do that, at least! Fuck yea dude! That's how you do!

Freaking ok man, umm...so now just describe something that "does everything", so descibe the general process for handling
something from within that function. Freaking ok, so we would basically just handle it, so like what we would do is loop and
everything like that from within that function, so like what we would do is we would either have a condition, or not, and then
like a loop and whatnot, or not. So freaking ok, umm...

So freaking ok, what this thing would be, then, is at least any old computer program. So like...ok dude, nothing to it but to
freaking run it down, what would any old computer program be?

So lets take our CMS: the thing would fire up, check to see if it was installed, and then that is a "thing", so basically what
we have is a condition and a function call (dependent on that condition). So freaking one condition, two functions. So ok,
like umm...what we do is...freaking answer the call dude. Fucking get your ass up dude, freaking do this dude. Your life, at
least, depends on it. Just focus and get it done. Or don't, but still get it done. Or don't, but if you don't you're fucked
and that's just plain what you get.

Ok, umm...so the ENTIRETY of the CMS would be...do we even need to know what that is? It's a series of forks. So ok, what you
do is fork, if you fork, and not, if you don't. THAT is what that is. It IS possible to have a logic-less computer program,
just in case. So freaking ok, umm...so otherwise what we do is:

Cinder
	if
		installed
			if
				logged-in
					view
					login
			install

And like that's all there is to it. So freaking what we have is like a series of functions...

So like ok the thing is dude the whole thing carries integrity throughout the whole structure of the thing, throughout the
whole thing, inside and out. Fucking a dude I'm gonna cry dude. This is so fucking bad.

So fucking bad. :)

Ok dude, so freaking what that means is you have two options, freaking go directly at it or circle around the perimeter and
look for a weak spot. Either way is faster.

Ok dude so like what we do is account for every possible thing dude, so so far what is a thing dude? Dude this is so freaking
bad dude! Holy shit you need to like celebrate or something...you need to do SOMETHING to mark this point dude, I mean this is
fucking it dude! This is all you get!

Freaking ok, umm...

So like dude...your charge is to create two things, then mesh them together to create one thing! Like all you have to do is
make two things and then generalize them into one thing, so like generalize all of the code and everything until you can
successfully build everything out of one thing. The closer the better.

So freaking ok, lets say we had two things, we would need control stuff, so like if/switch, and we would need functions for
looping and recursion, and like that's it. So freaking what we do is...just sit here and figure this shit out. This is so, SO
fucking bad. I mean dude complete and total control dude, 100% control, you can do WHATEVER, WHAT EVER, you want with that.
Fuck yes dude, this is straight high-quality work, keep going dude.

Ok, fucking a, how do we do this?

So like what we do is...fuck dude this is BAD...100% BAD...ok freaking what we do is...so like ok, what we do is go ok, IF we
had two of these things what we would do is like...ok so we would program every single little thing so that we could always
"get under" the code by modifying the underlying functions of it. So like if we had an "if" function, and we wanted to alter
the way it functioned, we could just alter the function (instead of picking through the program and re-coding every if
statement we find). Fuckin' a. So that is, at least, what we do. So freaking ok, umm...hmm...what we do is go...like...we need
to freaking squeeze this out dude omfg so close...mofo get that shit down! Down to the earth!

Ok mofo, what this is is everything is one thing, so what we do is simply work that all-throughout the system and voila, you
have a completely flexible system. Freaking the reason for this is is that ok, you generalize two things to create one thing,
since everything is made out of one thing, and that's like HOW you do this dude, so from there the thing IS intact, and you
like freaking go from there, then you build everything piecemeal and voila, it's working.

Pow!

Ok so how do we freaking do this dude...this is so fucking bad...

Ok so the thing is already, technically, extrapolating because it's taking a small amount of input and producing a large(r)
amount of output. So freaking all we have to do is break everything down at this point until we have the smallest bits
possible, then build the thing out of whatever that is.

So freaking ok, the plug-in generator takes some syntax that defines the general layout of the plug-in and creates the plug-in
itself out of this syntax. So freaking ok, umm...the syntax defines the "array" of the plug-in, the table that stores all the
data for the plug-in, that sort of thing. So like, specifically, what we do is go ok, so we generate something, we need to
generally know the "array" of that thing, so like...so basically we have an array, just we loop through that array whether
there are one or more elements to that array. So freaking ok, that defines that...then we conditionally loop, just in case we
DON'T want to loop, and like that's it. We just loop through the data, display it on the screen, etc., and like that's it.
Fucking a. THAT'S what that is. Always wondered what that is.

Ok, so we freaking loop through our data, so like we go ok, we HAVE some data...what if we don't have any data? This, THIS is
fucking SO bad. Dude that's what that is. That's at least what that is. Freaking a ok, umm...so if there's no variability, no
variables, there's no "computer program", or there is one, just it's completely constant. Nothing changing, at all, no
freaking timestamps, nothing. So freaking ok, like what we do is go ok, IF there is variability, what is something? So then
it's, say, an array, and what we do is conditionally loop through that array, conditionally doing stuff with the elements of
that array as we cruise along. So like ok, umm...what this is is...freaking like...

TEN THOUSAND FISTS IN THE AIIIIIIIIIR!

Ok dude, lets freaking nail this thing in the butt. So freaking what this is is a fundamental version of the plug-in
generator. So freaking what we do is...freaking nail it right in the ass. Ooo yea baby that's what I like. Ok freaking umm...
so like freaking what we do is...freaking like...

What we do is freaking...like...bust a freaking nut dude...so like we freaking take the freaking thing and go ok, so we go ok,
we take the syntax and break it down until we get what we want, until we account for every one thing. So freaking what this is
is...:

define array
	database definition
		table definition

Umm...so we freaking define the array, we structure the array...why an array? Because we're accounting for one or more things.
So we HAVE an array, we already know this. Review your notes? It's all in your head. Freaking so you have a plug-in generator,
like maybe what would the syntax for this thing look like? So ok we define the array structure of everything, the users and
the pages, and anything else we need to handle, and then we connect everything together with logic. Makes good sense. Seems
ok, because then what we would do is define the data itself...this makes a lot of sense. From there we define the actual view
itself, and that is like all that is. See, once we have the data, the users, the pages, etc., all we have to do is define the
actual logic, the logical progression, of the thing. So freaking what this is is...

Ok so what I'm thinking is that the logic of the thing is patterned, and therefore we can directly incorporate it into the
system. So freaking what we do is...freaking build it! That's like it is we build it, at that point we have both data and
logic, ying and yang, the thing is complete. Fuckin' a. Ok, umm...so then lets go like...

Freaking umm...what we do is freaking program this thing dude...but you know what, lets code it IN HERE before we code it IN
THERE! Then we're like poop, and we just poop the thing out and it's a completely natural process. :) Hah. Ok anyways...umm...
so like freaking what we do is...

Ok man, that is that dude! And that is how you freaking do that.